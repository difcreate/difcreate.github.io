<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>difcreate&#39;s blog</title>
  
  <subtitle>偷得浮生半日闲</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xhjiang.tech/"/>
  <updated>2018-11-20T07:19:35.335Z</updated>
  <id>https://xhjiang.tech/</id>
  
  <author>
    <name>difcreate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode刷题-13.Roman to Integer</title>
    <link href="https://xhjiang.tech/2018/11/20/leetcode%E5%88%B7%E9%A2%98-Roman-to-Integer/"/>
    <id>https://xhjiang.tech/2018/11/20/leetcode刷题-Roman-to-Integer/</id>
    <published>2018-11-20T07:08:44.000Z</published>
    <updated>2018-11-20T07:19:35.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer-罗马数字转整数"><a href="#13-Roman-to-Integer-罗马数字转整数" class="headerlink" title="13. Roman to Integer-罗马数字转整数"></a>13. Roman to Integer-罗马数字转整数</h1><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;13-Roman-to-Integer-罗马数字转整数&quot;&gt;&lt;a href=&quot;#13-Roman-to-Integer-罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;13. Roman to Integer-罗马数字转整数&quot;&gt;&lt;/a&gt;13. 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-122.Best Time to Buy and Sell Stock II</title>
    <link href="https://xhjiang.tech/2018/11/20/leetcode%E5%88%B7%E9%A2%98-Best-Time-to-Buy-and-Sell-Stock-II/"/>
    <id>https://xhjiang.tech/2018/11/20/leetcode刷题-Best-Time-to-Buy-and-Sell-Stock-II/</id>
    <published>2018-11-20T06:22:32.000Z</published>
    <updated>2018-11-20T07:19:16.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II" class="headerlink" title="122.Best Time to Buy and Sell Stock II-买卖股票的最佳时机 II"></a>122.Best Time to Buy and Sell Stock II-买卖股票的最佳时机 II</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>贪心算法，总是做出在当前看来是最好的选择，不从整体最优上加以考虑，也就是说，只关心当前最优解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>,tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            tmp = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)</span><br><span class="line">                max += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>我们要算的是利润，要有利润，自然要有一次交易。<br>所以我们就说说prices[1]，即是第一天股票价格。按照贪心策略，不关心以后，我们只关心当前利益。第0天买入，花费prices[0]，第一天卖出，得到prices[1]，那么我们的收获就是max = prices[1] - prices[0],那么有两种情况</p><p>1）当max &gt; 0 时，赶紧买入卖出，能赚一笔是一笔，苍蝇再小也是肉嘛 </p><p>2）当max &lt;= 0 时，再买入卖出的话，那就是傻了，白费力气不说，还亏钱。</p><p>以此方式类推下去，即得最大利润。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/categories/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-决策树原理及实战(一)</title>
    <link href="https://xhjiang.tech/2018/11/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/"/>
    <id>https://xhjiang.tech/2018/11/19/机器学习-决策树原理及实战/</id>
    <published>2018-11-19T08:18:30.000Z</published>
    <updated>2018-11-19T09:40:14.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习-决策树原理及实战-一"><a href="#机器学习-决策树原理及实战-一" class="headerlink" title="机器学习-决策树原理及实战(一)"></a>机器学习-决策树原理及实战(一)</h1><hr><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是什么？决策树(decision tree)是一种基本的分类与回归方法。举个通俗易懂的例子，如下图所示的流程图就是一个决策树，长方形代表判断模块(decision block)，椭圆形成代表终止模块(terminating block)，表示已经得出结论，可以终止运行。从判断模块引出的左右箭头称作为分支(branch)，它可以达到另一个判断模块或者终止模块。我们还可以这样理解，分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点(node)和有向边(directed edge)组成。结点有两种类型：内部结点(internal node)和叶结点(leaf node)。内部结点表示一个特征或属性，叶结点表示一个类。蒙圈没？？如下图所示的决策树，长方形和椭圆形都是结点。长方形的结点属于内部结点，椭圆形的结点属于叶结点，从结点引出的左右箭头就是有向边。而最上面的结点就是决策树的根结点(root node)。这样，结点说法就与模块说法对应上了，理解就好。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_1.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDo0bmLPfbfgzegr1ie8G5q8r2MOI6n9nU&amp;q-sign-time=1542615956;1542617756&amp;q-key-time=1542615956;1542617756&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=332b7d6eefee6b6b7e6452cc1399a1ede9fbc4fe&amp;x-cos-security-token=5a09803f8532adcdcaf3e993afe6031a505ccfe510001" alt=""></div></p><p>我们回到这个流程图，对，你没看错，这就是一个假想的相亲对象分类系统。它首先检测相亲对方是否有房。如果有房，则对于这个相亲对象可以考虑进一步接触。如果没有房，则观察相亲对象是否有上进心，如果没有，直接Say Goodbye，此时可以说：”你人很好，但是我们不合适。”如果有，则可以把这个相亲对象列入候选名单，好听点叫候选名单，有点瑕疵地讲，那就是备胎。</p><p>不过这只是个简单的相亲对象分类系统，只是做了简单的分类。真实情况可能要复杂得多，考虑因素也可以是五花八门。脾气好吗？会做饭吗？愿意做家务吗？家里几个孩子？父母是干什么的？天啊，我不想再说下去了，想想都可怕。</p><p>我们可以把决策树看成一个if-then规则的集合，将决策树转换成if-then规则的过程是这样的：由决策树的根结点(root node)到叶结点(leaf node)的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。决策树的路径或其对应的if-then规则集合具有一个重要的性质：互斥并且完备。这就是说，每一个实例都被一条路径或一条规则所覆盖，而且只被一条路径或一条规则所覆盖。这里所覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p><p><strong>使用决策树做预测需要以下过程：</strong></p><ul><li><p>收集数据：可以使用任何方法。比如想构建一个相亲系统，我们可以从媒婆那里，或者通过采访相亲对象获取数据。根据他们考虑的因素和最终的选择结果，就可以得到一些供我们利用的数据了。</p></li><li><p>准备数据：收集完的数据，我们要进行整理，将这些所有收集的信息按照一定规则整理出来，并排版，方便我们进行后续处理。</p></li><li><p>分析数据：可以使用任何方法，决策树构造完成之后，我们可以检查决策树图形是否符合预期。</p></li><li><p>训练算法：这个过程也就是构造决策树，同样也可以说是决策树学习，就是构造一个决策树的数据结构。</p></li><li><p>测试算法：使用经验树计算错误率。当错误率达到了可接收范围，这个决策树就可以投放使用了。</p></li><li><p>使用算法：此步骤可以使用适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。</p></li></ul><hr><h2 id="2-决策树的构建的准备工作"><a href="#2-决策树的构建的准备工作" class="headerlink" title="2.决策树的构建的准备工作"></a>2.决策树的构建的准备工作</h2><p>使用决策树做预测的每一步骤都很重要，数据收集不到位，将会导致没有足够的特征让我们构建错误率低的决策树。数据特征充足，但是不知道用哪些特征好，将会导致无法构建出分类效果好的决策树模型。从算法方面看，决策树的构建是我们的核心内容。</p><p>决策树要如何构建呢？通常，这一过程可以概括为3个步骤：特征选择、决策树的生成和决策树的修剪。</p><h3 id="2-1-特征选择"><a href="#2-1-特征选择" class="headerlink" title="2.1 特征选择"></a>2.1 特征选择</h3><p>特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率，如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。通常特征选择的标准是信息增益(information gain)或信息增益比，为了简单，本文使用信息增益作为选择特征的标准。那么，什么是信息增益？在讲解信息增益之前，让我们看一组实例，贷款申请样本数据表。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_2.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDcUidFOx6g1skcSVTRv9rLw2Yc5mVWxLK&amp;q-sign-time=1542616252;1542618052&amp;q-key-time=1542616252;1542618052&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=905b0b542300a4058c836d61d61c3ac20c863d57&amp;x-cos-security-token=03747c4a3672eba87137fa78e3f603e693f2084c10001" alt=""></div></p><p>希望通过所给的训练数据学习一个贷款申请的决策树，用于对未来的贷款申请进行分类，即当新的客户提出贷款申请时，根据申请人的特征利用决策树决定是否批准贷款申请。</p><p>特征选择就是决定用哪个特征来划分特征空间。比如，我们通过上述数据表得到两个可能的决策树，分别由两个不同特征的根结点构成。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_3.jpg?q-sign-algorithm=sha1&amp;q-ak=AKID7LoSNbZ3PaXBMUDmiyHD5b80PtM7mLge&amp;q-sign-time=1542616298;1542618098&amp;q-key-time=1542616298;1542618098&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=571430898b051ee3d211c06be3e5243329c1c61a&amp;x-cos-security-token=ec57b9d67f7a3fe8e41d393f82e1337fbb4d871510001" alt=""></div></p><p>图(a)所示的根结点的特征是年龄，有3个取值，对应于不同的取值有不同的子结点。图(b)所示的根节点的特征是工作，有2个取值，对应于不同的取值有不同的子结点。两个决策树都可以从此延续下去。问题是：究竟选择哪个特征更好些？这就要求确定选择特征的准则。直观上，如果一个特征具有更好的分类能力，或者说，按照这一特征将训练数据集分割成子集，使得各个子集在当前条件下有最好的分类，那么就更应该选择这个特征。信息增益就能够很好地表示这一直观的准则。</p><blockquote><p>什么是<strong>信息增益</strong>呢？在划分数据集之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。</p></blockquote><p><strong>1)香农熵</strong></p><p>在可以评测哪个数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合信息的度量方式称为香农熵或者简称为熵(entropy)，这个名字来源于信息论之父克劳德·香农。</p><p>如果看不明白什么是信息增益和熵，请不要着急，因为他们自诞生的那一天起，就注定会令世人十分费解。克劳德·香农写完信息论之后，约翰·冯·诺依曼建议使用”熵”这个术语，因为大家都不知道它是什么意思。</p><p>熵定义为信息的期望值。在信息论与概率统计中，熵是表示随机变量不确定性的度量。如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为 ：<br>$$l(x_i) = -\log_2 p(x_i)$$</p><p>其中p(xi)是选择该分类的概率。有人可能会问，信息为啥这样定义啊？答曰：前辈得出的结论。这就跟1+1等于2一样，记住并且会用即可。上述式中的对数以2为底，也可以e为底(自然对数)。</p><p>通过上式，我们可以得到所有类别的信息。为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值(数学期望)，通过下面的公式得到：<br>$$H = -\sum_{i=1}^{n}p(x_i)\log_2 p(x_i) \qquad$$</p><p>期中n是分类的数目。熵越大，随机变量的不确定性就越大。</p><p>当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为经验熵(empirical entropy)。什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。我们定义贷款申请样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ：<br>$$H(D) = -\sum_{k=1}^{K} \frac {|C_k|}{|D|} \log_2 \frac {|C_k|}{|D|} \qquad$$</p><p>根据此公式计算经验熵H(D)，分析贷款申请样本数据表中的数据。最终分类结果只有两类，即放贷和不放贷。根据表中的数据统计可知，在15个数据中，9个数据的结果为放贷，6个数据的结果为不放贷。所以数据集D的经验熵H(D)为：<br>$$H(D) = -\frac{9}{15} \log_2\frac{9}{15}-\frac{6}{15} \log_2\frac{6}{15} = 0.971 \qquad$$</p><p>经过计算可知，数据集D的经验熵H(D)的值为0.971。</p><p><strong>2)编写代码计算经验熵</strong></p><p>在编写代码之前，我们先对数据集进行属性标注。</p><ul><li>年龄：0代表青年，1代表中年，2代表老年；</li><li>有工作：0代表否，1代表是；</li><li>有自己的房子：0代表否，1代表是；</li><li>信贷情况：0代表一般，1代表好，2代表非常好；</li><li>类别(是否给贷款)：no代表否，yes代表是。</li></ul><p>确定这些之后，我们就可以创建数据集，并计算经验熵了，代码编写如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:创建测试数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">    labels - 分类属性</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],  <span class="comment"># 数据集</span></span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'不放贷'</span>, <span class="string">'放贷'</span>]  <span class="comment"># 分类属性</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels  <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:计算给定数据集的经验熵(香农熵)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    shannonEnt - 经验熵(香农熵)</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numEntires = len(dataSet)  <span class="comment"># 返回数据集的行数</span></span><br><span class="line">    labelCounts = &#123;&#125;  <span class="comment"># 保存每个标签(Label)出现次数的字典</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]  <span class="comment"># 提取标签(Label)信息</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():  <span class="comment"># 如果标签(Label)没有放入统计次数的字典,添加进去</span></span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment"># Label计数</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵(香农熵)</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:  <span class="comment"># 计算香农熵</span></span><br><span class="line">        prob = float(labelCounts[key]) / numEntires  <span class="comment"># 选择该标签(Label)的概率</span></span><br><span class="line">        shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># 利用公式计算</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt  <span class="comment"># 返回经验熵(香农熵)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dataSet, features = createDataSet()</span><br><span class="line">    print(dataSet)</span><br><span class="line">    print(calcShannonEnt(dataSet))</span><br></pre></td></tr></table></figure><p>代码运行结果如下图所示，代码是先打印训练数据集，然后打印计算的经验熵H(D)，程序计算的结果与我们统计计算的结果是一致的，程序没有问题。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_8.jpg?q-sign-algorithm=sha1&amp;q-ak=AKID7xfLaZY0Sf90r7bU4ZIQQPFld0ShPaLj&amp;q-sign-time=1542618680;1542620480&amp;q-key-time=1542618680;1542620480&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=796c7027aa9403cc50084ae1b420bef12fcefca8&amp;x-cos-security-token=c71fa4695aae6d64d7ba3551fe73072e003d9af210001" alt=""></div></p><p><strong>3)信息增益</strong></p><p>在上面，我们已经说过，如何选择特征，需要看信息增益。也就是说，信息增益是相对于特征而言的，信息增益越大，特征对最终的分类结果影响也就越大，我们就应该选择对最终分类结果影响最大的那个特征作为我们的分类特征。</p><p>在讲解信息增益定义之前，我们还需要明确一个概念，条件熵。</p><p>熵我们知道是什么，条件熵又是个什么鬼？条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，随机变量X给定的条件下随机变量Y的条件熵(conditional entropy)H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望：<br>$$H(Y|X) = -\sum_{i=1}^{n} p_i H(Y|X=x_i) \qquad$$</p><p>这里，<br>$$p_i = P(X = x_i),i = 1, 2,…,n$$</p><p>同理，当条件熵中的概率由数据估计(特别是极大似然估计)得到时，所对应的条件熵称为条件经验熵(empirical conditional entropy)。</p><p>明确了条件熵和经验条件熵的概念。接下来，让我们说说信息增益。前面也提到了，信息增益是相对于特征而言的。所以，特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即：<br>$$g (D,A) = H(D) - H(D|A)$$</p><p>一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p><p>设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数。于是经验条件熵的公式可以些为：<br>$$H(D|A) = \sum_{i=1}^{n} \frac {|D_i|}{|D|}H(D_i) = -\sum_{i=1}^{n} \frac {|D_i|}{|D|}\sum_{k=1}^{K} \frac {|D_{ik}|}{|D_i|} \log_2 \frac {|D_{ik}|}{|D_i|}$$</p><p>说了这么多概念性的东西，没有听懂也没有关系，举几个例子，再回来看一下概念，就懂了。</p><p>以贷款申请样本数据表为例进行说明。看下年龄这一列的数据，也就是特征A1，一共有三个类别，分别是：青年、中年和老年。我们只看年龄是青年的数据，年龄是青年的数据一共有5个，所以年龄是青年的数据在训练数据集出现的概率是十五分之五，也就是三分之一。同理，年龄是中年和老年的数据在训练数据集出现的概率也都是三分之一。现在我们只看年龄是青年的数据的最终得到贷款的概率为五分之二，因为在五个数据中，只有两个数据显示拿到了最终的贷款，同理，年龄是中年和老年的数据最终得到贷款的概率分别为五分之三、五分之四。所以计算年龄的信息增益，过程如下：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_13.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDdNqb8A6wqNlwt72O0cx4OIBpRKBDy6Z8&amp;q-sign-time=1542619737;1542621537&amp;q-key-time=1542619737;1542621537&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=d5bf3b836adeb09ab318fd15052dbe8bc07e534a&amp;x-cos-security-token=bfa078927345c660cac46791c51c6ec6410cacff10001" alt=""></div></p><p>同理，计算其余特征的信息增益g(D,A2)、g(D,A3)和g(D,A4)。分别为：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_14_m.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDSl7ywpwES4SEZ18ilCEH0T3bgKFszgXz&amp;q-sign-time=1542619793;1542621593&amp;q-key-time=1542619793;1542621593&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=9c306ce1b2af835bef3aa8cd67e1eb8e67a73ad3&amp;x-cos-security-token=7f741e6a28643d82f9a0cd1483c9474d1efe97c310001" alt=""></div></p><p>最后，比较特征的信息增益，由于特征A3(有自己的房子)的信息增益值最大，所以选择A3作为最优特征。</p><p><strong>4) 编写代码计算信息增益</strong></p><p>我们已经学会了通过公式计算信息增益，接下来编写代码，计算信息增益。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:计算给定数据集的经验熵(香农熵)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    shannonEnt - 经验熵(香农熵)</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numEntires = len(dataSet)  <span class="comment"># 返回数据集的行数</span></span><br><span class="line">    labelCounts = &#123;&#125;  <span class="comment"># 保存每个标签(Label)出现次数的字典</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]  <span class="comment"># 提取标签(Label)信息</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():  <span class="comment"># 如果标签(Label)没有放入统计次数的字典,添加进去</span></span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment"># Label计数</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵(香农熵)</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:  <span class="comment"># 计算香农熵</span></span><br><span class="line">        prob = float(labelCounts[key]) / numEntires  <span class="comment"># 选择该标签(Label)的概率</span></span><br><span class="line">        shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># 利用公式计算</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt  <span class="comment"># 返回经验熵(香农熵)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:创建测试数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">    labels - 分类属性</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],  <span class="comment"># 数据集</span></span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'不放贷'</span>, <span class="string">'放贷'</span>]  <span class="comment"># 分类属性</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels  <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:按照给定特征划分数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 待划分的数据集</span></span><br><span class="line"><span class="string">    axis - 划分数据集的特征</span></span><br><span class="line"><span class="string">    value - 需要返回的特征的值</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    retDataSet = []  <span class="comment"># 创建返回的数据集列表</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 遍历数据集</span></span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]  <span class="comment"># 去掉axis特征</span></span><br><span class="line">            reducedFeatVec.extend(featVec[axis + <span class="number">1</span>:])  <span class="comment"># 将符合条件的添加到返回的数据集</span></span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet  <span class="comment"># 返回划分后的数据集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:选择最优特征</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    bestFeature - 信息增益最大的(最优)特征的索引值</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 特征数量</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)  <span class="comment"># 计算数据集的香农熵</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>  <span class="comment"># 信息增益</span></span><br><span class="line">    bestFeature = <span class="number">-1</span>  <span class="comment"># 最优特征的索引值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):  <span class="comment"># 遍历所有特征</span></span><br><span class="line">        <span class="comment"># 获取dataSet的第i个所有特征</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        uniqueVals = set(featList)  <span class="comment"># 创建set集合&#123;&#125;,元素不可重复</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span>  <span class="comment"># 经验条件熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:  <span class="comment"># 计算信息增益</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)  <span class="comment"># subDataSet划分后的子集</span></span><br><span class="line">            prob = len(subDataSet) / float(len(dataSet))  <span class="comment"># 计算子集的概率</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)  <span class="comment"># 根据公式计算经验条件熵</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy  <span class="comment"># 信息增益</span></span><br><span class="line">        print(<span class="string">"第%d个特征的增益为%.3f"</span> % (i, infoGain))  <span class="comment"># 打印每个特征的信息增益</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):  <span class="comment"># 计算信息增益</span></span><br><span class="line">            bestInfoGain = infoGain  <span class="comment"># 更新信息增益，找到最大的信息增益</span></span><br><span class="line">            bestFeature = i  <span class="comment"># 记录信息增益最大的特征的索引值</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature  <span class="comment"># 返回信息增益最大的特征的索引值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dataSet, features = createDataSet()</span><br><span class="line">    print(<span class="string">"最优特征索引值:"</span> + str(chooseBestFeatureToSplit(dataSet)))</span><br></pre></td></tr></table></figure><p>splitDataSet函数是用来选择各个特征的子集的，比如选择年龄(第0个特征)的青年(用0代表)的自己，我们可以调用splitDataSet(dataSet,0,0)这样返回的子集就是年龄为青年的5个数据集。chooseBestFeatureToSplit是选择选择最优特征的函数。运行代码结果如下：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_17.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDXFJonnnEnE77YzSjHGXnVgA71i3hSz7C&amp;q-sign-time=1542620152;1542621952&amp;q-key-time=1542620152;1542621952&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=72e63ad8f9caf9c1aaded1fc2c462ac8a7d5c4b5&amp;x-cos-security-token=08d3672a0cc604a03b6686b7b2ebd4dc9c6dca9c10001" alt=""></div></p><p>对比我们自己计算的结果，发现结果完全正确！最优特征的索引值为2，也就是特征A3(有自己的房子)。</p><h2 id="决策树生成和修剪"><a href="#决策树生成和修剪" class="headerlink" title="决策树生成和修剪"></a>决策树生成和修剪</h2><p>我们已经学习了从数据集构造决策树算法所需要的子功能模块，包括经验熵的计算和最优特征的选择，其工作原理如下：得到原始数据集，然后基于最好的属性值划分数据集，由于特征值可能多于两个，因此可能存在大于两个分支的数据集划分。第一次划分之后，数据集被向下传递到树的分支的下一个结点。在这个结点上，我们可以再次划分数据。因此我们可以采用递归的原则处理数据集。</p><p>构建决策树的算法有很多，比如<strong>C4.5、ID3和CART</strong>，这些算法在运行时并不总是在每次划分数据分组时都会消耗特征。由于特征数目并不是每次划分数据分组时都减少，因此这些算法在实际使用时可能引起一定的问题。目前我们并不需要考虑这个问题，只需要在算法开始运行前计算列的数目，查看算法是否使用了所有属性即可。</p><p>决策树生成算法递归地产生决策树，直到不能继续下去未为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲解了如何计算数据集的经验熵和如何选择最优特征作为分类特征。决策树如何生成、修剪、可视化，以及整体实例练习，会在后续的文章中进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习-决策树原理及实战-一&quot;&gt;&lt;a href=&quot;#机器学习-决策树原理及实战-一&quot; class=&quot;headerlink&quot; title=&quot;机器学习-决策树原理及实战(一)&quot;&gt;&lt;/a&gt;机器学习-决策树原理及实战(一)&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;决策树&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="https://xhjiang.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://xhjiang.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-111.Minimum Depth of Binary Tree</title>
    <link href="https://xhjiang.tech/2018/11/19/leetcode%E5%88%B7%E9%A2%98-Minimum-Depth-of-Binary-Tree/"/>
    <id>https://xhjiang.tech/2018/11/19/leetcode刷题-Minimum-Depth-of-Binary-Tree/</id>
    <published>2018-11-19T07:44:56.000Z</published>
    <updated>2018-11-20T07:19:58.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度"><a href="#111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度" class="headerlink" title="111. Minimum Depth of Binary Tree-二叉树的最小深度"></a>111. Minimum Depth of Binary Tree-二叉树的最小深度</h1><hr><p><strong>描述：</strong><br>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回它的最小深度  2.</p><hr><p>递归方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//时间复杂度O(n),空间复杂度O(log(n))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(<span class="keyword">const</span> TreeNode *root, <span class="keyword">bool</span> hasbrother)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> hasbrother ? INT_MAX : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(minDepth(root-&gt;left, root-&gt;right != <span class="literal">NULL</span>),</span><br><span class="line">                       minDepth(root-&gt;right, root-&gt;left != <span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度&quot;&gt;&lt;a href=&quot;#111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;111. Minim
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-136.Single Number</title>
    <link href="https://xhjiang.tech/2018/11/19/leetcode%E5%88%B7%E9%A2%98-Single-Number/"/>
    <id>https://xhjiang.tech/2018/11/19/leetcode刷题-Single-Number/</id>
    <published>2018-11-19T06:33:55.000Z</published>
    <updated>2018-11-20T07:21:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="136-Single-Number-只出现过一次的数字"><a href="#136-Single-Number-只出现过一次的数字" class="headerlink" title="136. Single Number-只出现过一次的数字"></a>136. Single Number-只出现过一次的数字</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><blockquote><p><em>说明：</em><br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p></blockquote><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>题中要求，线性时间复杂度，而且不使用额外空间，那么就要从数组本身入手，同时只循环扫描一遍数组</p><p>我们可以考虑 异或运算 ，它是满足交换律和结合的，也就是说 a ^ b  ^c = a ^ c ^ b，这样当我们遍历数组，顺次进行异或运算，那么最终的结果就是唯一的不重复数字。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[4,1,2,1,2]，</span><br><span class="line">4^1^2^1^2 = 1^1^2^2^4 = 0^0^4=4</span><br></pre></td></tr></table></figure></p><p><strong>代码一：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//顺次异或，每当某个数字重复出现偶次都会被消除为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            x ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int singleNumber(int A[], int n) &#123;</span></span><br><span class="line"><span class="comment">//         int result = 0;</span></span><br><span class="line"><span class="comment">//         for(int i = 0;i &lt; n;i++)&#123;</span></span><br><span class="line"><span class="comment">//             result = result ^ A[i];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return result;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><p><strong>代码二：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//accumulate()函数用来求和，初始值为0，范围从begin到end的所有向量以位异或的方式求和</span></span><br><span class="line">        <span class="keyword">return</span> accumulate(nums.begin(), nums.end(), <span class="number">0</span>, bit_xor&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;136-Single-Number-只出现过一次的数字&quot;&gt;&lt;a href=&quot;#136-Single-Number-只出现过一次的数字&quot; class=&quot;headerlink&quot; title=&quot;136. Single Number-只出现过一次的数字&quot;&gt;&lt;/a&gt;136.
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-104.Maximum Depth of Binary Tree</title>
    <link href="https://xhjiang.tech/2018/11/17/leetcode%E5%88%B7%E9%A2%98-Maximum-Depth-of-Binary-Tree/"/>
    <id>https://xhjiang.tech/2018/11/17/leetcode刷题-Maximum-Depth-of-Binary-Tree/</id>
    <published>2018-11-17T05:56:48.000Z</published>
    <updated>2018-11-20T07:19:28.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度"><a href="#104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度" class="headerlink" title="104. Maximum Depth of Binary Tree-二叉树的最大深度"></a>104. Maximum Depth of Binary Tree-二叉树的最大深度</h1><hr><h2 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong>利用递归直接求解</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//若树为空则返回0</span></span><br><span class="line">        <span class="comment">//最后返回根节点的左右子树中深度较大的那个深度，最后加上根节点的深度</span></span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left),maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度&quot;&gt;&lt;a href=&quot;#104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;104. Maxim
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>华为机试-2.计算字符个数</title>
    <link href="https://xhjiang.tech/2018/11/17/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95-2-%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0/"/>
    <id>https://xhjiang.tech/2018/11/17/华为机试-2-计算字符个数/</id>
    <published>2018-11-17T05:23:18.000Z</published>
    <updated>2018-11-20T07:18:34.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-计算字符个数"><a href="#2-计算字符个数" class="headerlink" title="2.计算字符个数"></a>2.计算字符个数</h1><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</p><p>输入描述:<br>输入一个有字母和数字以及空格组成的字符串，和一个字符。</p><p>输出描述:<br>输出输入字符串中含有该字符的个数。</p><p><strong>示例1</strong><br>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEF A</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p><hr><p>思路：<br>第一反应就是可以把所有的字母输入都转为小写字母，或者所有的字母输入都转换为大写字母，简单直接，可能执行效率不是最好的，但是算法的思路挺简单的，两个循环就可以搞定，那么怎么实现这个字母转换呢。</p><p>这里我提供两种方法：</p><p>方法一就是判断所有的字母是否为A到Z之间的，如果是就直接加上’a’-‘A’，其实就是加上32，使其转换为大写字母，因为我们都知道小写字母的ASCII值比大写字母的大32。如程序中方法一所示的代码。</p><p>方法二直接使用string函数库中的处理函数tolower()函数直接处理，简单直接，如代码中的方法二的注释。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">char</span> p;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>,str); <span class="comment">//输入字符串，包括空格，遇到换行符即停止输入</span></span><br><span class="line">    p = <span class="built_in">cin</span>.get(); <span class="comment">//输入字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; str.length();++i)&#123;</span><br><span class="line">        <span class="comment">//方法二，把字符串所有字母都转换成小写字母</span></span><br><span class="line">        <span class="comment">//str[i] = tolower(str[i]); </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一，把所有小写字母都换成大写字母，同时判断字符是否为小写字母，如果是则换成大写字母</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] &gt;= <span class="string">'a'</span> &amp;&amp; str[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">            str[i] -= <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= <span class="string">'a'</span> &amp;&amp; p &lt;= <span class="string">'z'</span>)</span><br><span class="line">            p -= <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; str.length();++i)&#123;  <span class="comment">//若字符串str中某个字符等于字符p，则count+1，不区分大小写字母</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == p)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-计算字符个数&quot;&gt;&lt;a href=&quot;#2-计算字符个数&quot; class=&quot;headerlink&quot; title=&quot;2.计算字符个数&quot;&gt;&lt;/a&gt;2.计算字符个数&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="华为机试" scheme="https://xhjiang.tech/categories/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="华为机试" scheme="https://xhjiang.tech/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>华为机试-1.字符串最后一个单词的长度</title>
    <link href="https://xhjiang.tech/2018/11/16/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>https://xhjiang.tech/2018/11/16/华为机试-字符串最后一个单词的长度/</id>
    <published>2018-11-16T11:42:54.000Z</published>
    <updated>2018-11-20T07:18:47.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-字符串最后一个单词的长度"><a href="#1-字符串最后一个单词的长度" class="headerlink" title="1. 字符串最后一个单词的长度"></a>1. 字符串最后一个单词的长度</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>计算字符串最后一个单词的长度，单词以空格隔开。<br><strong>输入描述:</strong><br>一行字符串，非空，长度小于5000。</p><p><strong>输出描述:</strong><br>整数N，最后一个单词的长度。</p><p><strong>示例1: </strong><br>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str))&#123; <span class="comment">//若以cin输入字符串，遇到空格会结束；geiline则能输入整行，遇到换行符结束</span></span><br><span class="line">        str.erase(<span class="number">0</span>,str.find_first_not_of(<span class="string">" "</span>));<span class="comment">//这两行作用是去除首尾空格</span></span><br><span class="line">        str.erase(str.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">auto</span> iter1 = str.find_last_of(<span class="string">' '</span>);<span class="comment">//原来这类函数返回的是整数或string::npos(表示没有找到匹配值)</span></span><br><span class="line">        <span class="keyword">if</span>(iter1 == <span class="built_in">string</span>::npos)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str.size() - <span class="number">1</span>- iter1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-字符串最后一个单词的长度&quot;&gt;&lt;a href=&quot;#1-字符串最后一个单词的长度&quot; class=&quot;headerlink&quot; title=&quot;1. 字符串最后一个单词的长度&quot;&gt;&lt;/a&gt;1. 字符串最后一个单词的长度&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;描述：&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="华为机试" scheme="https://xhjiang.tech/categories/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="华为机试" scheme="https://xhjiang.tech/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-53.Maximum Subarray</title>
    <link href="https://xhjiang.tech/2018/11/16/leetcode%E5%88%B7%E9%A2%98-Maximum-Subarray/"/>
    <id>https://xhjiang.tech/2018/11/16/leetcode刷题-Maximum-Subarray/</id>
    <published>2018-11-16T11:42:14.000Z</published>
    <updated>2018-11-20T07:19:43.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-Maximum-Subarray-最大子序和"><a href="#53-Maximum-Subarray-最大子序和" class="headerlink" title="53. Maximum Subarray-最大子序和"></a>53. Maximum Subarray-最大子序和</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></p><blockquote><p><em>进阶:</em><br>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p></blockquote><hr><ul><li>解法一：动态规划</li></ul><p><strong>思路：</strong><br>当我们从头到尾遍历这个数组时，对于数组里的一个整数，他有几种选择呢？它只有两种选择：</p><ol><li>加入之前的SubArray;</li><li>自己另起一个SubArray。那什么时候会出现这两种情况呢？</li></ol><p>如果之前SubArray的总体之和大于0的话，那么就认为它对后续结果是有贡献的,这种情况下我们选择加入之前的SubArray;</p><p>如果之前SubArray的总体之和小于等于0的话，那么就认为它对后续结果是没有贡献的,甚至是有害的（小于0时），这种情况下我们选择以这个数字开始另起一个SubArray;</p><p>设状态为f[j]，表示以S[j]结尾的最大l连续子序列和，则状态转移方程如下：<br>$$f[j] = max{f[j-1] + S[j],S[j]},其中 1 \leq j \le n$$ </p><p>$$target = max{f[j]} , 其中 1 \leq j \le n $$</p><p>解释如下：</p><ul><li>情况一：S[j]不独立，与前面的某些数组成一个连续子序列，则最大连续子序列和为f[j-1]+S[j]</li><li>情况二：S[j]独立划分成一段,即连续子序列仅包含一个数S[j]，则最大连续子序列和为S[j]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">          f = max(f + nums[i], nums[i]);</span><br><span class="line">           result = max(result, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;53-Maximum-Subarray-最大子序和&quot;&gt;&lt;a href=&quot;#53-Maximum-Subarray-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. Maximum Subarray-最大子序和&quot;&gt;&lt;/a&gt;53. Maximu
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-118.Pascal&#39;s Triangle</title>
    <link href="https://xhjiang.tech/2018/11/15/leetcode%E5%88%B7%E9%A2%98-Pascal-s-Triangle/"/>
    <id>https://xhjiang.tech/2018/11/15/leetcode刷题-Pascal-s-Triangle/</id>
    <published>2018-11-15T08:11:30.000Z</published>
    <updated>2018-11-20T07:20:06.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="118-Pascal’s-Triangle-杨辉三角"><a href="#118-Pascal’s-Triangle-杨辉三角" class="headerlink" title="118. Pascal’s Triangle-杨辉三角"></a>118. Pascal’s Triangle-杨辉三角</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;118-Pascal’s-Triangle-杨辉三角&quot;&gt;&lt;a href=&quot;#118-Pascal’s-Triangle-杨辉三角&quot; class=&quot;headerlink&quot; title=&quot;118. Pascal’s Triangle-杨辉三角&quot;&gt;&lt;/a&gt;118. Pa
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-21.Merge Two Sorted Lists</title>
    <link href="https://xhjiang.tech/2018/11/15/leetcode%E5%88%B7%E9%A2%98-Merge-Two-Sorted-Lists/"/>
    <id>https://xhjiang.tech/2018/11/15/leetcode刷题-Merge-Two-Sorted-Lists/</id>
    <published>2018-11-15T07:25:32.000Z</published>
    <updated>2018-11-20T07:19:50.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="21-Merge-Two-Sorted-Lists-合并两个有序链表"><a href="#21-Merge-Two-Sorted-Lists-合并两个有序链表" class="headerlink" title="21. Merge Two Sorted Lists-合并两个有序链表"></a>21. Merge Two Sorted Lists-合并两个有序链表</h1><hr><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><hr><ul><li>解法一:非递归版</li></ul><blockquote><p>思路：<br>新建一个链表用来存储新的有序链表，可以先让两个链表互相比较，新链表的指针指向更小的那个，依次遍历直到一方遍历结束，最后把剩下的那个链表的剩余部分连接到新链表的表尾</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//时间复杂度O(max(m,n)),空间复杂度O(m+n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *t1 = l1;</span><br><span class="line">        ListNode *t2 = l2;</span><br><span class="line">        ListNode *newlist = <span class="keyword">new</span> ListNode(<span class="number">0</span>);    <span class="comment">//新建一个链表用来存储</span></span><br><span class="line">        ListNode *nl = newlist;    <span class="comment">//让指针nl指向新链表，最后返回nl</span></span><br><span class="line">        <span class="comment">//两个链表相互比较大小，新链表指针指向更小的值</span></span><br><span class="line">        <span class="keyword">while</span>(t1 != <span class="literal">nullptr</span> &amp;&amp; t2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val &gt; t2-&gt;val)&#123;</span><br><span class="line">                newlist-&gt;next = t2;</span><br><span class="line">                newlist = newlist-&gt;next;    <span class="comment">//得到一个更小的值后指针后移</span></span><br><span class="line">                t2 = t2-&gt;next;      <span class="comment">//指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                newlist-&gt;next = t1;</span><br><span class="line">                newlist = newlist-&gt;next;</span><br><span class="line">                t1 = t1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把当只剩下一个链表时，把链表剩余部分连接到新链表表尾</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">nullptr</span> &amp;&amp; t2 != <span class="literal">nullptr</span>)</span><br><span class="line">            newlist-&gt;next = t2;     </span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="literal">nullptr</span> &amp;&amp; t1 != <span class="literal">nullptr</span>)</span><br><span class="line">            newlist-&gt;next = t1;</span><br><span class="line">        <span class="keyword">return</span> nl-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;21-Merge-Two-Sorted-Lists-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-Merge-Two-Sorted-Lists-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21. Merge Two Sorted Lis
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-66.Plus One</title>
    <link href="https://xhjiang.tech/2018/11/14/leetcode%E5%88%B7%E9%A2%98-Plus-One/"/>
    <id>https://xhjiang.tech/2018/11/14/leetcode刷题-Plus-One/</id>
    <published>2018-11-14T08:52:38.000Z</published>
    <updated>2018-11-20T07:20:15.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="66-Plus-One-加一"><a href="#66-Plus-One-加一" class="headerlink" title="66. Plus One-加一"></a>66. Plus One-加一</h1><hr><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><blockquote><p>高精度加法</p></blockquote><ul><li>解法一：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;</span><br><span class="line">        add(digits, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 0 &lt;= digit &lt;= 9</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = digit; <span class="comment">// carry, 进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = digits.rbegin(); it != digits.rend(); ++it)&#123;</span><br><span class="line">            *it += c;</span><br><span class="line">            c = *it / <span class="number">10</span>;</span><br><span class="line">            *it %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="comment">//如果最前一位是9+1需要进位的话，那就在最前面的位置插入1</span></span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素<br>c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置<br>对于反向迭代器，++ 运算将访问前一个元素，而 – 运算则访问下一个元素</p></blockquote><ul><li>解法二：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;</span><br><span class="line">        add(digits, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 0 &lt;= digit &lt;= 9</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = digit; <span class="comment">// carry, 进位</span></span><br><span class="line">        for_each(digits.rbegin(), digits.rend(), [&amp;c](<span class="keyword">int</span> &amp;d)&#123;</span><br><span class="line">            d += c;</span><br><span class="line">            c = d / <span class="number">10</span>;</span><br><span class="line">            d %= <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) </span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>这个解法没看明白……</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;66-Plus-One-加一&quot;&gt;&lt;a href=&quot;#66-Plus-One-加一&quot; class=&quot;headerlink&quot; title=&quot;66. Plus One-加一&quot;&gt;&lt;/a&gt;66. Plus One-加一&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;描述&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-100.Same Tree</title>
    <link href="https://xhjiang.tech/2018/11/14/leetcode%E5%88%B7%E9%A2%98-Same-Tree/"/>
    <id>https://xhjiang.tech/2018/11/14/leetcode刷题-Same-Tree/</id>
    <published>2018-11-14T06:58:20.000Z</published>
    <updated>2018-11-20T07:20:55.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="100-Same-Tree-相同的树"><a href="#100-Same-Tree-相同的树" class="headerlink" title="100. Same Tree-相同的树"></a>100. Same Tree-相同的树</h1><hr><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h1 id="递归版："><a href="#递归版：" class="headerlink" title="递归版："></a>递归版：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//递归版，时间复杂度O(n),空间复杂度O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val     <span class="comment">//三方合并</span></span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) </span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代版："><a href="#迭代版：" class="headerlink" title="迭代版："></a>迭代版：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(p);</span><br><span class="line">        s.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            p = s.top(); s.pop();</span><br><span class="line">            q = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(p-&gt;left);</span><br><span class="line">            s.push(q-&gt;left);</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">            s.push(q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;100-Same-Tree-相同的树&quot;&gt;&lt;a href=&quot;#100-Same-Tree-相同的树&quot; class=&quot;headerlink&quot; title=&quot;100. Same Tree-相同的树&quot;&gt;&lt;/a&gt;100. Same Tree-相同的树&lt;/h1&gt;&lt;hr&gt;
&lt;p
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习-mnist手写数字tensorflow实现</title>
    <link href="https://xhjiang.tech/2018/11/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97tensorflow%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xhjiang.tech/2018/11/14/深度学习-mnist手写数字tensorflow实现/</id>
    <published>2018-11-14T03:01:58.000Z</published>
    <updated>2018-11-14T05:36:41.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习实战（一）：手写数字识别"><a href="#深度学习实战（一）：手写数字识别" class="headerlink" title="深度学习实战（一）：手写数字识别"></a>深度学习实战（一）：手写数字识别</h1><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>为了更好的理解Neural Network，本文使用Tensorflow实现一个最简单的神经网络，然后使用MNIST数据集进行测试。同时使用Tensorboard对训练过程进行可视化。</p><hr><h1 id="2-MNIST数据集简介"><a href="#2-MNIST数据集简介" class="headerlink" title="2. MNIST数据集简介"></a>2. MNIST数据集简介</h1><p>当我们学习新的编程语言时，通常第一个程序就是打印输出著名的“Hello World!”。在深度学习中，MNIST数据集就相当于Hello World。</p><p><strong>数据集：</strong><br>train-images-idx3-ubyte 训练数据图像 (60,000)<br>train-labels-idx1-ubyte 训练数据label<br>t10k-images-idx3-ubyte 测试数据图像 (10,000)<br>t10k-labels-idx1-ubyte 测试数据label</p><blockquote><p>我们的任务是使用上面数据训练一个可以准确识别手写数字的神经网络模型，并使用Tensorflow对训练过程各个参数的变化进行可视化。</p></blockquote><hr><h1 id="3-Tensorboard简介"><a href="#3-Tensorboard简介" class="headerlink" title="3. Tensorboard简介"></a>3. Tensorboard简介</h1><p>本文要使用到Tensorboard，先让我们看看它究竟是用来干什么的。</p><p>当使用Tensorflow训练大量深层的神经网络时，我们希望去跟踪神经网络的整个训练过程中的信息，比如迭代的过程中每一层参数是如何变化与分布的，比如每次循环参数更新后模型在测试集与训练集上的准确率是如何的，比如损失值的变化情况，等等。如果能在训练的过程中将一些信息加以记录并可视化得表现出来，是不是对我们探索模型有更深的帮助与理解呢？</p><p>Tensorflow官方推出了可视化工具Tensorboard，可以帮助我们实现以上功能，它可以将模型训练过程中的各种数据汇总起来存在自定义的路径与日志文件中，然后在指定的web端可视化地展现这些信息。</p><h2 id="3-1-Tensorboard的数据形式："><a href="#3-1-Tensorboard的数据形式：" class="headerlink" title="3.1 Tensorboard的数据形式："></a>3.1 Tensorboard的数据形式：</h2><p>Tensorboard可以记录与展示以下数据形式：</p><p>（1）标量Scalars</p><p>（2）图片Images</p><p>（3）音频Audio</p><p>（4）计算图Graph</p><p>（5）数据分布Distribution</p><p>（6）直方图Histograms</p><p>（7）嵌入向量Embeddings</p><h2 id="3-2-Tensorboard的可视化过程："><a href="#3-2-Tensorboard的可视化过程：" class="headerlink" title="3.2 Tensorboard的可视化过程："></a>3.2 Tensorboard的可视化过程：</h2><p>（1）首先肯定是先建立一个graph,你想从这个graph中获取某些数据的信息</p><p>（2）确定要在graph中的哪些节点放置summary operations以记录信息</p><p>使用tf.summary.scalar记录标量</p><p>使用tf.summary.histogram记录数据的直方图</p><p>使用tf.summary.distribution记录数据的分布图</p><p>使用tf.summary.image记录图像数据</p><p>…..等等</p><p>（3）operations并不会去真的执行计算，除非你告诉他们需要去run,或者它被其他的需要run的operation所依赖。而我们上一步创建的这些summary operations其实并不被其他节点依赖，因此，我们需要特地去运行所有的summary节点。但是呢，一份程序下来可能有超多这样的summary 节点，要手动一个一个去启动自然是极其繁琐的，因此我们可以使用tf.summary.merge_all去将所有summary节点合并成一个节点，只要运行这个节点，就能产生所有我们之前设置的summary data。</p><p>（4）使用tf.summary.FileWriter将运行后输出的数据都保存到本地磁盘中</p><p>（5）运行整个程序，并在命令行输入运行tensorboard的指令，之后打开web端可查看可视化的结果</p><p>考虑多类情况。非onehot，标签是类似0 1 2 3…n这样。而onehot标签则是顾名思义，一个长度为n的数组，只有一个元素是1.0，其他元素是0.0。例如在n为4的情况下，标签2对应的onehot标签就是 0.0 0.0 1.0 0.0使用onehot的直接原因是现在多分类cnn网络的输出通常是softmax层，而它的输出是一个概率分布，从而要求输入的标签也以概率分布的形式出现，进而算交叉熵之类。</p><hr><h1 id="4-手写数字识别"><a href="#4-手写数字识别" class="headerlink" title="4. 手写数字识别"></a>4. 手写数字识别</h1><p>现在，我们使用最基础的手写数字识别。</p><h2 id="4-1-准备数据集、定义超参数等准备工作"><a href="#4-1-准备数据集、定义超参数等准备工作" class="headerlink" title="4.1 准备数据集、定义超参数等准备工作"></a>4.1 准备数据集、定义超参数等准备工作</h2><p>1）首先是导入需要使用的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入使用的包</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><p>2）定义超参数</p><p>如果你问，这个超参数为啥要这样设定，如何选择最优的超参数？这个问题此处先不讨论，超参数的选择在机器学习建模中最常用的方法就是“交叉验证法”。而现在假设我们已经获得了最优的超参数，设置学利率为0.001，dropout的保留节点比例为0.9，最大循环次数为1000。</p><p>另外，还要设置两个路径，第一个是数据下载下来存放的地方，一个是summary输出保存的地方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">max_steps = <span class="number">1000</span>  <span class="comment"># 最大迭代数</span></span><br><span class="line">learning_rate = <span class="number">0.001</span>  <span class="comment"># 学习率</span></span><br><span class="line">dropout = <span class="number">0.9</span>  <span class="comment"># dropout时随机保留神经元的比例</span></span><br><span class="line">data_dir = <span class="string">'./MNIST_DATA'</span>  <span class="comment"># 样本数据存储的路径</span></span><br><span class="line">log_dir = <span class="string">'./MNIST_LOG'</span>    <span class="comment"># 输出日志保存的路径</span></span><br></pre></td></tr></table></figure><p>3）GPU设置</p><p>这里使用GPU进行训练，如果使用cpu，可以略过此步。如果使用GPU建议进行设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU设置</span></span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"0"</span></span><br><span class="line">config = tf.ConfigProto(allow_soft_placement=<span class="keyword">True</span>)</span><br><span class="line">gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=<span class="number">0.99</span>)</span><br><span class="line">config.gpu_options.allow_growth = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><blockquote><p><em>Tips：</em><br>上述代码的意思是使用GPU设备0，最多给GPU分配总共内存的百分之33，并且允许GPU按需申请内存。也就是说，假设一个程序使用一块GPU内存百分之10就够了，如果我们没有指定allow_growth=True，那么程序会直接占用GPU内存的百分之33，因为这个是我们给它分配的。如果我们连0.33，也就是GPU内存的百分之33都没有指定，那么程序会直接占用整个GPU设备0。虽然占用这么多没有用，但是我就占着，属于“占着茅坑不拉屎”。所以，为了充分利用资源，特别是一帮人使用一个服务器的时候，指定下这些参数就很有必要了。</p></blockquote><p>4）下载数据下载数据是直接调用了tensorflow提供的函数<strong>read_data_sets</strong>，输入两个参数，第一个是下载到数据存储的路径，第二个one_hot表示是否要将类别标签进行独热编码。它首先回去找制定目录下有没有这个数据文件，没有的话才去下载，有的话就直接读取。所以第一次执行这个命令，速度会比较慢，因为没有数据集，需要进行下载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据集，并采用one_hot独热编码</span></span><br><span class="line">mnist = input_data.read_data_sets(data_dir, one_hot=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h2 id="4-2-数据处理"><a href="#4-2-数据处理" class="headerlink" title="4.2 数据处理"></a>4.2 数据处理</h2><p>1）创建tensorflow默认会话：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建tensorflow默认会话</span></span><br><span class="line">sess = tf.InteractiveSession(config=config)</span><br></pre></td></tr></table></figure></p><blockquote><p><em>Tips:</em><br>为了使设置的GPU参数生效，我们需要在创建会话的时候传入这个config参数。</p></blockquote><p>2）创建输入数据的占位符，分别创建特征数据x，标签数据y_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建输入数据的占位符，分别创建特征数据x，标签数据y_</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'input'</span>):</span><br><span class="line">    x = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">784</span>], name=<span class="string">'x-input'</span>)</span><br><span class="line">    y_ = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">10</span>], name=<span class="string">'y-input'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips：</em><br>在<strong>tf.placeholder()</strong>函数中传入了3个参数，第一个是定义数据类型为float32；第二个是数据的大小，特征数据是大小784的向量，标签数据是大小为10的向量，None表示不定死大小，到时候可以传入任何数量的样本；第3个参数是这个占位符的名称<br><strong>mnist下载好的数据集就是很多个1<em>784的向量，就是已经对28</em>28的图片进行了向量化处理。</strong></p></blockquote><p>3）使用tf.summary.image保存图像信息</p><p>前面也说了，特征数据其实就是图像的像素数据拉升成一个1<em>784的向量，现在如果想在tensorboard上还原出输入的特征数据对应的图片，就需要将拉升的向量转变成28 </em> 28 * 1的原始像素了，于是可以用<strong>tf.reshape()</strong>直接重新调整特征数据的维度：</p><p>将输入的数据转换成[28 <em> 28 </em> 1]的shape，存储成另一个tensor，命名为image_shaped_input。<br>为了能使图片在tensorbord上展示出来，使用<strong>tf.summary.image</strong>将图片数据汇总给tensorbord。<br><strong>tf.summary.image（）</strong>中传入的第一个参数是命名，第二个是图片数据，第三个是最多展示的张数，此处为10张。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用tf.summary.image保存图像信息</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'input_reshape'</span>):</span><br><span class="line">    image_shaped_input = tf.reshape(x, [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">    tf.summary.image(<span class="string">'input'</span>, image_shaped_input, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="4-3-初始化参数并保存参数信息到summary"><a href="#4-3-初始化参数并保存参数信息到summary" class="headerlink" title="4.3 初始化参数并保存参数信息到summary"></a>4.3 初始化参数并保存参数信息到summary</h2><p>1）初始化参数w和b</p><p>在构建神经网络模型中，每一层中都需要去初始化参数w,b,为了使代码简介美观，最好将初始化参数的过程封装成方法function。 创建初始化权重w的方法，生成大小等于传入的shape参数，标准差为0.1，遵循正态分布的随机数，并且将它转换成tensorflow中的variable返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化权重参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.truncated_normal(shape, stddev=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure><p>创建初始换偏执项b的方法，生成大小为传入参数shape的常数0.1，并将其转换成tensorflow的variable并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化偏执参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.constant(<span class="number">0.1</span>, shape=shape)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure><p>2）记录训练过程参数变化</p><p>我们知道，在训练的过程在参数是不断地在改变和优化的，我们往往想知道每次迭代后参数都做了哪些变化，可以将参数的信息展现在tenorbord上，因此我们专门写一个方法来收录每次的参数信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录训练过程参数变化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable_summaries</span><span class="params">(var)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'summaries'</span>):</span><br><span class="line">        <span class="comment"># 计算参数的均值，并使用tf.summary.scalar记录</span></span><br><span class="line">        mean = tf.reduce_mean(var)</span><br><span class="line">        tf.summary.scalar(<span class="string">'mean'</span>, mean)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算参数的标准差</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'stddev'</span>):</span><br><span class="line">            stddev = tf.sqrt(tf.reduce_mean(var - mean))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用tf.summat.scalar记录标准差，最大值，最小值</span></span><br><span class="line">        tf.summary.scalar(<span class="string">'stddev'</span>, stddev)</span><br><span class="line">        tf.summary.scalar(<span class="string">'max'</span>, tf.reduce_max(var))</span><br><span class="line">        tf.summary.scalar(<span class="string">'min'</span>, tf.reduce_min(var))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用直方图记录参数的分布</span></span><br><span class="line">        tf.summary.histogram(<span class="string">'histogram'</span>, var)</span><br></pre></td></tr></table></figure><h2 id="4-4-构建神经网络层"><a href="#4-4-构建神经网络层" class="headerlink" title="4.4 构建神经网络层"></a>4.4 构建神经网络层</h2><p>1）创建第一层隐藏层</p><p>创建一个构建隐藏层的方法,输入的参数有：</p><blockquote><p>input_tensor：特征数据<br>input_dim：输入数据的维度大小<br>output_dim：输出数据的维度大小(=隐层神经元个数）<br>layer_name：命名空间<br>act=tf.nn.relu：激活函数（默认是relu)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建神经网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_layer</span><span class="params">(input_tensor, input_dim, out_dim, layer_name, act=tf.nn.relu)</span>:</span></span><br><span class="line">    <span class="comment"># 设置命名空间</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(layer_name):</span><br><span class="line">        <span class="comment"># 调用之前的方法初始化权重w，并且调用参数信息的记录方法，记录w的信息</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'weights'</span>):</span><br><span class="line">            weights = weight_variable([input_dim, out_dim])</span><br><span class="line">            variable_summaries(weights)</span><br><span class="line">        <span class="comment"># 调用之前的方法初始化权重b，并且调用参数信息的记录方法，记录b的信息</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'biases'</span>):</span><br><span class="line">            biases = bias_variable([out_dim])</span><br><span class="line">            variable_summaries(biases)</span><br><span class="line">        <span class="comment"># 执行wx+b的线性计算，并且用直方图记录下来</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'linear_compute'</span>):</span><br><span class="line">            preactivate = tf.matmul(input_tensor, weights) + biases</span><br><span class="line">            tf.summary.histogram(<span class="string">'linear'</span>, preactivate)</span><br><span class="line">        <span class="comment"># 将线性输出经过激励函数，并将输出也用直方图记录下来</span></span><br><span class="line">        activations = act(preactivate, name=<span class="string">'activations'</span>)</span><br><span class="line">        tf.summary.histogram(<span class="string">'activations'</span>, activations)</span><br><span class="line">    <span class="comment"># 返回激励层的最终输出</span></span><br><span class="line">    <span class="keyword">return</span> activations</span><br></pre></td></tr></table></figure><p>调用隐层创建函数创建一个隐藏层：输入的维度是特征的维度784，隐藏层的神经元个数是500，也就是输出的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个隐藏层</span></span><br><span class="line">hidden1 = nn_layer(x, <span class="number">784</span>, <span class="number">500</span>, <span class="string">'layer1'</span>)</span><br></pre></td></tr></table></figure><p>2）创建一个dropout层</p><p>随机关闭掉hidden1的一些神经元，并记录keep_prob，减少保存参数，防止过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个dropout层</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'dropout'</span>):</span><br><span class="line">    keep_prob = tf.placeholder(tf.float32)</span><br><span class="line">    tf.summary.scalar(<span class="string">'dropout_keep_probability'</span>, keep_prob)</span><br><span class="line">    dropped = tf.nn.dropout(hidden1, keep_prob)</span><br></pre></td></tr></table></figure><p>3）创建一个输出层</p><p>输入的维度是上一层的输出:500,输出的维度是分类的类别种类：10，激活函数设置为全等映射identity。（暂且先别使用softmax，会放在之后的损失函数中一起计算）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个输出层</span></span><br><span class="line">y = nn_layer(dropped, <span class="number">500</span>, <span class="number">10</span>, <span class="string">'layer2'</span>, act=tf.identity)</span><br></pre></td></tr></table></figure><h2 id="4-5-创造损失函数"><a href="#4-5-创造损失函数" class="headerlink" title="4.5 创造损失函数"></a>4.5 创造损失函数</h2><p>使用tf.nn.softmax_cross_entropy_with_logits来计算softmax并计算交叉熵损失,并且求均值作为最终的损失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建损失函数</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'loss'</span>):</span><br><span class="line">    <span class="comment"># 计算交叉熵损失（每个样本都会有一个损失）</span></span><br><span class="line">    diff = tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y)</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'total'</span>):</span><br><span class="line">        <span class="comment"># 计算所有样本交叉熵损失的均值</span></span><br><span class="line">        cross_entropy = tf.reduce_mean(diff)</span><br><span class="line">    tf.summary.scalar(<span class="string">'loss'</span>, cross_entropy)</span><br></pre></td></tr></table></figure><h2 id="4-6-训练"><a href="#4-6-训练" class="headerlink" title="4.6 训练"></a>4.6 训练</h2><p>首先，使用AdamOptimizer优化器训练模型，最小化交叉熵损失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用AdamOptimizer优化器训练模型，最小化交叉熵损失</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'train'</span>):</span><br><span class="line">    train_step = tf.train.AdamOptimizer(learning_rate).minimize(cross_entropy)</span><br></pre></td></tr></table></figure><p>然后，计算准确率,并用tf.summary.scalar记录准确率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'accuracy'</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'correct_prediction'</span>):</span><br><span class="line">        <span class="comment"># 分别将预测和真实的标签中取出最大值的索引，若相同则返回1(true),不同则返回0(false)</span></span><br><span class="line">        correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'accuracy'</span>):</span><br><span class="line">            <span class="comment"># 求均值即为准确率</span></span><br><span class="line">            accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line">tf.summary.scalar(<span class="string">'accuracy'</span>, accuracy)</span><br></pre></td></tr></table></figure><h2 id="4-7-所有变量初始化"><a href="#4-7-所有变量初始化" class="headerlink" title="4.7 所有变量初始化"></a>4.7 所有变量初始化</h2><p>将所有的summaries合并，并且将它们写到之前定义的log_dir路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># summaries合并</span></span><br><span class="line">merged = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写到指定的磁盘路径中</span></span><br><span class="line">train_writer = tf.summary.FileWriter(log_dir + <span class="string">'/train'</span>, sess.graph)</span><br><span class="line">test_writer = tf.summary.FileWriter(log_dir + <span class="string">'/test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行初始化所有变量</span></span><br><span class="line">tf.global_variables_initializer().run()</span><br></pre></td></tr></table></figure><h2 id="4-8-送入数据集"><a href="#4-8-送入数据集" class="headerlink" title="4.8 送入数据集"></a>4.8 送入数据集</h2><p>feed_dict用于获取数据，如果是<strong>train == true</strong>，也就是进行训练的时候，就从mnist.train中获取一个batch大小为100样本，并且设置dropout值为0.9。如果是<strong>train == false</strong>,则获取minist.test的测试数据，并且设置dropout为1，即保留所有神经元开启。</p><p>同时，每隔10步，进行一次测试，并打印一次测试数据集的准确率，然后将测试数据集的各种summary信息写进日志中。 其余的时候，都是在进行训练，将训练集的summary信息并写到日志中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feed_dict</span><span class="params">(train)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> train:</span><br><span class="line">        xs, ys = mnist.train.next_batch(<span class="number">100</span>)</span><br><span class="line">        k = dropout</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        xs, ys = mnist.test.images, mnist.test.labels</span><br><span class="line">        k = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;x: xs, y_: ys, keep_prob: k&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(max_steps):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:  <span class="comment"># 记录测试集的summary与accuracy</span></span><br><span class="line">        summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(<span class="keyword">False</span>))</span><br><span class="line">        test_writer.add_summary(summary, i)</span><br><span class="line">        print(<span class="string">'Accuracy at step %s: %s'</span> % (i, acc))</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 记录训练集的summary</span></span><br><span class="line">        summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(<span class="keyword">True</span>))</span><br><span class="line">        train_writer.add_summary(summary, i)</span><br><span class="line"></span><br><span class="line">train_writer.close()</span><br><span class="line">test_writer.close()</span><br></pre></td></tr></table></figure><h2 id="4-9-运行程序"><a href="#4-9-运行程序" class="headerlink" title="4.9 运行程序"></a>4.9 运行程序</h2><p>运行整个程序，在程序中定义的summary node就会将要记录的信息全部保存在指定的logdir路径中了，训练的记录会存一份文件，测试的记录会存一份文件。</p><p>运行程序，如果使用GPU进行训练，等待几分钟应该就OK了</p><h2 id="4-10-利用Tensorboard查看训练状态"><a href="#4-10-利用Tensorboard查看训练状态" class="headerlink" title="4.10 利用Tensorboard查看训练状态"></a>4.10 利用Tensorboard查看训练状态</h2><p>与此同时，在运行的时候，我们就可以打开Tensorboard查看训练状态。使用如下指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=./MNIST_LOG --port=<span class="number">8008</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度学习实战（一）：手写数字识别&quot;&gt;&lt;a href=&quot;#深度学习实战（一）：手写数字识别&quot; class=&quot;headerlink&quot; title=&quot;深度学习实战（一）：手写数字识别&quot;&gt;&lt;/a&gt;深度学习实战（一）：手写数字识别&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;1-前言
      
    
    </summary>
    
      <category term="深度学习" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Tensorflow" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Tensorflow/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Tensorflow/Python/"/>
    
    
      <category term="深度学习" scheme="https://xhjiang.tech/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/tags/Python/"/>
    
      <category term="Tensorflow" scheme="https://xhjiang.tech/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-替换空格</title>
    <link href="https://xhjiang.tech/2018/11/13/%E5%89%91%E6%8C%87offer-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://xhjiang.tech/2018/11/13/剑指offer-替换空格/</id>
    <published>2018-11-13T11:35:12.000Z</published>
    <updated>2018-11-20T07:19:02.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><hr><p><strong>题目描述</strong></p><p>请实现一个函数，将一个字符串中的每个空格替换成“<strong>%20</strong>”。例如，当字符串为<strong>We Are Happy</strong>.则经过替换之后的字符串为<strong>We%20Are%20Happy</strong>.</p><hr><p><strong>C++解题思路</strong></p><ol><li><p>可以新建一个string对象，从前向后遍历源字符串，遇到空格即替换成%20，不是空格直接拷贝，最后把string对象转换成C字符串拷贝给源字符串。</p></li><li><p>先遍历源字符串得到空格的个数，得到替换后字符串的长度，使用两个指针，一个指向源串的最后，一个指向新字符串的最后，从后向前拷贝，遇到空格开始替换，同时后面的指针继续向前，直到两个指针相等，说明替换完成。注意不要在函数内新建一个数组来做，直接在源串上进行改动。这里给出第二种解题思路的代码：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* pstr = str; </span><br><span class="line">    <span class="keyword">while</span>(*pstr != <span class="string">'\0'</span>)     <span class="comment">//得到空格的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pstr == <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;    </span><br><span class="line">        &#125;</span><br><span class="line">        pstr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newsize = length + <span class="number">2</span>*count;    <span class="comment">//替换后的字符串长度</span></span><br><span class="line">    str[newsize] = <span class="string">'\0'</span>;           <span class="comment">//给新字符串末尾设置结束标志，不能省略。</span></span><br><span class="line">    <span class="keyword">char</span>* end = str + length - <span class="number">1</span>;     <span class="comment">//源串的最后一个位置</span></span><br><span class="line">    <span class="keyword">char</span>* finish = str + newsize - <span class="number">1</span>;   <span class="comment">//新串的最后一个位置</span></span><br><span class="line">    <span class="keyword">while</span>(end != finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*end != <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *finish-- = *end--;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                  <span class="comment">//遇见空格开始替换。</span></span><br><span class="line">            *finish-- = <span class="string">'0'</span>;</span><br><span class="line">            *finish-- = <span class="string">'2'</span>;</span><br><span class="line">            *finish-- = <span class="string">'%'</span>;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Python解题思路</strong></p><p><strong>Python</strong>中的<strong>replace()</strong> 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。所以只需要在循环中判断字符是否是空格字符，如果是的话就替换成‘<strong>%20</strong>’就行了。</p><blockquote><p><em>用法：</em> str.replace(old, new[, max])</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#s1 = dict(s)</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="string">' '</span>:</span><br><span class="line">                s = s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><blockquote><p>Tips:<br>此解法是本菜鸡自己想出来的，所以可以得出并不是本菜鸡变厉害了，而是python相对于c++来说确实很好用。python真香~</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;替换空格&quot;&gt;&lt;a href=&quot;#替换空格&quot; class=&quot;headerlink&quot; title=&quot;替换空格&quot;&gt;&lt;/a&gt;替换空格&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的每个空格替换成“&lt;str
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://xhjiang.tech/categories/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/%E5%89%91%E6%8C%87offer/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="剑指offer" scheme="https://xhjiang.tech/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-7.Reverse Integer</title>
    <link href="https://xhjiang.tech/2018/11/13/leetcode%E5%88%B7%E9%A2%98-Reverse-Integer/"/>
    <id>https://xhjiang.tech/2018/11/13/leetcode刷题-Reverse-Integer/</id>
    <published>2018-11-13T08:38:32.000Z</published>
    <updated>2018-11-20T07:20:42.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-Reverse-Integer-反转整数"><a href="#7-Reverse-Integer-反转整数" class="headerlink" title="7.Reverse Integer-反转整数"></a>7.Reverse Integer-反转整数</h1><hr><p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p><p>注意:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</span><br></pre></td></tr></table></figure></p><hr><h1 id="方法：弹出和推入数字-amp-溢出前进行检查"><a href="#方法：弹出和推入数字-amp-溢出前进行检查" class="headerlink" title="方法：弹出和推入数字 &amp; 溢出前进行检查"></a>方法：弹出和推入数字 &amp; 溢出前进行检查</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>反转整数的方法可以与反转字符串进行类比。</p><p>我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 <strong>rev</strong> 的后面。最后，<strong>rev</strong> 将与 xx 相反。</p><p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure></p><p>但是，这种方法很危险，因为当 <strong>temp=rev⋅10+pop</strong> 时会导致溢出。</p><p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p><p>为了便于解释，我们假设 <strong>rev</strong> 是正数。</p><ol><li>如果 <strong>temp = rev ⋅ 10 + pop</strong> 导致溢出，那么一定有 <strong>rev ≥ INTMAX / 10</strong>。</li><li>如果 <strong>rev &gt; INTMAX / 10</strong>，那么 <strong>temp = rev ⋅ 10 + pop</strong> 一定会溢出。</li><li>如果 <strong>rev== INTMAX / 10</strong>，那么只要 <strong>pop &gt; 7</strong>, <strong>temp = rev ⋅ 10 + pop</strong> 就会溢出。<br>当 <strong>rev</strong> 为负时可以应用类似的逻辑。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>复杂度分析:</strong></p><p>时间复杂度：O(log(x))，x 中大约有 log10(x) 位数字。<br>空间复杂度：O(1)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;7-Reverse-Integer-反转整数&quot;&gt;&lt;a href=&quot;#7-Reverse-Integer-反转整数&quot; class=&quot;headerlink&quot; title=&quot;7.Reverse Integer-反转整数&quot;&gt;&lt;/a&gt;7.Reverse Integer-反转
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数学" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数学" scheme="https://xhjiang.tech/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-867.Transpose Matrix</title>
    <link href="https://xhjiang.tech/2018/11/13/leetcode%E5%88%B7%E9%A2%98-Transpose-Matrix/"/>
    <id>https://xhjiang.tech/2018/11/13/leetcode刷题-Transpose-Matrix/</id>
    <published>2018-11-13T08:00:30.000Z</published>
    <updated>2018-11-20T07:21:13.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="867-Transpose-Matrix-转置矩阵"><a href="#867-Transpose-Matrix-转置矩阵" class="headerlink" title="867.Transpose Matrix-转置矩阵"></a>867.Transpose Matrix-转置矩阵</h1><hr><p>给定一个矩阵 A， 返回 A 的转置矩阵。</p><p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt;提示：</span><br><span class="line">&gt;1 &lt;= A.length &lt;= 1000</span><br><span class="line">&gt;1 &lt;= A[0].length &lt;= 1000</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**解题思路：**</span><br><span class="line"></span><br><span class="line">矩阵的行列互换，简单的二重循环就可以了,不过很可惜，可能是太久没实战编码了，虽然知道该怎么做，但还是没写出来正确可以运行的代码......</span><br><span class="line"></span><br><span class="line">- C++版代码：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">        int m=A.size();</span><br><span class="line">        int n=A[0].size();</span><br><span class="line">        vector&lt;int&gt; B(m,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; C(n,B);</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">                C[j][i]=A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        return C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Python版代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        R, C = len(A), len(A[<span class="number">0</span>])</span><br><span class="line">        ans = [[<span class="keyword">None</span>] * R <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(C)]</span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                ans[c][r] = val</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="comment">#Alternative Solution:</span></span><br><span class="line">        <span class="comment">#return zip(*A)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>复杂度分析:</strong></p><p>时间复杂度：O(R * C)，其中 R 和 C 是给定矩阵 A 的行数和列数。</p><p>空间复杂度：O(R * C)，也就是答案所使用的空间。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;867-Transpose-Matrix-转置矩阵&quot;&gt;&lt;a href=&quot;#867-Transpose-Matrix-转置矩阵&quot; class=&quot;headerlink&quot; title=&quot;867.Transpose Matrix-转置矩阵&quot;&gt;&lt;/a&gt;867.Transpo
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-27.Remove Element</title>
    <link href="https://xhjiang.tech/2018/11/12/leetcode%E5%88%B7%E9%A2%98-Remove-Element/"/>
    <id>https://xhjiang.tech/2018/11/12/leetcode刷题-Remove-Element/</id>
    <published>2018-11-12T11:34:34.000Z</published>
    <updated>2018-11-20T07:20:33.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="27-Remove-Element-移除元素"><a href="#27-Remove-Element-移除元素" class="headerlink" title="27. Remove Element-移除元素"></a>27. Remove Element-移除元素</h1><hr><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解法一:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Element</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><em>Tips:</em><br>本解法是受到了 <strong>LeetCode</strong> 上第26题 <strong>Remove Duplicates from Sorted Array</strong> 的解法一的启发。<em>PS</em>终于自己解出来了一道题，虽然是一道简单级别的题，并且两题解法很相似，但还是觉得受到了鼓舞^_^</p></blockquote><ul><li>解法二:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Element</span></span><br><span class="line"><span class="comment">// 使用 remove()，时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(), remove(nums.begin(), nums.end(), val));</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意:</strong></p><ul><li><strong>distance(iterator first,iterator last)</strong> 函数表示返回两个迭代器 <strong>first</strong> 和 <strong>last</strong> 之间的距离;</li><li><strong>remove()</strong> 函数表示返回新的end()迭代器但是不改变原来数组的end()迭代器的值，将范围内值等于val的元素用后一个元素替代。原先数组中 新的end()至原end()范围内的值仍为原来数组的值，但是这部分状态不可靠。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;27-Remove-Element-移除元素&quot;&gt;&lt;a href=&quot;#27-Remove-Element-移除元素&quot; class=&quot;headerlink&quot; title=&quot;27. Remove Element-移除元素&quot;&gt;&lt;/a&gt;27. Remove Element-
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-26.Remove Duplicates from Sorted Array</title>
    <link href="https://xhjiang.tech/2018/11/12/leetcode%E5%88%B7%E9%A2%98-Remove-Duplicates-from-Sorted-Array/"/>
    <id>https://xhjiang.tech/2018/11/12/leetcode刷题-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2018-11-12T08:18:08.000Z</published>
    <updated>2018-11-20T07:20:25.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项"><a href="#26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项" class="headerlink" title="26. Remove Duplicates from Sorted Array-删除排序数组中的重复项"></a>26. Remove Duplicates from Sorted Array-删除排序数组中的重复项</h1><p><strong>内容：</strong> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>Tips：</em><br>这道题开始还是没有做出来，暴力破解法的思路错误了，不能一直试图用for循环来解决，应该着重于数组本身的变化以及要在STL上面寻求更好的解题思路</p></blockquote><ul><li><p>解法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Duplicates from Sorted Array</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] != nums[i])</span><br><span class="line">            nums[++index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>解法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Duplicates from Sorted Array</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(), unique(nums.begin(), nums.end()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意:</strong></p><ul><li><strong>distance(iterator first,iterator last)</strong> 函数表示返回两个迭代器 <strong>first</strong> 和 <strong>last</strong> 之间的距离;</li><li><strong>unique(iterator it_1,iterator it_2)</strong> 函数表示其中这两个参数表示对容器中[it_1，it_2)范围的元素进行去重(注：区间是前闭后开，即不包含it_2所指的元素),返回值是一个迭代器，它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。</li></ul></blockquote><ul><li>解法三：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Duplicates from Sorted Array</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(), removeDuplicates(nums.begin(), nums.end(), nums.begin()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InIt, <span class="keyword">typename</span> OutIt&gt;</span><br><span class="line">    <span class="function">OutIt <span class="title">removeDuplicates</span><span class="params">(InIt first, InIt last, OutIt output)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *output++ = *first;</span><br><span class="line">        first = upper_bound(first, last, *first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;#26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++中的STL中map用法详解</title>
    <link href="https://xhjiang.tech/2018/11/12/C-%E4%B8%AD%E7%9A%84STL%E4%B8%ADmap%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://xhjiang.tech/2018/11/12/C-中的STL中map用法详解/</id>
    <published>2018-11-12T06:35:43.000Z</published>
    <updated>2018-11-12T07:27:07.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-map简介"><a href="#1-map简介" class="headerlink" title="1. map简介"></a>1. map简介</h1><p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。跟<strong>python</strong>语言中的<strong>元组</strong>类似。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p><hr><h1 id="2-map的基本操作函数"><a href="#2-map的基本操作函数" class="headerlink" title="2. map的基本操作函数"></a>2. map的基本操作函数</h1><p>map的基本操作函数：</p><pre><code>begin()         返回指向map头部的迭代器clear(）        删除所有元素count()         返回指定元素出现的次数empty()         如果map为空则返回trueend()           返回指向map末尾的迭代器equal_range()   返回特殊条目的迭代器对erase()         删除一个元素find()          查找一个元素get_allocator() 返回map的配置器insert()        插入元素key_comp()      返回比较元素key的函数lower_bound()   返回键值&gt;=给定元素的第一个位置max_size()      返回可以容纳的最大元素个数rbegin()        返回一个指向map尾部的逆向迭代器rend()          返回一个指向map头部的逆向迭代器size()          返回map中元素的个数swap()           交换两个mapupper_bound()    返回键值&gt;给定元素的第一个位置value_comp()     返回比较元素value的函数</code></pre><hr><h1 id="3-使用map"><a href="#3-使用map" class="headerlink" title="3. 使用map"></a>3. 使用map</h1><p>使用map得包含map类所在的头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //注意，STL头文件没有扩展名.h</span></span></span><br></pre></td></tr></table></figure></p><p>map对象是模板类，需要关键字和存储对象两个模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; personnel;</span><br></pre></td></tr></table></figure></p><p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p><p>为了使用方便，可以对模板类进行一下类型定义，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>,CString&gt; UDT_MAP_INT_CSTRING;</span><br><span class="line"></span><br><span class="line">UDT_MAP_INT_CSTRING enumMap;</span><br></pre></td></tr></table></figure></p><h1 id="4-map的构造函数"><a href="#4-map的构造函数" class="headerlink" title="4. map的构造函数"></a>4. map的构造函数</h1><p>map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br></pre></td></tr></table></figure></p><h1 id="5-map的一些基本操作"><a href="#5-map的一些基本操作" class="headerlink" title="5. map的一些基本操作"></a>5. map的一些基本操作</h1><h2 id="5-1-insert插入操作"><a href="#5-1-insert插入操作" class="headerlink" title="5.1 insert插入操作"></a>5.1 insert插入操作</h2><p>在构造map容器后，我们就可以往里面插入数据了。这里讲三种插入数据的方法：</p><h3 id="5-1-1-用insert函数插入pair数据，下面举例说明"><a href="#5-1-1-用insert函数插入pair数据，下面举例说明" class="headerlink" title="5.1.1 用insert函数插入pair数据，下面举例说明"></a>5.1.1 用insert函数插入pair数据，下面举例说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据的插入--第一种：用insert函数插入pair数据  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-用insert函数插入value-type数据，下面举例说明"><a href="#5-1-2-用insert函数插入value-type数据，下面举例说明" class="headerlink" title="5.1.2 用insert函数插入value_type数据，下面举例说明"></a>5.1.2 用insert函数插入value_type数据，下面举例说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种：用insert函数插入value_type数据，下面举例说明  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-用数组方式插入数据，下面举例说明"><a href="#5-1-3-用数组方式插入数据，下面举例说明" class="headerlink" title="5.1.3 用数组方式插入数据，下面举例说明"></a>5.1.3 用数组方式插入数据，下面举例说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种：用数组方式插入数据，下面举例说明  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">"student_one"</span>;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">2</span>] = <span class="string">"student_two"</span>;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">3</span>] = <span class="string">"student_three"</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips：</em><br>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值。</p></blockquote><h2 id="5-2-map的大小–size函数"><a href="#5-2-map的大小–size函数" class="headerlink" title="5.2 map的大小–size函数"></a>5.2 map的大小–size函数</h2><p>这里也提供三种方法，对map进行遍历</p><h3 id="5-2-1-应用前向迭代器，上面举例程序中到处都是了，略过不表"><a href="#5-2-1-应用前向迭代器，上面举例程序中到处都是了，略过不表" class="headerlink" title="5.2.1 应用前向迭代器，上面举例程序中到处都是了，略过不表"></a>5.2.1 应用前向迭代器，上面举例程序中到处都是了，略过不表</h3><h3 id="5-2-2-应用反相迭代器，下面举例说明："><a href="#5-2-2-应用反相迭代器，下面举例说明：" class="headerlink" title="5.2.2 应用反相迭代器，下面举例说明："></a>5.2.2 应用反相迭代器，下面举例说明：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种，利用反向迭代器  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::reverse_iterator iter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">"  "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-用数组的形式，程序说明如下："><a href="#5-2-3-用数组的形式，程序说明如下：" class="headerlink" title="5.2.3 用数组的形式，程序说明如下："></a>5.2.3 用数组的形式，程序说明如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种：用数组方式，程序说明如下  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> nSize = mapStudent.size();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//此处应注意，应该是 for(int nindex = 1; nindex &lt;= nSize; nindex++)  </span></span><br><span class="line"><span class="comment">//而不是 for(int nindex = 0; nindex &lt; nSize; nindex++)  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> nindex = <span class="number">1</span>; nindex &lt;= nSize; nindex++)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mapStudent[nindex]&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-查找并获取map中的元素（包括判定这个关键字是否在map中出现）"><a href="#5-3-查找并获取map中的元素（包括判定这个关键字是否在map中出现）" class="headerlink" title="5.3 查找并获取map中的元素（包括判定这个关键字是否在map中出现）"></a>5.3 查找并获取map中的元素（包括判定这个关键字是否在map中出现）</h2><p>在这里我们将体会，map在数据插入时保证有序的好处。要判定一个数据（关键字）是否在map中出现的方法比较多，这里标题虽然是数据的查找，在这里将穿插着大量的map基本用法。<br>这里给出三种数据查找方法:</p><h3 id="5-3-1-用count函数来判定关键字是否出现"><a href="#5-3-1-用count函数来判定关键字是否出现" class="headerlink" title="5.3.1 用count函数来判定关键字是否出现"></a>5.3.1 用count函数来判定关键字是否出现</h3><p>其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了</p><h3 id="5-3-2-用find函数来定位数据出现位置"><a href="#5-3-2-用find函数来定位数据出现位置" class="headerlink" title="5.3.2 用find函数来定位数据出现位置"></a>5.3.2 用find函数来定位数据出现位置</h3><p>它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。查找map中是否包含某个关键字条目用find()方法，传入的参数是要查找的key，在这里需要提到的是<strong>begin()</strong>和<strong>end()</strong>两个成员，分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是<strong>iterator</strong>。<br>程序说明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.find(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(iter != mapStudent.end())  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find, the value is "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>通过map对象的方法获取的iterator数据类型是一个std::pair对象，包括两个数据 iterator-&gt;first和 iterator-&gt;second分别代表关键字和存储的数据。</p></blockquote><h3 id="5-3-3-第三种：这个方法用来判定数据是否出现"><a href="#5-3-3-第三种：这个方法用来判定数据是否出现" class="headerlink" title="5.3.3 第三种：这个方法用来判定数据是否出现"></a>5.3.3 第三种：这个方法用来判定数据是否出现</h3><p>lower_bound函数用法，这个函数用来返回要查找关键字的下界(是一个迭代器)<br>upper_bound函数用法，这个函数用来返回要查找关键字的上界(是一个迭代器)</p><p>例如：map中已经插入了1，2，3，4的话，如果lower_bound(2)的话，返回的2，而upper-bound（2）的话，返回的就是3</p><p>Equal_range函数返回一个pair，pair里面第一个变量是Lower_bound返回的迭代器，pair里面第二个迭代器是Upper_bound返回的迭代器，如果这两个迭代器相等的话，则说明map中不出现这个关键字，</p><p>程序说明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">"student_one"</span>;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">3</span>] = <span class="string">"student_three"</span>;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">5</span>] = <span class="string">"student_five"</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.lower_bound(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是下界1的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.lower_bound(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是下界3的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.lower_bound(<span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是下界3的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.upper_bound(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是上界3的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.upper_bound(<span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是上界5的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator&gt; mappair;  </span><br><span class="line">  </span><br><span class="line">    mappair = mapStudent.equal_range(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(mappair.first == mappair.second)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    mappair = mapStudent.equal_range(<span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(mappair.first == mappair.second)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-从map中删除元素"><a href="#5-4-从map中删除元素" class="headerlink" title="5.4 从map中删除元素"></a>5.4 从map中删除元素</h2><p>移除某个map中某个条目用<strong>erase（）</strong></p><p>该成员方法的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iterator erase（iterator it);<span class="comment">//通过一个条目对象删除</span></span><br><span class="line"></span><br><span class="line">iterator erase（iterator first，iterator last）<span class="comment">//删除一个范围</span></span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> Key&amp;key)</span></span>;<span class="comment">//通过关键字删除</span></span><br><span class="line"></span><br><span class="line">clear()就相当于enumMap.erase(enumMap.begin(),enumMap.end());</span><br></pre></td></tr></table></figure></p><p>这里要用到erase函数，它有三个重载了的函数，下面在例子中详细说明它们的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好  </span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">//如果要删除1,用迭代器删除  </span></span><br><span class="line">  </span><br><span class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">       iter = mapStudent.find(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">       mapStudent.erase(iter);  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//如果要删除1，用关键字删除  </span></span><br><span class="line">  </span><br><span class="line">       <span class="keyword">int</span> n = mapStudent.erase(<span class="number">1</span>);<span class="comment">//如果删除了会返回1，否则返回0  </span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">//用迭代器，成片的删除  </span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">//一下代码把整个map清空  </span></span><br><span class="line">  </span><br><span class="line">       mapStudent.erase( mapStudent.begin(), mapStudent.end() );  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合  </span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">//自个加上遍历代码，打印输出吧  </span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-map中的swap用法"><a href="#5-5-map中的swap用法" class="headerlink" title="5.5 map中的swap用法"></a>5.5 map中的swap用法</h2><p>map中的swap不是一个容器中的元素交换，而是两个容器所有元素的交换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-map简介&quot;&gt;&lt;a href=&quot;#1-map简介&quot; class=&quot;headerlink&quot; title=&quot;1. map简介&quot;&gt;&lt;/a&gt;1. map简介&lt;/h1&gt;&lt;p&gt;Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出
      
    
    </summary>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/C/"/>
    
      <category term="STL" scheme="https://xhjiang.tech/categories/C/STL/"/>
    
      <category term="map" scheme="https://xhjiang.tech/categories/C/STL/map/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="STL" scheme="https://xhjiang.tech/tags/STL/"/>
    
      <category term="map" scheme="https://xhjiang.tech/tags/map/"/>
    
  </entry>
  
</feed>
