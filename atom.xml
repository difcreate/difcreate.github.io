<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>difcreate&#39;s blog</title>
  
  <subtitle>偷得浮生半日闲</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xhjiang.tech/"/>
  <updated>2018-12-01T15:50:53.250Z</updated>
  <id>https://xhjiang.tech/</id>
  
  <author>
    <name>difcreate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode刷题-2. Add Two Numbers</title>
    <link href="https://xhjiang.tech/2018/12/01/leetcode%E5%88%B7%E9%A2%98-2-Add-Two-Numbers/"/>
    <id>https://xhjiang.tech/2018/12/01/leetcode刷题-2-Add-Two-Numbers/</id>
    <published>2018-12-01T15:32:12.000Z</published>
    <updated>2018-12-01T15:50:53.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers-两数相加"><a href="#2-Add-Two-Numbers-两数相加" class="headerlink" title="2. Add Two Numbers-两数相加"></a>2. Add Two Numbers-两数相加</h1><hr><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>创建一个临时的头结点，并将指针cur指向该节点，之后遍历L1 和 L2两个链表，将他们对应位置节点的值相加，同和，如果该位置前的两个节点之和大于等于10，需要进位，则该节点值加1，然后对10取余，并新建节点保存，将cur的next指针指向该节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> carry = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(carry)</span><br><span class="line">                sum++;</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">            carry = sum &gt;= <span class="number">10</span> ? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-Add-Two-Numbers-两数相加&quot;&gt;&lt;a href=&quot;#2-Add-Two-Numbers-两数相加&quot; class=&quot;headerlink&quot; title=&quot;2. Add Two Numbers-两数相加&quot;&gt;&lt;/a&gt;2. Add Two Numbers-
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-69. Sqrt(x)</title>
    <link href="https://xhjiang.tech/2018/12/01/leetcode%E5%88%B7%E9%A2%98-69-Sqrt-x/"/>
    <id>https://xhjiang.tech/2018/12/01/leetcode刷题-69-Sqrt-x/</id>
    <published>2018-12-01T14:27:20.000Z</published>
    <updated>2018-12-01T14:41:50.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-Sqrt-x-x的平方根"><a href="#69-Sqrt-x-x的平方根" class="headerlink" title="69. Sqrt(x)-x的平方根"></a>69. Sqrt(x)-x的平方根</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>算一个候选值的平方，然后和x比较大小，为了缩短查找时间，我们采用二分搜索法来找平方根</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">         <span class="keyword">int</span> left = <span class="number">0</span>, right = x;</span><br><span class="line">         <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">             <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span> (x / mid &gt;= mid) left = mid + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;69-Sqrt-x-x的平方根&quot;&gt;&lt;a href=&quot;#69-Sqrt-x-x的平方根&quot; class=&quot;headerlink&quot; title=&quot;69. Sqrt(x)-x的平方根&quot;&gt;&lt;/a&gt;69. Sqrt(x)-x的平方根&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;描述：&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数学" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数学" scheme="https://xhjiang.tech/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-55. Jump Game</title>
    <link href="https://xhjiang.tech/2018/11/30/leetcode%E5%88%B7%E9%A2%98-55-Jump-Game/"/>
    <id>https://xhjiang.tech/2018/11/30/leetcode刷题-55-Jump-Game/</id>
    <published>2018-11-30T08:25:41.000Z</published>
    <updated>2018-11-30T08:26:37.577Z</updated>
    
    <content type="html"><![CDATA[<p>#　55. Jump Game-跳跃游戏</p><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题可以用<strong>贪婪算法Greedy Algorithm</strong>来解决，因为我们并不是很关心每一个位置上的剩余步数，我们只希望知道能否到达末尾，也就是说我们只对最远能到达的位置感兴趣，所以我们维护一个变量reach，表示最远能到达的位置，初始化为0。遍历数组中每一个数字，如果当前坐标大于reach或者reach已经抵达最后一个位置则跳出循环，否则就更新reach的值为其和i + nums[i]中的较大值，其中i + nums[i]表示当前位置能到达的最大位置，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), reach = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//当前坐标大于reach或者reach已经抵达最后则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; reach || reach &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            reach = max(reach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reach &gt;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#　55. Jump Game-跳跃游戏&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;headerlink&quot; title=&quot;描述：&quot;&gt;&lt;/a&gt;描述：&lt;/h2&gt;&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/categories/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-144. Binary Tree Preorder Traversal</title>
    <link href="https://xhjiang.tech/2018/11/29/leetcode%E5%88%B7%E9%A2%98-144-Binary-Tree-Preorder-Traversal/"/>
    <id>https://xhjiang.tech/2018/11/29/leetcode刷题-144-Binary-Tree-Preorder-Traversal/</id>
    <published>2018-11-29T12:10:26.000Z</published>
    <updated>2018-11-29T12:25:11.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历"><a href="#144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历" class="headerlink" title="144. Binary Tree Preorder Traversal-二叉树的前序遍历"></a>144. Binary Tree Preorder Traversal-二叉树的前序遍历</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个二叉树，返回它的 前序 遍历。</p><p> 示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure></p><blockquote><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><hr><p>非递归版-使用栈解题<br>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">const</span> TreeNode *&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">const</span> TreeNode *p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            result.push_back(p-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right != <span class="literal">nullptr</span>) s.push(p-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left != <span class="literal">nullptr</span>) s.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">            preorder(root-&gt;left,result);</span><br><span class="line">            preorder(root-&gt;right,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        preorder(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;144. B
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-20. Valid Parentheses</title>
    <link href="https://xhjiang.tech/2018/11/29/leetcode%E5%88%B7%E9%A2%98-20-Valid-Parentheses/"/>
    <id>https://xhjiang.tech/2018/11/29/leetcode刷题-20-Valid-Parentheses/</id>
    <published>2018-11-29T11:38:19.000Z</published>
    <updated>2018-11-29T11:49:58.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20-Valid-Parentheses-有效的括号"><a href="#20-Valid-Parentheses-有效的括号" class="headerlink" title="20. Valid Parentheses-有效的括号"></a>20. Valid Parentheses-有效的括号</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>利用<strong>栈stack数据结构</strong>来解决问题；首先判断字符串是否为空，若为空则返回true；然后判断只要栈中的元素为空，就入栈，而且栈顶和目前的元素无法配对的时候，同样打入栈中，这样避免了一开始就是右括号，不入栈；若栈顶是对应的左括号接下来要访问栈顶的元素，最后只需要判断栈中是不是为空就好了。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; result;  </span><br><span class="line">        <span class="keyword">int</span> n=s.size();  </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)  &#123;  </span><br><span class="line">            <span class="keyword">if</span>(result.empty())  </span><br><span class="line">                result.push(s[i]);  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(result.top()==<span class="string">'('</span>&amp;&amp;s[i]==<span class="string">')'</span>||  </span><br><span class="line">                  result.top()==<span class="string">'['</span>&amp;&amp;s[i]==<span class="string">']'</span>||  </span><br><span class="line">                  result.top()==<span class="string">'&#123;'</span>&amp;&amp;s[i]==<span class="string">'&#125;'</span>)   </span><br><span class="line">                    result.pop();  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                result.push(s[i]);  </span><br><span class="line"></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> result.empty(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;20-Valid-Parentheses-有效的括号&quot;&gt;&lt;a href=&quot;#20-Valid-Parentheses-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;20. Valid Parentheses-有效的括号&quot;&gt;&lt;/a&gt;20. Val
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="栈" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%88/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="栈" scheme="https://xhjiang.tech/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-11. Container With Most Water</title>
    <link href="https://xhjiang.tech/2018/11/28/leetcode%E5%88%B7%E9%A2%98-11-Container-With-Most-Water/"/>
    <id>https://xhjiang.tech/2018/11/28/leetcode刷题-11-Container-With-Most-Water/</id>
    <published>2018-11-28T14:53:05.000Z</published>
    <updated>2018-11-28T15:05:00.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water-盛最多水的容器"><a href="#11-Container-With-Most-Water-盛最多水的容器" class="headerlink" title="11. Container With Most Water-盛最多水的容器"></a>11. Container With Most Water-盛最多水的容器</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong> 你不能倾斜容器，且 n 的值至少为 2。<div align="center"><br><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/leetcode/question_11.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDAo1tspwphcTrXVj2W29WzZffzFfpa5c3&amp;q-sign-time=1543417200;1543419000&amp;q-key-time=1543417200;1543419000&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=88a6e762f29499510c18505700752a1f18c91853&amp;x-cos-security-token=2bc82588c9883bce6d8e820373aa29a8543eb06010001" alt="图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。"></div></p><blockquote><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p></blockquote><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong></p><p>考虑用<strong>双指针</strong>法解题。维护两个指针f、l分别指向数组左右两端，则f和l构成的容器盛水体积计算公式为<strong>min(height[f],height[l])*(l-f)</strong>。可以看出盛水体积取决于容器边中较小的数字和容器底长度。若移动较大的数字，则容器底长度会变小，而盛水的最大高度不变，所以盛水体积不会变更大。因此需要移动两数中较小的数字，这样若中间出现特别大的数字，则有可能提高盛水体积。然后每次移动完更新此时的最大盛水体积，直到两指针相遇。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>,l = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(f &lt; l)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = min(height[f],height[l])*(l-f);</span><br><span class="line">            <span class="keyword">if</span>(area &gt; max)</span><br><span class="line">                max = area;</span><br><span class="line">            <span class="keyword">if</span>(height[f]&lt;height[l])</span><br><span class="line">                f++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;11-Container-With-Most-Water-盛最多水的容器&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;11. Container With M
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-62. Unique Paths</title>
    <link href="https://xhjiang.tech/2018/11/27/leetcode%E5%88%B7%E9%A2%98-62-Unique-Paths/"/>
    <id>https://xhjiang.tech/2018/11/27/leetcode刷题-62-Unique-Paths/</id>
    <published>2018-11-27T14:07:31.000Z</published>
    <updated>2018-11-28T15:04:55.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="62-Unique-Paths-不同路径"><a href="#62-Unique-Paths-不同路径" class="headerlink" title="62. Unique Paths-不同路径"></a>62. Unique Paths-不同路径</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/leetcode/question_62.png?q-sign-algorithm=sha1&amp;q-ak=AKID2vZhp1cvd42VAikuWAywg73c8X0YvzTj&amp;q-sign-time=1543417433;1543419233&amp;q-key-time=1543417433;1543419233&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=aebbb05c9130983eb09642a9bfe67eb7f8298dd2&amp;x-cos-security-token=73c5e962610da5b65c10947356559eb21fe46a6e10001" alt=""></div></p><blockquote><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p></blockquote><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题跟之前那道 Climbing Stairs 很类似，那道题是说可以每次能爬一格或两格，问到达顶部的所有不同爬法的个数。而这道题是每次可以向下走或者向右走，求到达最右下角的所有不同走法的个数。那么跟爬梯子问题一样，我们需要用<strong>动态规划</strong>来解，我们可以维护一个二维数组nums，其中nums[i][j]表示到当前位置不同的走法的个数，然后可以得到<strong>状态转移方程: nums[i][j] = nums[i - 1][j] + nums[i][j - 1]</strong>。</p><p>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(m*n),空间复杂度O(m*n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nums(m,num);</span><br><span class="line">        <span class="comment">//nums[i][j] = nums[i - 1][j] + nums[i][j - 1];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    nums[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nums[i][j] = nums[i - <span class="number">1</span>][j] + nums[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了节省空间，我们使用一维数组nums，一行一行的刷新也可以。</p><p>代码二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(m*n),空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;62-Unique-Paths-不同路径&quot;&gt;&lt;a href=&quot;#62-Unique-Paths-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. Unique Paths-不同路径&quot;&gt;&lt;/a&gt;62. Unique Paths-不同路径&lt;/h1
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-110. Balanced Binary Tree</title>
    <link href="https://xhjiang.tech/2018/11/27/leetcode%E5%88%B7%E9%A2%98-110-Balanced-Binary-Tree/"/>
    <id>https://xhjiang.tech/2018/11/27/leetcode刷题-110-Balanced-Binary-Tree/</id>
    <published>2018-11-27T10:21:10.000Z</published>
    <updated>2018-11-27T14:00:00.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="110-Balanced-Binary-Tree-平衡二叉树"><a href="#110-Balanced-Binary-Tree-平衡二叉树" class="headerlink" title="110. Balanced Binary Tree-平衡二叉树"></a>110. Balanced Binary Tree-平衡二叉树</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure></p><hr><p><strong>代码一：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//时间复杂度O(n),空间复杂度O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> balancedHeight (root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the height of `root` if `root` is a balanced tree,</span></span><br><span class="line"><span class="comment">    * otherwise, returns `-1`.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedHeight</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">int</span> left = balancedHeight (root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = balancedHeight (root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span> || <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>; <span class="comment">// ̸三方合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;110-Balanced-Binary-Tree-平衡二叉树&quot;&gt;&lt;a href=&quot;#110-Balanced-Binary-Tree-平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;110. Balanced Binary Tree-平衡二叉树&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-35. Search Insert Position</title>
    <link href="https://xhjiang.tech/2018/11/25/leetcode%E5%88%B7%E9%A2%98-35-Search-Insert-Position/"/>
    <id>https://xhjiang.tech/2018/11/25/leetcode刷题-35-Search-Insert-Position/</id>
    <published>2018-11-25T15:00:59.000Z</published>
    <updated>2018-11-27T10:20:05.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="35-Search-Insert-Position-搜索插入位置"><a href="#35-Search-Insert-Position-搜索插入位置" class="headerlink" title="35. Search Insert Position-搜索插入位置"></a>35. Search Insert Position-搜索插入位置</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><hr><p>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;target||nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;target&amp;&amp;nums[i+<span class="number">1</span>]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt; target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; target &amp;&amp; A[i+<span class="number">1</span>] &gt; target)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;35-Search-Insert-Position-搜索插入位置&quot;&gt;&lt;a href=&quot;#35-Search-Insert-Position-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;35. Search Insert Position-搜
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="查找" scheme="https://xhjiang.tech/categories/leetcode/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="查找" scheme="https://xhjiang.tech/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-96. Unique Binary Search Trees</title>
    <link href="https://xhjiang.tech/2018/11/25/leetcode%E5%88%B7%E9%A2%98-96-Unique-Binary-Search-Trees/"/>
    <id>https://xhjiang.tech/2018/11/25/leetcode刷题-96-Unique-Binary-Search-Trees/</id>
    <published>2018-11-25T14:48:08.000Z</published>
    <updated>2018-11-27T10:22:12.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="96-Unique-Binary-Search-Trees-不同的二叉搜索树"><a href="#96-Unique-Binary-Search-Trees-不同的二叉搜索树" class="headerlink" title="96. Unique Binary Search Trees-不同的二叉搜索树"></a>96. Unique Binary Search Trees-不同的二叉搜索树</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题我们可以看出一个规律就是当数组为1,2,3…,n时，基于以下原则的构建的BST树具有唯一性：<strong>以i为根节点的树，其左子树由[1,i-1],组成，其右子树由[i+1,n]组成。</strong></p><p>此问题可以看作是一维动态规划问题，可以看出，以i为根节点的树的个数等于：<strong>左子树的个数乘以右子树的个数(其中空子树和单节点树的个数都为1)</strong><br>公式表达为：$$f(i) = \sum_{k=1}^{i}f(k-1)*f(i-k)$$</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n^2),空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)&#123;</span><br><span class="line">                f[i] += f[k<span class="number">-1</span>] * f[i-k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;96-Unique-Binary-Search-Trees-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-Unique-Binary-Search-Trees-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. Unique Binar
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-70. Climbing Stairs</title>
    <link href="https://xhjiang.tech/2018/11/23/leetcode%E5%88%B7%E9%A2%98-70-Climbing-Stairs/"/>
    <id>https://xhjiang.tech/2018/11/23/leetcode刷题-70-Climbing-Stairs/</id>
    <published>2018-11-23T13:41:29.000Z</published>
    <updated>2018-11-23T13:52:11.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-Climbing-Stairs-爬楼梯"><a href="#70-Climbing-Stairs-爬楼梯" class="headerlink" title="70. Climbing Stairs-爬楼梯"></a>70. Climbing Stairs-爬楼梯</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题目实际上跟<strong>斐波那契数列</strong>非常相似，假设梯子有n层，那么如何爬到第n层呢，因为每次只能爬1或2步，那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的，所以递推公式非常容易的就得出了：<strong>dp[n] = dp[n-1] + dp[n-2]</strong>。 由于斐波那契额数列的求解可以用递归，所以最先尝试了递归，拿到OJ上运行，显示Time Limit Exceeded，就是说运行时间超了，因为递归计算了很多分支，效率很低，这里需要用动态规划 (Dynamic Programming) 来提高效率，代码如下：</p><p>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//类似于斐波那契数列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>另外：</strong></p><blockquote><p>我们可以对空间进行进一步优化，我们只用两个整型变量a和b来存储过程值，首先将a+b的值赋给b，然后a赋值为原来的b，所以应该赋值为b-a即可。这样就模拟了上面累加的过程，而不用存储所有的值。</p></blockquote><p>代码二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            b += a;</span><br><span class="line">            a = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;70-Climbing-Stairs-爬楼梯&quot;&gt;&lt;a href=&quot;#70-Climbing-Stairs-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. Climbing Stairs-爬楼梯&quot;&gt;&lt;/a&gt;70. Climbing Stairs
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-9. Palindrome Number</title>
    <link href="https://xhjiang.tech/2018/11/23/leetcode%E5%88%B7%E9%A2%98-9-Palindrome-Number/"/>
    <id>https://xhjiang.tech/2018/11/23/leetcode刷题-9-Palindrome-Number/</id>
    <published>2018-11-23T13:32:22.000Z</published>
    <updated>2018-11-23T13:36:58.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Palindrome-Number-回文数"><a href="#9-Palindrome-Number-回文数" class="headerlink" title="9. Palindrome Number-回文数"></a>9. Palindrome Number-回文数</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>进阶:</p><p>你能不将整数转为字符串来解决这个问题吗？</p><hr><p><strong>思路：</strong></p><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以10的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(log_10 n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9-Palindrome-Number-回文数&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number-回文数&quot; class=&quot;headerlink&quot; title=&quot;9. Palindrome Number-回文数&quot;&gt;&lt;/a&gt;9. Palindrome Nu
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-121. Best Time to Buy and Sell Stock</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-121-Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-121-Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2018-11-22T13:37:09.000Z</published>
    <updated>2018-11-22T13:41:00.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机" class="headerlink" title="121. Best Time to Buy and Sell Stock-买卖股票的最佳时机"></a>121. Best Time to Buy and Sell Stock-买卖股票的最佳时机</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>找到最小的值，然后依次比较最小值后面每个值与最小值的差值的大小，保留最大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到最小的值，然后依次比较最小值后面每个值与最小值的差值的大小，保留最大的差值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;12
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-48. Rotate Image</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-48-Rotate-Image/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-48-Rotate-Image/</id>
    <published>2018-11-22T13:27:41.000Z</published>
    <updated>2018-11-22T13:35:52.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="48-Rotate-Image-旋转图像"><a href="#48-Rotate-Image-旋转图像" class="headerlink" title="48. Rotate Image-旋转图像"></a>48. Rotate Image-旋转图像</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><hr><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="comment">// 沿着副对角线反转</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - <span class="number">1</span> - j][n - <span class="number">1</span> - i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) <span class="comment">// 沿着水平中线反转</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - <span class="number">1</span> - i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;48-Rotate-Image-旋转图像&quot;&gt;&lt;a href=&quot;#48-Rotate-Image-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. Rotate Image-旋转图像&quot;&gt;&lt;/a&gt;48. Rotate Image-旋转图像&lt;/h1
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-12. Integer to Roman</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-12-Integer-to-Roman/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-12-Integer-to-Roman/</id>
    <published>2018-11-21T16:19:10.000Z</published>
    <updated>2018-11-21T16:23:27.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-Integer-to-Roman-整数转罗马数字"><a href="#12-Integer-to-Roman-整数转罗马数字" class="headerlink" title="12. Integer to Roman-整数转罗马数字"></a>12. Integer to Roman-整数转罗马数字</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br></pre></td></tr></table></figure></p><p>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><hr><p><strong>思路：</strong><br>从最高位开始依次求得每个位置上的数字，然后按照罗马字符串数组上对照的罗马字母依次添加到字符串Roman后面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> radix[] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>,</span><br><span class="line">                             <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span> symbol[] = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>,</span><br><span class="line">                                 <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> roman;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; num &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = num / radix[i];</span><br><span class="line">            num %= radix[i];</span><br><span class="line">            <span class="keyword">for</span> (; count &gt; <span class="number">0</span>; --count) roman += symbol[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;12-Integer-to-Roman-整数转罗马数字&quot;&gt;&lt;a href=&quot;#12-Integer-to-Roman-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;12. Integer to Roman-整数转罗马数字&quot;&gt;&lt;/a&gt;12. 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-141. Linked List Cycle</title>
    <link href="https://xhjiang.tech/2018/11/21/leetcode%E5%88%B7%E9%A2%98-141-Linked-List-Cycle/"/>
    <id>https://xhjiang.tech/2018/11/21/leetcode刷题-141-Linked-List-Cycle/</id>
    <published>2018-11-21T15:47:59.000Z</published>
    <updated>2018-11-21T15:53:18.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-Linked-List-Cycle-环形链表"><a href="#141-Linked-List-Cycle-环形链表" class="headerlink" title="141. Linked List Cycle-环形链表"></a>141. Linked List Cycle-环形链表</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个链表，判断链表中是否有环。</p><p><strong>思路：</strong><br>最好的方法是时间复杂度O(n),空间复杂度O(1)。设置两个指针，一个快，一个慢，快的指针每次走两步，慢的指针每次走一步，如果两个指针相遇，则说明有环。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> * Definition <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"> <span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head,*fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;141-Linked-List-Cycle-环形链表&quot;&gt;&lt;a href=&quot;#141-Linked-List-Cycle-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141. Linked List Cycle-环形链表&quot;&gt;&lt;/a&gt;141. Li
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-13.Roman to Integer</title>
    <link href="https://xhjiang.tech/2018/11/20/leetcode%E5%88%B7%E9%A2%98-Roman-to-Integer/"/>
    <id>https://xhjiang.tech/2018/11/20/leetcode刷题-Roman-to-Integer/</id>
    <published>2018-11-20T07:08:44.000Z</published>
    <updated>2018-11-20T08:03:25.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer-罗马数字转整数"><a href="#13-Roman-to-Integer-罗马数字转整数" class="headerlink" title="13. Roman to Integer-罗马数字转整数"></a>13. Roman to Integer-罗马数字转整数</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>从前往后遍历，用一个临时变量记录分段数字。如果当前数字比上一个数字大，说明这一段的值应该用当前这个值减去上一个值，比如<strong>IV = 5 - 1</strong>；否则，将当前值加入到结果中，开始下一段记录。比如：<strong>VI = 5 + 1,II = 1 + 1</strong>;</p><blockquote><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">map</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">map</span>(s[i]) &gt; <span class="built_in">map</span>(s[i<span class="number">-1</span>])))&#123;</span><br><span class="line">                <span class="comment">//这里减去两倍的上一个值是前一个值在迭代时已经加过了，所以要减两次</span></span><br><span class="line">                result += (<span class="built_in">map</span>(s[i]) - <span class="number">2</span> * <span class="built_in">map</span>(s[i<span class="number">-1</span>]));</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">               result += <span class="built_in">map</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;13-Roman-to-Integer-罗马数字转整数&quot;&gt;&lt;a href=&quot;#13-Roman-to-Integer-罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;13. Roman to Integer-罗马数字转整数&quot;&gt;&lt;/a&gt;13. 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-122.Best Time to Buy and Sell Stock II</title>
    <link href="https://xhjiang.tech/2018/11/20/leetcode%E5%88%B7%E9%A2%98-Best-Time-to-Buy-and-Sell-Stock-II/"/>
    <id>https://xhjiang.tech/2018/11/20/leetcode刷题-Best-Time-to-Buy-and-Sell-Stock-II/</id>
    <published>2018-11-20T06:22:32.000Z</published>
    <updated>2018-11-20T07:19:16.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II" class="headerlink" title="122.Best Time to Buy and Sell Stock II-买卖股票的最佳时机 II"></a>122.Best Time to Buy and Sell Stock II-买卖股票的最佳时机 II</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>贪心算法，总是做出在当前看来是最好的选择，不从整体最优上加以考虑，也就是说，只关心当前最优解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>,tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            tmp = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)</span><br><span class="line">                max += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>我们要算的是利润，要有利润，自然要有一次交易。<br>所以我们就说说prices[1]，即是第一天股票价格。按照贪心策略，不关心以后，我们只关心当前利益。第0天买入，花费prices[0]，第一天卖出，得到prices[1]，那么我们的收获就是max = prices[1] - prices[0],那么有两种情况</p><p>1）当max &gt; 0 时，赶紧买入卖出，能赚一笔是一笔，苍蝇再小也是肉嘛 </p><p>2）当max &lt;= 0 时，再买入卖出的话，那就是傻了，白费力气不说，还亏钱。</p><p>以此方式类推下去，即得最大利润。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/categories/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-决策树原理及实战(一)</title>
    <link href="https://xhjiang.tech/2018/11/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/"/>
    <id>https://xhjiang.tech/2018/11/19/机器学习-决策树原理及实战/</id>
    <published>2018-11-19T08:18:30.000Z</published>
    <updated>2018-11-19T09:40:14.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习-决策树原理及实战-一"><a href="#机器学习-决策树原理及实战-一" class="headerlink" title="机器学习-决策树原理及实战(一)"></a>机器学习-决策树原理及实战(一)</h1><hr><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是什么？决策树(decision tree)是一种基本的分类与回归方法。举个通俗易懂的例子，如下图所示的流程图就是一个决策树，长方形代表判断模块(decision block)，椭圆形成代表终止模块(terminating block)，表示已经得出结论，可以终止运行。从判断模块引出的左右箭头称作为分支(branch)，它可以达到另一个判断模块或者终止模块。我们还可以这样理解，分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点(node)和有向边(directed edge)组成。结点有两种类型：内部结点(internal node)和叶结点(leaf node)。内部结点表示一个特征或属性，叶结点表示一个类。蒙圈没？？如下图所示的决策树，长方形和椭圆形都是结点。长方形的结点属于内部结点，椭圆形的结点属于叶结点，从结点引出的左右箭头就是有向边。而最上面的结点就是决策树的根结点(root node)。这样，结点说法就与模块说法对应上了，理解就好。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_1.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDo0bmLPfbfgzegr1ie8G5q8r2MOI6n9nU&amp;q-sign-time=1542615956;1542617756&amp;q-key-time=1542615956;1542617756&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=332b7d6eefee6b6b7e6452cc1399a1ede9fbc4fe&amp;x-cos-security-token=5a09803f8532adcdcaf3e993afe6031a505ccfe510001" alt=""></div></p><p>我们回到这个流程图，对，你没看错，这就是一个假想的相亲对象分类系统。它首先检测相亲对方是否有房。如果有房，则对于这个相亲对象可以考虑进一步接触。如果没有房，则观察相亲对象是否有上进心，如果没有，直接Say Goodbye，此时可以说：”你人很好，但是我们不合适。”如果有，则可以把这个相亲对象列入候选名单，好听点叫候选名单，有点瑕疵地讲，那就是备胎。</p><p>不过这只是个简单的相亲对象分类系统，只是做了简单的分类。真实情况可能要复杂得多，考虑因素也可以是五花八门。脾气好吗？会做饭吗？愿意做家务吗？家里几个孩子？父母是干什么的？天啊，我不想再说下去了，想想都可怕。</p><p>我们可以把决策树看成一个if-then规则的集合，将决策树转换成if-then规则的过程是这样的：由决策树的根结点(root node)到叶结点(leaf node)的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。决策树的路径或其对应的if-then规则集合具有一个重要的性质：互斥并且完备。这就是说，每一个实例都被一条路径或一条规则所覆盖，而且只被一条路径或一条规则所覆盖。这里所覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p><p><strong>使用决策树做预测需要以下过程：</strong></p><ul><li><p>收集数据：可以使用任何方法。比如想构建一个相亲系统，我们可以从媒婆那里，或者通过采访相亲对象获取数据。根据他们考虑的因素和最终的选择结果，就可以得到一些供我们利用的数据了。</p></li><li><p>准备数据：收集完的数据，我们要进行整理，将这些所有收集的信息按照一定规则整理出来，并排版，方便我们进行后续处理。</p></li><li><p>分析数据：可以使用任何方法，决策树构造完成之后，我们可以检查决策树图形是否符合预期。</p></li><li><p>训练算法：这个过程也就是构造决策树，同样也可以说是决策树学习，就是构造一个决策树的数据结构。</p></li><li><p>测试算法：使用经验树计算错误率。当错误率达到了可接收范围，这个决策树就可以投放使用了。</p></li><li><p>使用算法：此步骤可以使用适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。</p></li></ul><hr><h2 id="2-决策树的构建的准备工作"><a href="#2-决策树的构建的准备工作" class="headerlink" title="2.决策树的构建的准备工作"></a>2.决策树的构建的准备工作</h2><p>使用决策树做预测的每一步骤都很重要，数据收集不到位，将会导致没有足够的特征让我们构建错误率低的决策树。数据特征充足，但是不知道用哪些特征好，将会导致无法构建出分类效果好的决策树模型。从算法方面看，决策树的构建是我们的核心内容。</p><p>决策树要如何构建呢？通常，这一过程可以概括为3个步骤：特征选择、决策树的生成和决策树的修剪。</p><h3 id="2-1-特征选择"><a href="#2-1-特征选择" class="headerlink" title="2.1 特征选择"></a>2.1 特征选择</h3><p>特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率，如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。通常特征选择的标准是信息增益(information gain)或信息增益比，为了简单，本文使用信息增益作为选择特征的标准。那么，什么是信息增益？在讲解信息增益之前，让我们看一组实例，贷款申请样本数据表。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_2.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDcUidFOx6g1skcSVTRv9rLw2Yc5mVWxLK&amp;q-sign-time=1542616252;1542618052&amp;q-key-time=1542616252;1542618052&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=905b0b542300a4058c836d61d61c3ac20c863d57&amp;x-cos-security-token=03747c4a3672eba87137fa78e3f603e693f2084c10001" alt=""></div></p><p>希望通过所给的训练数据学习一个贷款申请的决策树，用于对未来的贷款申请进行分类，即当新的客户提出贷款申请时，根据申请人的特征利用决策树决定是否批准贷款申请。</p><p>特征选择就是决定用哪个特征来划分特征空间。比如，我们通过上述数据表得到两个可能的决策树，分别由两个不同特征的根结点构成。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_3.jpg?q-sign-algorithm=sha1&amp;q-ak=AKID7LoSNbZ3PaXBMUDmiyHD5b80PtM7mLge&amp;q-sign-time=1542616298;1542618098&amp;q-key-time=1542616298;1542618098&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=571430898b051ee3d211c06be3e5243329c1c61a&amp;x-cos-security-token=ec57b9d67f7a3fe8e41d393f82e1337fbb4d871510001" alt=""></div></p><p>图(a)所示的根结点的特征是年龄，有3个取值，对应于不同的取值有不同的子结点。图(b)所示的根节点的特征是工作，有2个取值，对应于不同的取值有不同的子结点。两个决策树都可以从此延续下去。问题是：究竟选择哪个特征更好些？这就要求确定选择特征的准则。直观上，如果一个特征具有更好的分类能力，或者说，按照这一特征将训练数据集分割成子集，使得各个子集在当前条件下有最好的分类，那么就更应该选择这个特征。信息增益就能够很好地表示这一直观的准则。</p><blockquote><p>什么是<strong>信息增益</strong>呢？在划分数据集之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。</p></blockquote><p><strong>1)香农熵</strong></p><p>在可以评测哪个数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合信息的度量方式称为香农熵或者简称为熵(entropy)，这个名字来源于信息论之父克劳德·香农。</p><p>如果看不明白什么是信息增益和熵，请不要着急，因为他们自诞生的那一天起，就注定会令世人十分费解。克劳德·香农写完信息论之后，约翰·冯·诺依曼建议使用”熵”这个术语，因为大家都不知道它是什么意思。</p><p>熵定义为信息的期望值。在信息论与概率统计中，熵是表示随机变量不确定性的度量。如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为 ：<br>$$l(x_i) = -\log_2 p(x_i)$$</p><p>其中p(xi)是选择该分类的概率。有人可能会问，信息为啥这样定义啊？答曰：前辈得出的结论。这就跟1+1等于2一样，记住并且会用即可。上述式中的对数以2为底，也可以e为底(自然对数)。</p><p>通过上式，我们可以得到所有类别的信息。为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值(数学期望)，通过下面的公式得到：<br>$$H = -\sum_{i=1}^{n}p(x_i)\log_2 p(x_i) \qquad$$</p><p>期中n是分类的数目。熵越大，随机变量的不确定性就越大。</p><p>当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为经验熵(empirical entropy)。什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。我们定义贷款申请样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ：<br>$$H(D) = -\sum_{k=1}^{K} \frac {|C_k|}{|D|} \log_2 \frac {|C_k|}{|D|} \qquad$$</p><p>根据此公式计算经验熵H(D)，分析贷款申请样本数据表中的数据。最终分类结果只有两类，即放贷和不放贷。根据表中的数据统计可知，在15个数据中，9个数据的结果为放贷，6个数据的结果为不放贷。所以数据集D的经验熵H(D)为：<br>$$H(D) = -\frac{9}{15} \log_2\frac{9}{15}-\frac{6}{15} \log_2\frac{6}{15} = 0.971 \qquad$$</p><p>经过计算可知，数据集D的经验熵H(D)的值为0.971。</p><p><strong>2)编写代码计算经验熵</strong></p><p>在编写代码之前，我们先对数据集进行属性标注。</p><ul><li>年龄：0代表青年，1代表中年，2代表老年；</li><li>有工作：0代表否，1代表是；</li><li>有自己的房子：0代表否，1代表是；</li><li>信贷情况：0代表一般，1代表好，2代表非常好；</li><li>类别(是否给贷款)：no代表否，yes代表是。</li></ul><p>确定这些之后，我们就可以创建数据集，并计算经验熵了，代码编写如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:创建测试数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">    labels - 分类属性</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],  <span class="comment"># 数据集</span></span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'不放贷'</span>, <span class="string">'放贷'</span>]  <span class="comment"># 分类属性</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels  <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:计算给定数据集的经验熵(香农熵)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    shannonEnt - 经验熵(香农熵)</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numEntires = len(dataSet)  <span class="comment"># 返回数据集的行数</span></span><br><span class="line">    labelCounts = &#123;&#125;  <span class="comment"># 保存每个标签(Label)出现次数的字典</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]  <span class="comment"># 提取标签(Label)信息</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():  <span class="comment"># 如果标签(Label)没有放入统计次数的字典,添加进去</span></span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment"># Label计数</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵(香农熵)</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:  <span class="comment"># 计算香农熵</span></span><br><span class="line">        prob = float(labelCounts[key]) / numEntires  <span class="comment"># 选择该标签(Label)的概率</span></span><br><span class="line">        shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># 利用公式计算</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt  <span class="comment"># 返回经验熵(香农熵)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dataSet, features = createDataSet()</span><br><span class="line">    print(dataSet)</span><br><span class="line">    print(calcShannonEnt(dataSet))</span><br></pre></td></tr></table></figure><p>代码运行结果如下图所示，代码是先打印训练数据集，然后打印计算的经验熵H(D)，程序计算的结果与我们统计计算的结果是一致的，程序没有问题。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_8.jpg?q-sign-algorithm=sha1&amp;q-ak=AKID7xfLaZY0Sf90r7bU4ZIQQPFld0ShPaLj&amp;q-sign-time=1542618680;1542620480&amp;q-key-time=1542618680;1542620480&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=796c7027aa9403cc50084ae1b420bef12fcefca8&amp;x-cos-security-token=c71fa4695aae6d64d7ba3551fe73072e003d9af210001" alt=""></div></p><p><strong>3)信息增益</strong></p><p>在上面，我们已经说过，如何选择特征，需要看信息增益。也就是说，信息增益是相对于特征而言的，信息增益越大，特征对最终的分类结果影响也就越大，我们就应该选择对最终分类结果影响最大的那个特征作为我们的分类特征。</p><p>在讲解信息增益定义之前，我们还需要明确一个概念，条件熵。</p><p>熵我们知道是什么，条件熵又是个什么鬼？条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，随机变量X给定的条件下随机变量Y的条件熵(conditional entropy)H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望：<br>$$H(Y|X) = -\sum_{i=1}^{n} p_i H(Y|X=x_i) \qquad$$</p><p>这里，<br>$$p_i = P(X = x_i),i = 1, 2,…,n$$</p><p>同理，当条件熵中的概率由数据估计(特别是极大似然估计)得到时，所对应的条件熵称为条件经验熵(empirical conditional entropy)。</p><p>明确了条件熵和经验条件熵的概念。接下来，让我们说说信息增益。前面也提到了，信息增益是相对于特征而言的。所以，特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即：<br>$$g (D,A) = H(D) - H(D|A)$$</p><p>一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p><p>设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数。于是经验条件熵的公式可以些为：<br>$$H(D|A) = \sum_{i=1}^{n} \frac {|D_i|}{|D|}H(D_i) = -\sum_{i=1}^{n} \frac {|D_i|}{|D|}\sum_{k=1}^{K} \frac {|D_{ik}|}{|D_i|} \log_2 \frac {|D_{ik}|}{|D_i|}$$</p><p>说了这么多概念性的东西，没有听懂也没有关系，举几个例子，再回来看一下概念，就懂了。</p><p>以贷款申请样本数据表为例进行说明。看下年龄这一列的数据，也就是特征A1，一共有三个类别，分别是：青年、中年和老年。我们只看年龄是青年的数据，年龄是青年的数据一共有5个，所以年龄是青年的数据在训练数据集出现的概率是十五分之五，也就是三分之一。同理，年龄是中年和老年的数据在训练数据集出现的概率也都是三分之一。现在我们只看年龄是青年的数据的最终得到贷款的概率为五分之二，因为在五个数据中，只有两个数据显示拿到了最终的贷款，同理，年龄是中年和老年的数据最终得到贷款的概率分别为五分之三、五分之四。所以计算年龄的信息增益，过程如下：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_13.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDdNqb8A6wqNlwt72O0cx4OIBpRKBDy6Z8&amp;q-sign-time=1542619737;1542621537&amp;q-key-time=1542619737;1542621537&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=d5bf3b836adeb09ab318fd15052dbe8bc07e534a&amp;x-cos-security-token=bfa078927345c660cac46791c51c6ec6410cacff10001" alt=""></div></p><p>同理，计算其余特征的信息增益g(D,A2)、g(D,A3)和g(D,A4)。分别为：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_14_m.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDSl7ywpwES4SEZ18ilCEH0T3bgKFszgXz&amp;q-sign-time=1542619793;1542621593&amp;q-key-time=1542619793;1542621593&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=9c306ce1b2af835bef3aa8cd67e1eb8e67a73ad3&amp;x-cos-security-token=7f741e6a28643d82f9a0cd1483c9474d1efe97c310001" alt=""></div></p><p>最后，比较特征的信息增益，由于特征A3(有自己的房子)的信息增益值最大，所以选择A3作为最优特征。</p><p><strong>4) 编写代码计算信息增益</strong></p><p>我们已经学会了通过公式计算信息增益，接下来编写代码，计算信息增益。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:计算给定数据集的经验熵(香农熵)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    shannonEnt - 经验熵(香农熵)</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numEntires = len(dataSet)  <span class="comment"># 返回数据集的行数</span></span><br><span class="line">    labelCounts = &#123;&#125;  <span class="comment"># 保存每个标签(Label)出现次数的字典</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]  <span class="comment"># 提取标签(Label)信息</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():  <span class="comment"># 如果标签(Label)没有放入统计次数的字典,添加进去</span></span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment"># Label计数</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵(香农熵)</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:  <span class="comment"># 计算香农熵</span></span><br><span class="line">        prob = float(labelCounts[key]) / numEntires  <span class="comment"># 选择该标签(Label)的概率</span></span><br><span class="line">        shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># 利用公式计算</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt  <span class="comment"># 返回经验熵(香农熵)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:创建测试数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">    labels - 分类属性</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],  <span class="comment"># 数据集</span></span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'不放贷'</span>, <span class="string">'放贷'</span>]  <span class="comment"># 分类属性</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels  <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:按照给定特征划分数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 待划分的数据集</span></span><br><span class="line"><span class="string">    axis - 划分数据集的特征</span></span><br><span class="line"><span class="string">    value - 需要返回的特征的值</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    retDataSet = []  <span class="comment"># 创建返回的数据集列表</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 遍历数据集</span></span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]  <span class="comment"># 去掉axis特征</span></span><br><span class="line">            reducedFeatVec.extend(featVec[axis + <span class="number">1</span>:])  <span class="comment"># 将符合条件的添加到返回的数据集</span></span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet  <span class="comment"># 返回划分后的数据集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:选择最优特征</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    bestFeature - 信息增益最大的(最优)特征的索引值</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 特征数量</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)  <span class="comment"># 计算数据集的香农熵</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>  <span class="comment"># 信息增益</span></span><br><span class="line">    bestFeature = <span class="number">-1</span>  <span class="comment"># 最优特征的索引值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):  <span class="comment"># 遍历所有特征</span></span><br><span class="line">        <span class="comment"># 获取dataSet的第i个所有特征</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        uniqueVals = set(featList)  <span class="comment"># 创建set集合&#123;&#125;,元素不可重复</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span>  <span class="comment"># 经验条件熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:  <span class="comment"># 计算信息增益</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)  <span class="comment"># subDataSet划分后的子集</span></span><br><span class="line">            prob = len(subDataSet) / float(len(dataSet))  <span class="comment"># 计算子集的概率</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)  <span class="comment"># 根据公式计算经验条件熵</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy  <span class="comment"># 信息增益</span></span><br><span class="line">        print(<span class="string">"第%d个特征的增益为%.3f"</span> % (i, infoGain))  <span class="comment"># 打印每个特征的信息增益</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):  <span class="comment"># 计算信息增益</span></span><br><span class="line">            bestInfoGain = infoGain  <span class="comment"># 更新信息增益，找到最大的信息增益</span></span><br><span class="line">            bestFeature = i  <span class="comment"># 记录信息增益最大的特征的索引值</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature  <span class="comment"># 返回信息增益最大的特征的索引值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dataSet, features = createDataSet()</span><br><span class="line">    print(<span class="string">"最优特征索引值:"</span> + str(chooseBestFeatureToSplit(dataSet)))</span><br></pre></td></tr></table></figure><p>splitDataSet函数是用来选择各个特征的子集的，比如选择年龄(第0个特征)的青年(用0代表)的自己，我们可以调用splitDataSet(dataSet,0,0)这样返回的子集就是年龄为青年的5个数据集。chooseBestFeatureToSplit是选择选择最优特征的函数。运行代码结果如下：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_17.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDXFJonnnEnE77YzSjHGXnVgA71i3hSz7C&amp;q-sign-time=1542620152;1542621952&amp;q-key-time=1542620152;1542621952&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=72e63ad8f9caf9c1aaded1fc2c462ac8a7d5c4b5&amp;x-cos-security-token=08d3672a0cc604a03b6686b7b2ebd4dc9c6dca9c10001" alt=""></div></p><p>对比我们自己计算的结果，发现结果完全正确！最优特征的索引值为2，也就是特征A3(有自己的房子)。</p><h2 id="决策树生成和修剪"><a href="#决策树生成和修剪" class="headerlink" title="决策树生成和修剪"></a>决策树生成和修剪</h2><p>我们已经学习了从数据集构造决策树算法所需要的子功能模块，包括经验熵的计算和最优特征的选择，其工作原理如下：得到原始数据集，然后基于最好的属性值划分数据集，由于特征值可能多于两个，因此可能存在大于两个分支的数据集划分。第一次划分之后，数据集被向下传递到树的分支的下一个结点。在这个结点上，我们可以再次划分数据。因此我们可以采用递归的原则处理数据集。</p><p>构建决策树的算法有很多，比如<strong>C4.5、ID3和CART</strong>，这些算法在运行时并不总是在每次划分数据分组时都会消耗特征。由于特征数目并不是每次划分数据分组时都减少，因此这些算法在实际使用时可能引起一定的问题。目前我们并不需要考虑这个问题，只需要在算法开始运行前计算列的数目，查看算法是否使用了所有属性即可。</p><p>决策树生成算法递归地产生决策树，直到不能继续下去未为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲解了如何计算数据集的经验熵和如何选择最优特征作为分类特征。决策树如何生成、修剪、可视化，以及整体实例练习，会在后续的文章中进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习-决策树原理及实战-一&quot;&gt;&lt;a href=&quot;#机器学习-决策树原理及实战-一&quot; class=&quot;headerlink&quot; title=&quot;机器学习-决策树原理及实战(一)&quot;&gt;&lt;/a&gt;机器学习-决策树原理及实战(一)&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;决策树&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="https://xhjiang.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://xhjiang.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-111.Minimum Depth of Binary Tree</title>
    <link href="https://xhjiang.tech/2018/11/19/leetcode%E5%88%B7%E9%A2%98-Minimum-Depth-of-Binary-Tree/"/>
    <id>https://xhjiang.tech/2018/11/19/leetcode刷题-Minimum-Depth-of-Binary-Tree/</id>
    <published>2018-11-19T07:44:56.000Z</published>
    <updated>2018-11-20T07:19:58.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度"><a href="#111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度" class="headerlink" title="111. Minimum Depth of Binary Tree-二叉树的最小深度"></a>111. Minimum Depth of Binary Tree-二叉树的最小深度</h1><hr><p><strong>描述：</strong><br>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回它的最小深度  2.</p><hr><p>递归方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//时间复杂度O(n),空间复杂度O(log(n))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(<span class="keyword">const</span> TreeNode *root, <span class="keyword">bool</span> hasbrother)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> hasbrother ? INT_MAX : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(minDepth(root-&gt;left, root-&gt;right != <span class="literal">NULL</span>),</span><br><span class="line">                       minDepth(root-&gt;right, root-&gt;left != <span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度&quot;&gt;&lt;a href=&quot;#111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;111. Minim
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
