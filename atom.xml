<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>difcreate&#39;s blog</title>
  
  <subtitle>偷得浮生半日闲</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xhjiang.tech/"/>
  <updated>2018-11-27T10:11:34.301Z</updated>
  <id>https://xhjiang.tech/</id>
  
  <author>
    <name>difcreate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode刷题-35. Search Insert Position</title>
    <link href="https://xhjiang.tech/2018/11/25/leetcode%E5%88%B7%E9%A2%98-35-Search-Insert-Position/"/>
    <id>https://xhjiang.tech/2018/11/25/leetcode刷题-35-Search-Insert-Position/</id>
    <published>2018-11-25T15:00:59.000Z</published>
    <updated>2018-11-27T10:11:34.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="35-Search-Insert-Position-搜索插入位置"><a href="#35-Search-Insert-Position-搜索插入位置" class="headerlink" title="35. Search Insert Position-搜索插入位置"></a>35. Search Insert Position-搜索插入位置</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><hr><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;target||nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;target&amp;&amp;nums[i+<span class="number">1</span>]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;35-Search-Insert-Position-搜索插入位置&quot;&gt;&lt;a href=&quot;#35-Search-Insert-Position-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;35. Search Insert Position-搜
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="查找" scheme="https://xhjiang.tech/categories/leetcode/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="查找" scheme="https://xhjiang.tech/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-96. Unique Binary Search Trees</title>
    <link href="https://xhjiang.tech/2018/11/25/leetcode%E5%88%B7%E9%A2%98-96-Unique-Binary-Search-Trees/"/>
    <id>https://xhjiang.tech/2018/11/25/leetcode刷题-96-Unique-Binary-Search-Trees/</id>
    <published>2018-11-25T14:48:08.000Z</published>
    <updated>2018-11-25T14:59:51.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="96-Unique-Binary-Search-Trees-不同的二叉搜索树"><a href="#96-Unique-Binary-Search-Trees-不同的二叉搜索树" class="headerlink" title="96. Unique Binary Search Trees-不同的二叉搜索树"></a>96. Unique Binary Search Trees-不同的二叉搜索树</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题我们可以看出一个规律就是当数组为1,2,3…,n时，基于以下原则的构建的BST树具有唯一性：<strong>以i为根节点的树，其左子树由[1,i-1],组成，其右子树由[i+1,n]组成。</strong></p><p>此问题可以看作是一维动态规划问题，可以看出，以i为根节点的树的个数等于：左子树的个数乘以右子树的个数(其中空子树和单节点树的个数都为1)<br>公式表达为：$$f(i) = \sum_{k=1}^{i}f(k-1)*f(i-k)$$</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n^2),空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)&#123;</span><br><span class="line">                f[i] += f[k<span class="number">-1</span>] * f[i-k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;96-Unique-Binary-Search-Trees-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-Unique-Binary-Search-Trees-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. Unique Binar
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-70. Climbing Stairs</title>
    <link href="https://xhjiang.tech/2018/11/23/leetcode%E5%88%B7%E9%A2%98-70-Climbing-Stairs/"/>
    <id>https://xhjiang.tech/2018/11/23/leetcode刷题-70-Climbing-Stairs/</id>
    <published>2018-11-23T13:41:29.000Z</published>
    <updated>2018-11-23T13:52:11.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-Climbing-Stairs-爬楼梯"><a href="#70-Climbing-Stairs-爬楼梯" class="headerlink" title="70. Climbing Stairs-爬楼梯"></a>70. Climbing Stairs-爬楼梯</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题目实际上跟<strong>斐波那契数列</strong>非常相似，假设梯子有n层，那么如何爬到第n层呢，因为每次只能爬1或2步，那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的，所以递推公式非常容易的就得出了：<strong>dp[n] = dp[n-1] + dp[n-2]</strong>。 由于斐波那契额数列的求解可以用递归，所以最先尝试了递归，拿到OJ上运行，显示Time Limit Exceeded，就是说运行时间超了，因为递归计算了很多分支，效率很低，这里需要用动态规划 (Dynamic Programming) 来提高效率，代码如下：</p><p>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//类似于斐波那契数列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>另外：</strong></p><blockquote><p>我们可以对空间进行进一步优化，我们只用两个整型变量a和b来存储过程值，首先将a+b的值赋给b，然后a赋值为原来的b，所以应该赋值为b-a即可。这样就模拟了上面累加的过程，而不用存储所有的值。</p></blockquote><p>代码二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            b += a;</span><br><span class="line">            a = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;70-Climbing-Stairs-爬楼梯&quot;&gt;&lt;a href=&quot;#70-Climbing-Stairs-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. Climbing Stairs-爬楼梯&quot;&gt;&lt;/a&gt;70. Climbing Stairs
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-9. Palindrome Number</title>
    <link href="https://xhjiang.tech/2018/11/23/leetcode%E5%88%B7%E9%A2%98-9-Palindrome-Number/"/>
    <id>https://xhjiang.tech/2018/11/23/leetcode刷题-9-Palindrome-Number/</id>
    <published>2018-11-23T13:32:22.000Z</published>
    <updated>2018-11-23T13:36:58.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Palindrome-Number-回文数"><a href="#9-Palindrome-Number-回文数" class="headerlink" title="9. Palindrome Number-回文数"></a>9. Palindrome Number-回文数</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>进阶:</p><p>你能不将整数转为字符串来解决这个问题吗？</p><hr><p><strong>思路：</strong></p><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以10的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(log_10 n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9-Palindrome-Number-回文数&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number-回文数&quot; class=&quot;headerlink&quot; title=&quot;9. Palindrome Number-回文数&quot;&gt;&lt;/a&gt;9. Palindrome Nu
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-121. Best Time to Buy and Sell Stock</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-121-Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-121-Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2018-11-22T13:37:09.000Z</published>
    <updated>2018-11-22T13:41:00.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机" class="headerlink" title="121. Best Time to Buy and Sell Stock-买卖股票的最佳时机"></a>121. Best Time to Buy and Sell Stock-买卖股票的最佳时机</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>找到最小的值，然后依次比较最小值后面每个值与最小值的差值的大小，保留最大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到最小的值，然后依次比较最小值后面每个值与最小值的差值的大小，保留最大的差值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;12
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-48. Rotate Image</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-48-Rotate-Image/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-48-Rotate-Image/</id>
    <published>2018-11-22T13:27:41.000Z</published>
    <updated>2018-11-22T13:35:52.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="48-Rotate-Image-旋转图像"><a href="#48-Rotate-Image-旋转图像" class="headerlink" title="48. Rotate Image-旋转图像"></a>48. Rotate Image-旋转图像</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><hr><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="comment">// 沿着副对角线反转</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - <span class="number">1</span> - j][n - <span class="number">1</span> - i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) <span class="comment">// 沿着水平中线反转</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - <span class="number">1</span> - i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;48-Rotate-Image-旋转图像&quot;&gt;&lt;a href=&quot;#48-Rotate-Image-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. Rotate Image-旋转图像&quot;&gt;&lt;/a&gt;48. Rotate Image-旋转图像&lt;/h1
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-12. Integer to Roman</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-12-Integer-to-Roman/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-12-Integer-to-Roman/</id>
    <published>2018-11-21T16:19:10.000Z</published>
    <updated>2018-11-21T16:23:27.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-Integer-to-Roman-整数转罗马数字"><a href="#12-Integer-to-Roman-整数转罗马数字" class="headerlink" title="12. Integer to Roman-整数转罗马数字"></a>12. Integer to Roman-整数转罗马数字</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br></pre></td></tr></table></figure></p><p>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><hr><p><strong>思路：</strong><br>从最高位开始依次求得每个位置上的数字，然后按照罗马字符串数组上对照的罗马字母依次添加到字符串Roman后面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> radix[] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>,</span><br><span class="line">                             <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span> symbol[] = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>,</span><br><span class="line">                                 <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> roman;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; num &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = num / radix[i];</span><br><span class="line">            num %= radix[i];</span><br><span class="line">            <span class="keyword">for</span> (; count &gt; <span class="number">0</span>; --count) roman += symbol[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;12-Integer-to-Roman-整数转罗马数字&quot;&gt;&lt;a href=&quot;#12-Integer-to-Roman-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;12. Integer to Roman-整数转罗马数字&quot;&gt;&lt;/a&gt;12. 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-141. Linked List Cycle</title>
    <link href="https://xhjiang.tech/2018/11/21/leetcode%E5%88%B7%E9%A2%98-141-Linked-List-Cycle/"/>
    <id>https://xhjiang.tech/2018/11/21/leetcode刷题-141-Linked-List-Cycle/</id>
    <published>2018-11-21T15:47:59.000Z</published>
    <updated>2018-11-21T15:53:18.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-Linked-List-Cycle-环形链表"><a href="#141-Linked-List-Cycle-环形链表" class="headerlink" title="141. Linked List Cycle-环形链表"></a>141. Linked List Cycle-环形链表</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个链表，判断链表中是否有环。</p><p><strong>思路：</strong><br>最好的方法是时间复杂度O(n),空间复杂度O(1)。设置两个指针，一个快，一个慢，快的指针每次走两步，慢的指针每次走一步，如果两个指针相遇，则说明有环。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> * Definition <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"> <span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head,*fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;141-Linked-List-Cycle-环形链表&quot;&gt;&lt;a href=&quot;#141-Linked-List-Cycle-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141. Linked List Cycle-环形链表&quot;&gt;&lt;/a&gt;141. Li
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-13.Roman to Integer</title>
    <link href="https://xhjiang.tech/2018/11/20/leetcode%E5%88%B7%E9%A2%98-Roman-to-Integer/"/>
    <id>https://xhjiang.tech/2018/11/20/leetcode刷题-Roman-to-Integer/</id>
    <published>2018-11-20T07:08:44.000Z</published>
    <updated>2018-11-20T08:03:25.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer-罗马数字转整数"><a href="#13-Roman-to-Integer-罗马数字转整数" class="headerlink" title="13. Roman to Integer-罗马数字转整数"></a>13. Roman to Integer-罗马数字转整数</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>从前往后遍历，用一个临时变量记录分段数字。如果当前数字比上一个数字大，说明这一段的值应该用当前这个值减去上一个值，比如<strong>IV = 5 - 1</strong>；否则，将当前值加入到结果中，开始下一段记录。比如：<strong>VI = 5 + 1,II = 1 + 1</strong>;</p><blockquote><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">map</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">map</span>(s[i]) &gt; <span class="built_in">map</span>(s[i<span class="number">-1</span>])))&#123;</span><br><span class="line">                <span class="comment">//这里减去两倍的上一个值是前一个值在迭代时已经加过了，所以要减两次</span></span><br><span class="line">                result += (<span class="built_in">map</span>(s[i]) - <span class="number">2</span> * <span class="built_in">map</span>(s[i<span class="number">-1</span>]));</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">               result += <span class="built_in">map</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;13-Roman-to-Integer-罗马数字转整数&quot;&gt;&lt;a href=&quot;#13-Roman-to-Integer-罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;13. Roman to Integer-罗马数字转整数&quot;&gt;&lt;/a&gt;13. 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-122.Best Time to Buy and Sell Stock II</title>
    <link href="https://xhjiang.tech/2018/11/20/leetcode%E5%88%B7%E9%A2%98-Best-Time-to-Buy-and-Sell-Stock-II/"/>
    <id>https://xhjiang.tech/2018/11/20/leetcode刷题-Best-Time-to-Buy-and-Sell-Stock-II/</id>
    <published>2018-11-20T06:22:32.000Z</published>
    <updated>2018-11-20T07:19:16.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II" class="headerlink" title="122.Best Time to Buy and Sell Stock II-买卖股票的最佳时机 II"></a>122.Best Time to Buy and Sell Stock II-买卖股票的最佳时机 II</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>贪心算法，总是做出在当前看来是最好的选择，不从整体最优上加以考虑，也就是说，只关心当前最优解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>,tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            tmp = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)</span><br><span class="line">                max += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>我们要算的是利润，要有利润，自然要有一次交易。<br>所以我们就说说prices[1]，即是第一天股票价格。按照贪心策略，不关心以后，我们只关心当前利益。第0天买入，花费prices[0]，第一天卖出，得到prices[1]，那么我们的收获就是max = prices[1] - prices[0],那么有两种情况</p><p>1）当max &gt; 0 时，赶紧买入卖出，能赚一笔是一笔，苍蝇再小也是肉嘛 </p><p>2）当max &lt;= 0 时，再买入卖出的话，那就是傻了，白费力气不说，还亏钱。</p><p>以此方式类推下去，即得最大利润。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/categories/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-决策树原理及实战(一)</title>
    <link href="https://xhjiang.tech/2018/11/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%88%98/"/>
    <id>https://xhjiang.tech/2018/11/19/机器学习-决策树原理及实战/</id>
    <published>2018-11-19T08:18:30.000Z</published>
    <updated>2018-11-19T09:40:14.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习-决策树原理及实战-一"><a href="#机器学习-决策树原理及实战-一" class="headerlink" title="机器学习-决策树原理及实战(一)"></a>机器学习-决策树原理及实战(一)</h1><hr><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是什么？决策树(decision tree)是一种基本的分类与回归方法。举个通俗易懂的例子，如下图所示的流程图就是一个决策树，长方形代表判断模块(decision block)，椭圆形成代表终止模块(terminating block)，表示已经得出结论，可以终止运行。从判断模块引出的左右箭头称作为分支(branch)，它可以达到另一个判断模块或者终止模块。我们还可以这样理解，分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点(node)和有向边(directed edge)组成。结点有两种类型：内部结点(internal node)和叶结点(leaf node)。内部结点表示一个特征或属性，叶结点表示一个类。蒙圈没？？如下图所示的决策树，长方形和椭圆形都是结点。长方形的结点属于内部结点，椭圆形的结点属于叶结点，从结点引出的左右箭头就是有向边。而最上面的结点就是决策树的根结点(root node)。这样，结点说法就与模块说法对应上了，理解就好。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_1.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDo0bmLPfbfgzegr1ie8G5q8r2MOI6n9nU&amp;q-sign-time=1542615956;1542617756&amp;q-key-time=1542615956;1542617756&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=332b7d6eefee6b6b7e6452cc1399a1ede9fbc4fe&amp;x-cos-security-token=5a09803f8532adcdcaf3e993afe6031a505ccfe510001" alt=""></div></p><p>我们回到这个流程图，对，你没看错，这就是一个假想的相亲对象分类系统。它首先检测相亲对方是否有房。如果有房，则对于这个相亲对象可以考虑进一步接触。如果没有房，则观察相亲对象是否有上进心，如果没有，直接Say Goodbye，此时可以说：”你人很好，但是我们不合适。”如果有，则可以把这个相亲对象列入候选名单，好听点叫候选名单，有点瑕疵地讲，那就是备胎。</p><p>不过这只是个简单的相亲对象分类系统，只是做了简单的分类。真实情况可能要复杂得多，考虑因素也可以是五花八门。脾气好吗？会做饭吗？愿意做家务吗？家里几个孩子？父母是干什么的？天啊，我不想再说下去了，想想都可怕。</p><p>我们可以把决策树看成一个if-then规则的集合，将决策树转换成if-then规则的过程是这样的：由决策树的根结点(root node)到叶结点(leaf node)的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点的类对应着规则的结论。决策树的路径或其对应的if-then规则集合具有一个重要的性质：互斥并且完备。这就是说，每一个实例都被一条路径或一条规则所覆盖，而且只被一条路径或一条规则所覆盖。这里所覆盖是指实例的特征与路径上的特征一致或实例满足规则的条件。</p><p><strong>使用决策树做预测需要以下过程：</strong></p><ul><li><p>收集数据：可以使用任何方法。比如想构建一个相亲系统，我们可以从媒婆那里，或者通过采访相亲对象获取数据。根据他们考虑的因素和最终的选择结果，就可以得到一些供我们利用的数据了。</p></li><li><p>准备数据：收集完的数据，我们要进行整理，将这些所有收集的信息按照一定规则整理出来，并排版，方便我们进行后续处理。</p></li><li><p>分析数据：可以使用任何方法，决策树构造完成之后，我们可以检查决策树图形是否符合预期。</p></li><li><p>训练算法：这个过程也就是构造决策树，同样也可以说是决策树学习，就是构造一个决策树的数据结构。</p></li><li><p>测试算法：使用经验树计算错误率。当错误率达到了可接收范围，这个决策树就可以投放使用了。</p></li><li><p>使用算法：此步骤可以使用适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。</p></li></ul><hr><h2 id="2-决策树的构建的准备工作"><a href="#2-决策树的构建的准备工作" class="headerlink" title="2.决策树的构建的准备工作"></a>2.决策树的构建的准备工作</h2><p>使用决策树做预测的每一步骤都很重要，数据收集不到位，将会导致没有足够的特征让我们构建错误率低的决策树。数据特征充足，但是不知道用哪些特征好，将会导致无法构建出分类效果好的决策树模型。从算法方面看，决策树的构建是我们的核心内容。</p><p>决策树要如何构建呢？通常，这一过程可以概括为3个步骤：特征选择、决策树的生成和决策树的修剪。</p><h3 id="2-1-特征选择"><a href="#2-1-特征选择" class="headerlink" title="2.1 特征选择"></a>2.1 特征选择</h3><p>特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率，如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。通常特征选择的标准是信息增益(information gain)或信息增益比，为了简单，本文使用信息增益作为选择特征的标准。那么，什么是信息增益？在讲解信息增益之前，让我们看一组实例，贷款申请样本数据表。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_2.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDcUidFOx6g1skcSVTRv9rLw2Yc5mVWxLK&amp;q-sign-time=1542616252;1542618052&amp;q-key-time=1542616252;1542618052&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=905b0b542300a4058c836d61d61c3ac20c863d57&amp;x-cos-security-token=03747c4a3672eba87137fa78e3f603e693f2084c10001" alt=""></div></p><p>希望通过所给的训练数据学习一个贷款申请的决策树，用于对未来的贷款申请进行分类，即当新的客户提出贷款申请时，根据申请人的特征利用决策树决定是否批准贷款申请。</p><p>特征选择就是决定用哪个特征来划分特征空间。比如，我们通过上述数据表得到两个可能的决策树，分别由两个不同特征的根结点构成。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_3.jpg?q-sign-algorithm=sha1&amp;q-ak=AKID7LoSNbZ3PaXBMUDmiyHD5b80PtM7mLge&amp;q-sign-time=1542616298;1542618098&amp;q-key-time=1542616298;1542618098&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=571430898b051ee3d211c06be3e5243329c1c61a&amp;x-cos-security-token=ec57b9d67f7a3fe8e41d393f82e1337fbb4d871510001" alt=""></div></p><p>图(a)所示的根结点的特征是年龄，有3个取值，对应于不同的取值有不同的子结点。图(b)所示的根节点的特征是工作，有2个取值，对应于不同的取值有不同的子结点。两个决策树都可以从此延续下去。问题是：究竟选择哪个特征更好些？这就要求确定选择特征的准则。直观上，如果一个特征具有更好的分类能力，或者说，按照这一特征将训练数据集分割成子集，使得各个子集在当前条件下有最好的分类，那么就更应该选择这个特征。信息增益就能够很好地表示这一直观的准则。</p><blockquote><p>什么是<strong>信息增益</strong>呢？在划分数据集之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。</p></blockquote><p><strong>1)香农熵</strong></p><p>在可以评测哪个数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合信息的度量方式称为香农熵或者简称为熵(entropy)，这个名字来源于信息论之父克劳德·香农。</p><p>如果看不明白什么是信息增益和熵，请不要着急，因为他们自诞生的那一天起，就注定会令世人十分费解。克劳德·香农写完信息论之后，约翰·冯·诺依曼建议使用”熵”这个术语，因为大家都不知道它是什么意思。</p><p>熵定义为信息的期望值。在信息论与概率统计中，熵是表示随机变量不确定性的度量。如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为 ：<br>$$l(x_i) = -\log_2 p(x_i)$$</p><p>其中p(xi)是选择该分类的概率。有人可能会问，信息为啥这样定义啊？答曰：前辈得出的结论。这就跟1+1等于2一样，记住并且会用即可。上述式中的对数以2为底，也可以e为底(自然对数)。</p><p>通过上式，我们可以得到所有类别的信息。为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值(数学期望)，通过下面的公式得到：<br>$$H = -\sum_{i=1}^{n}p(x_i)\log_2 p(x_i) \qquad$$</p><p>期中n是分类的数目。熵越大，随机变量的不确定性就越大。</p><p>当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为经验熵(empirical entropy)。什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。我们定义贷款申请样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。设有K个类Ck, = 1,2,3,…,K,|Ck|为属于类Ck的样本个数，因此经验熵公式就可以写为 ：<br>$$H(D) = -\sum_{k=1}^{K} \frac {|C_k|}{|D|} \log_2 \frac {|C_k|}{|D|} \qquad$$</p><p>根据此公式计算经验熵H(D)，分析贷款申请样本数据表中的数据。最终分类结果只有两类，即放贷和不放贷。根据表中的数据统计可知，在15个数据中，9个数据的结果为放贷，6个数据的结果为不放贷。所以数据集D的经验熵H(D)为：<br>$$H(D) = -\frac{9}{15} \log_2\frac{9}{15}-\frac{6}{15} \log_2\frac{6}{15} = 0.971 \qquad$$</p><p>经过计算可知，数据集D的经验熵H(D)的值为0.971。</p><p><strong>2)编写代码计算经验熵</strong></p><p>在编写代码之前，我们先对数据集进行属性标注。</p><ul><li>年龄：0代表青年，1代表中年，2代表老年；</li><li>有工作：0代表否，1代表是；</li><li>有自己的房子：0代表否，1代表是；</li><li>信贷情况：0代表一般，1代表好，2代表非常好；</li><li>类别(是否给贷款)：no代表否，yes代表是。</li></ul><p>确定这些之后，我们就可以创建数据集，并计算经验熵了，代码编写如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:创建测试数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">    labels - 分类属性</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],  <span class="comment"># 数据集</span></span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'不放贷'</span>, <span class="string">'放贷'</span>]  <span class="comment"># 分类属性</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels  <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:计算给定数据集的经验熵(香农熵)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    shannonEnt - 经验熵(香农熵)</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numEntires = len(dataSet)  <span class="comment"># 返回数据集的行数</span></span><br><span class="line">    labelCounts = &#123;&#125;  <span class="comment"># 保存每个标签(Label)出现次数的字典</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]  <span class="comment"># 提取标签(Label)信息</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():  <span class="comment"># 如果标签(Label)没有放入统计次数的字典,添加进去</span></span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment"># Label计数</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵(香农熵)</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:  <span class="comment"># 计算香农熵</span></span><br><span class="line">        prob = float(labelCounts[key]) / numEntires  <span class="comment"># 选择该标签(Label)的概率</span></span><br><span class="line">        shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># 利用公式计算</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt  <span class="comment"># 返回经验熵(香农熵)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dataSet, features = createDataSet()</span><br><span class="line">    print(dataSet)</span><br><span class="line">    print(calcShannonEnt(dataSet))</span><br></pre></td></tr></table></figure><p>代码运行结果如下图所示，代码是先打印训练数据集，然后打印计算的经验熵H(D)，程序计算的结果与我们统计计算的结果是一致的，程序没有问题。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_8.jpg?q-sign-algorithm=sha1&amp;q-ak=AKID7xfLaZY0Sf90r7bU4ZIQQPFld0ShPaLj&amp;q-sign-time=1542618680;1542620480&amp;q-key-time=1542618680;1542620480&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=796c7027aa9403cc50084ae1b420bef12fcefca8&amp;x-cos-security-token=c71fa4695aae6d64d7ba3551fe73072e003d9af210001" alt=""></div></p><p><strong>3)信息增益</strong></p><p>在上面，我们已经说过，如何选择特征，需要看信息增益。也就是说，信息增益是相对于特征而言的，信息增益越大，特征对最终的分类结果影响也就越大，我们就应该选择对最终分类结果影响最大的那个特征作为我们的分类特征。</p><p>在讲解信息增益定义之前，我们还需要明确一个概念，条件熵。</p><p>熵我们知道是什么，条件熵又是个什么鬼？条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，随机变量X给定的条件下随机变量Y的条件熵(conditional entropy)H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望：<br>$$H(Y|X) = -\sum_{i=1}^{n} p_i H(Y|X=x_i) \qquad$$</p><p>这里，<br>$$p_i = P(X = x_i),i = 1, 2,…,n$$</p><p>同理，当条件熵中的概率由数据估计(特别是极大似然估计)得到时，所对应的条件熵称为条件经验熵(empirical conditional entropy)。</p><p>明确了条件熵和经验条件熵的概念。接下来，让我们说说信息增益。前面也提到了，信息增益是相对于特征而言的。所以，特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即：<br>$$g (D,A) = H(D) - H(D|A)$$</p><p>一般地，熵H(D)与条件熵H(D|A)之差称为互信息(mutual information)。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p><p>设特征A有n个不同的取值{a1,a2,···,an}，根据特征A的取值将D划分为n个子集{D1,D2，···,Dn}，|Di|为Di的样本个数。记子集Di中属于Ck的样本的集合为Dik，即Dik = Di ∩ Ck，|Dik|为Dik的样本个数。于是经验条件熵的公式可以些为：<br>$$H(D|A) = \sum_{i=1}^{n} \frac {|D_i|}{|D|}H(D_i) = -\sum_{i=1}^{n} \frac {|D_i|}{|D|}\sum_{k=1}^{K} \frac {|D_{ik}|}{|D_i|} \log_2 \frac {|D_{ik}|}{|D_i|}$$</p><p>说了这么多概念性的东西，没有听懂也没有关系，举几个例子，再回来看一下概念，就懂了。</p><p>以贷款申请样本数据表为例进行说明。看下年龄这一列的数据，也就是特征A1，一共有三个类别，分别是：青年、中年和老年。我们只看年龄是青年的数据，年龄是青年的数据一共有5个，所以年龄是青年的数据在训练数据集出现的概率是十五分之五，也就是三分之一。同理，年龄是中年和老年的数据在训练数据集出现的概率也都是三分之一。现在我们只看年龄是青年的数据的最终得到贷款的概率为五分之二，因为在五个数据中，只有两个数据显示拿到了最终的贷款，同理，年龄是中年和老年的数据最终得到贷款的概率分别为五分之三、五分之四。所以计算年龄的信息增益，过程如下：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_13.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDdNqb8A6wqNlwt72O0cx4OIBpRKBDy6Z8&amp;q-sign-time=1542619737;1542621537&amp;q-key-time=1542619737;1542621537&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=d5bf3b836adeb09ab318fd15052dbe8bc07e534a&amp;x-cos-security-token=bfa078927345c660cac46791c51c6ec6410cacff10001" alt=""></div></p><p>同理，计算其余特征的信息增益g(D,A2)、g(D,A3)和g(D,A4)。分别为：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_14_m.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDSl7ywpwES4SEZ18ilCEH0T3bgKFszgXz&amp;q-sign-time=1542619793;1542621593&amp;q-key-time=1542619793;1542621593&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=9c306ce1b2af835bef3aa8cd67e1eb8e67a73ad3&amp;x-cos-security-token=7f741e6a28643d82f9a0cd1483c9474d1efe97c310001" alt=""></div></p><p>最后，比较特征的信息增益，由于特征A3(有自己的房子)的信息增益值最大，所以选择A3作为最优特征。</p><p><strong>4) 编写代码计算信息增益</strong></p><p>我们已经学会了通过公式计算信息增益，接下来编写代码，计算信息增益。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:计算给定数据集的经验熵(香农熵)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    shannonEnt - 经验熵(香农熵)</span></span><br><span class="line"><span class="string">Author:</span></span><br><span class="line"><span class="string">    xhjiang</span></span><br><span class="line"><span class="string">Modify:</span></span><br><span class="line"><span class="string">    2018-11-19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numEntires = len(dataSet)  <span class="comment"># 返回数据集的行数</span></span><br><span class="line">    labelCounts = &#123;&#125;  <span class="comment"># 保存每个标签(Label)出现次数的字典</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]  <span class="comment"># 提取标签(Label)信息</span></span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():  <span class="comment"># 如果标签(Label)没有放入统计次数的字典,添加进去</span></span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span>  <span class="comment"># Label计数</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span>  <span class="comment"># 经验熵(香农熵)</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:  <span class="comment"># 计算香农熵</span></span><br><span class="line">        prob = float(labelCounts[key]) / numEntires  <span class="comment"># 选择该标签(Label)的概率</span></span><br><span class="line">        shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># 利用公式计算</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt  <span class="comment"># 返回经验熵(香农熵)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:创建测试数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">    labels - 分类属性</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],  <span class="comment"># 数据集</span></span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'不放贷'</span>, <span class="string">'放贷'</span>]  <span class="comment"># 分类属性</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels  <span class="comment"># 返回数据集和分类属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:按照给定特征划分数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 待划分的数据集</span></span><br><span class="line"><span class="string">    axis - 划分数据集的特征</span></span><br><span class="line"><span class="string">    value - 需要返回的特征的值</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    无</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    retDataSet = []  <span class="comment"># 创建返回的数据集列表</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 遍历数据集</span></span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]  <span class="comment"># 去掉axis特征</span></span><br><span class="line">            reducedFeatVec.extend(featVec[axis + <span class="number">1</span>:])  <span class="comment"># 将符合条件的添加到返回的数据集</span></span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet  <span class="comment"># 返回划分后的数据集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">函数说明:选择最优特征</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameters:</span></span><br><span class="line"><span class="string">    dataSet - 数据集</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    bestFeature - 信息增益最大的(最优)特征的索引值</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 特征数量</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)  <span class="comment"># 计算数据集的香农熵</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span>  <span class="comment"># 信息增益</span></span><br><span class="line">    bestFeature = <span class="number">-1</span>  <span class="comment"># 最优特征的索引值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):  <span class="comment"># 遍历所有特征</span></span><br><span class="line">        <span class="comment"># 获取dataSet的第i个所有特征</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        uniqueVals = set(featList)  <span class="comment"># 创建set集合&#123;&#125;,元素不可重复</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span>  <span class="comment"># 经验条件熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:  <span class="comment"># 计算信息增益</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)  <span class="comment"># subDataSet划分后的子集</span></span><br><span class="line">            prob = len(subDataSet) / float(len(dataSet))  <span class="comment"># 计算子集的概率</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)  <span class="comment"># 根据公式计算经验条件熵</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy  <span class="comment"># 信息增益</span></span><br><span class="line">        print(<span class="string">"第%d个特征的增益为%.3f"</span> % (i, infoGain))  <span class="comment"># 打印每个特征的信息增益</span></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):  <span class="comment"># 计算信息增益</span></span><br><span class="line">            bestInfoGain = infoGain  <span class="comment"># 更新信息增益，找到最大的信息增益</span></span><br><span class="line">            bestFeature = i  <span class="comment"># 记录信息增益最大的特征的索引值</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature  <span class="comment"># 返回信息增益最大的特征的索引值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dataSet, features = createDataSet()</span><br><span class="line">    print(<span class="string">"最优特征索引值:"</span> + str(chooseBestFeatureToSplit(dataSet)))</span><br></pre></td></tr></table></figure><p>splitDataSet函数是用来选择各个特征的子集的，比如选择年龄(第0个特征)的青年(用0代表)的自己，我们可以调用splitDataSet(dataSet,0,0)这样返回的子集就是年龄为青年的5个数据集。chooseBestFeatureToSplit是选择选择最优特征的函数。运行代码结果如下：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-%E5%86%B3%E7%AD%96%E6%A0%91/m_2_17.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDXFJonnnEnE77YzSjHGXnVgA71i3hSz7C&amp;q-sign-time=1542620152;1542621952&amp;q-key-time=1542620152;1542621952&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=72e63ad8f9caf9c1aaded1fc2c462ac8a7d5c4b5&amp;x-cos-security-token=08d3672a0cc604a03b6686b7b2ebd4dc9c6dca9c10001" alt=""></div></p><p>对比我们自己计算的结果，发现结果完全正确！最优特征的索引值为2，也就是特征A3(有自己的房子)。</p><h2 id="决策树生成和修剪"><a href="#决策树生成和修剪" class="headerlink" title="决策树生成和修剪"></a>决策树生成和修剪</h2><p>我们已经学习了从数据集构造决策树算法所需要的子功能模块，包括经验熵的计算和最优特征的选择，其工作原理如下：得到原始数据集，然后基于最好的属性值划分数据集，由于特征值可能多于两个，因此可能存在大于两个分支的数据集划分。第一次划分之后，数据集被向下传递到树的分支的下一个结点。在这个结点上，我们可以再次划分数据。因此我们可以采用递归的原则处理数据集。</p><p>构建决策树的算法有很多，比如<strong>C4.5、ID3和CART</strong>，这些算法在运行时并不总是在每次划分数据分组时都会消耗特征。由于特征数目并不是每次划分数据分组时都减少，因此这些算法在实际使用时可能引起一定的问题。目前我们并不需要考虑这个问题，只需要在算法开始运行前计算列的数目，查看算法是否使用了所有属性即可。</p><p>决策树生成算法递归地产生决策树，直到不能继续下去未为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲解了如何计算数据集的经验熵和如何选择最优特征作为分类特征。决策树如何生成、修剪、可视化，以及整体实例练习，会在后续的文章中进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习-决策树原理及实战-一&quot;&gt;&lt;a href=&quot;#机器学习-决策树原理及实战-一&quot; class=&quot;headerlink&quot; title=&quot;机器学习-决策树原理及实战(一)&quot;&gt;&lt;/a&gt;机器学习-决策树原理及实战(一)&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;决策树&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="https://xhjiang.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://xhjiang.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-111.Minimum Depth of Binary Tree</title>
    <link href="https://xhjiang.tech/2018/11/19/leetcode%E5%88%B7%E9%A2%98-Minimum-Depth-of-Binary-Tree/"/>
    <id>https://xhjiang.tech/2018/11/19/leetcode刷题-Minimum-Depth-of-Binary-Tree/</id>
    <published>2018-11-19T07:44:56.000Z</published>
    <updated>2018-11-20T07:19:58.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度"><a href="#111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度" class="headerlink" title="111. Minimum Depth of Binary Tree-二叉树的最小深度"></a>111. Minimum Depth of Binary Tree-二叉树的最小深度</h1><hr><p><strong>描述：</strong><br>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回它的最小深度  2.</p><hr><p>递归方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//时间复杂度O(n),空间复杂度O(log(n))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(<span class="keyword">const</span> TreeNode *root, <span class="keyword">bool</span> hasbrother)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> hasbrother ? INT_MAX : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(minDepth(root-&gt;left, root-&gt;right != <span class="literal">NULL</span>),</span><br><span class="line">                       minDepth(root-&gt;right, root-&gt;left != <span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度&quot;&gt;&lt;a href=&quot;#111-Minimum-Depth-of-Binary-Tree-二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;111. Minim
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-136.Single Number</title>
    <link href="https://xhjiang.tech/2018/11/19/leetcode%E5%88%B7%E9%A2%98-Single-Number/"/>
    <id>https://xhjiang.tech/2018/11/19/leetcode刷题-Single-Number/</id>
    <published>2018-11-19T06:33:55.000Z</published>
    <updated>2018-11-20T07:21:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="136-Single-Number-只出现过一次的数字"><a href="#136-Single-Number-只出现过一次的数字" class="headerlink" title="136. Single Number-只出现过一次的数字"></a>136. Single Number-只出现过一次的数字</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><blockquote><p><em>说明：</em><br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p></blockquote><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>题中要求，线性时间复杂度，而且不使用额外空间，那么就要从数组本身入手，同时只循环扫描一遍数组</p><p>我们可以考虑 异或运算 ，它是满足交换律和结合的，也就是说 a ^ b  ^c = a ^ c ^ b，这样当我们遍历数组，顺次进行异或运算，那么最终的结果就是唯一的不重复数字。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[4,1,2,1,2]，</span><br><span class="line">4^1^2^1^2 = 1^1^2^2^4 = 0^0^4=4</span><br></pre></td></tr></table></figure></p><p><strong>代码一：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//顺次异或，每当某个数字重复出现偶次都会被消除为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            x ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int singleNumber(int A[], int n) &#123;</span></span><br><span class="line"><span class="comment">//         int result = 0;</span></span><br><span class="line"><span class="comment">//         for(int i = 0;i &lt; n;i++)&#123;</span></span><br><span class="line"><span class="comment">//             result = result ^ A[i];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return result;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><p><strong>代码二：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//accumulate()函数用来求和，初始值为0，范围从begin到end的所有向量以位异或的方式求和</span></span><br><span class="line">        <span class="keyword">return</span> accumulate(nums.begin(), nums.end(), <span class="number">0</span>, bit_xor&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;136-Single-Number-只出现过一次的数字&quot;&gt;&lt;a href=&quot;#136-Single-Number-只出现过一次的数字&quot; class=&quot;headerlink&quot; title=&quot;136. Single Number-只出现过一次的数字&quot;&gt;&lt;/a&gt;136.
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-104.Maximum Depth of Binary Tree</title>
    <link href="https://xhjiang.tech/2018/11/17/leetcode%E5%88%B7%E9%A2%98-Maximum-Depth-of-Binary-Tree/"/>
    <id>https://xhjiang.tech/2018/11/17/leetcode刷题-Maximum-Depth-of-Binary-Tree/</id>
    <published>2018-11-17T05:56:48.000Z</published>
    <updated>2018-11-20T07:19:28.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度"><a href="#104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度" class="headerlink" title="104. Maximum Depth of Binary Tree-二叉树的最大深度"></a>104. Maximum Depth of Binary Tree-二叉树的最大深度</h1><hr><h2 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong>利用递归直接求解</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//若树为空则返回0</span></span><br><span class="line">        <span class="comment">//最后返回根节点的左右子树中深度较大的那个深度，最后加上根节点的深度</span></span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left),maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度&quot;&gt;&lt;a href=&quot;#104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;104. Maxim
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>华为机试-2.计算字符个数</title>
    <link href="https://xhjiang.tech/2018/11/17/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95-2-%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0/"/>
    <id>https://xhjiang.tech/2018/11/17/华为机试-2-计算字符个数/</id>
    <published>2018-11-17T05:23:18.000Z</published>
    <updated>2018-11-20T07:18:34.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-计算字符个数"><a href="#2-计算字符个数" class="headerlink" title="2.计算字符个数"></a>2.计算字符个数</h1><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</p><p>输入描述:<br>输入一个有字母和数字以及空格组成的字符串，和一个字符。</p><p>输出描述:<br>输出输入字符串中含有该字符的个数。</p><p><strong>示例1</strong><br>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEF A</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p><hr><p>思路：<br>第一反应就是可以把所有的字母输入都转为小写字母，或者所有的字母输入都转换为大写字母，简单直接，可能执行效率不是最好的，但是算法的思路挺简单的，两个循环就可以搞定，那么怎么实现这个字母转换呢。</p><p>这里我提供两种方法：</p><p>方法一就是判断所有的字母是否为A到Z之间的，如果是就直接加上’a’-‘A’，其实就是加上32，使其转换为大写字母，因为我们都知道小写字母的ASCII值比大写字母的大32。如程序中方法一所示的代码。</p><p>方法二直接使用string函数库中的处理函数tolower()函数直接处理，简单直接，如代码中的方法二的注释。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">char</span> p;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    getline(<span class="built_in">cin</span>,str); <span class="comment">//输入字符串，包括空格，遇到换行符即停止输入</span></span><br><span class="line">    p = <span class="built_in">cin</span>.get(); <span class="comment">//输入字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; str.length();++i)&#123;</span><br><span class="line">        <span class="comment">//方法二，把字符串所有字母都转换成小写字母</span></span><br><span class="line">        <span class="comment">//str[i] = tolower(str[i]); </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一，把所有小写字母都换成大写字母，同时判断字符是否为小写字母，如果是则换成大写字母</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] &gt;= <span class="string">'a'</span> &amp;&amp; str[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">            str[i] -= <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= <span class="string">'a'</span> &amp;&amp; p &lt;= <span class="string">'z'</span>)</span><br><span class="line">            p -= <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; str.length();++i)&#123;  <span class="comment">//若字符串str中某个字符等于字符p，则count+1，不区分大小写字母</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == p)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-计算字符个数&quot;&gt;&lt;a href=&quot;#2-计算字符个数&quot; class=&quot;headerlink&quot; title=&quot;2.计算字符个数&quot;&gt;&lt;/a&gt;2.计算字符个数&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="华为机试" scheme="https://xhjiang.tech/categories/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="华为机试" scheme="https://xhjiang.tech/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>华为机试-1.字符串最后一个单词的长度</title>
    <link href="https://xhjiang.tech/2018/11/16/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>https://xhjiang.tech/2018/11/16/华为机试-字符串最后一个单词的长度/</id>
    <published>2018-11-16T11:42:54.000Z</published>
    <updated>2018-11-20T07:18:47.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-字符串最后一个单词的长度"><a href="#1-字符串最后一个单词的长度" class="headerlink" title="1. 字符串最后一个单词的长度"></a>1. 字符串最后一个单词的长度</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>计算字符串最后一个单词的长度，单词以空格隔开。<br><strong>输入描述:</strong><br>一行字符串，非空，长度小于5000。</p><p><strong>输出描述:</strong><br>整数N，最后一个单词的长度。</p><p><strong>示例1: </strong><br>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,str))&#123; <span class="comment">//若以cin输入字符串，遇到空格会结束；geiline则能输入整行，遇到换行符结束</span></span><br><span class="line">        str.erase(<span class="number">0</span>,str.find_first_not_of(<span class="string">" "</span>));<span class="comment">//这两行作用是去除首尾空格</span></span><br><span class="line">        str.erase(str.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">auto</span> iter1 = str.find_last_of(<span class="string">' '</span>);<span class="comment">//原来这类函数返回的是整数或string::npos(表示没有找到匹配值)</span></span><br><span class="line">        <span class="keyword">if</span>(iter1 == <span class="built_in">string</span>::npos)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str.size() - <span class="number">1</span>- iter1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-字符串最后一个单词的长度&quot;&gt;&lt;a href=&quot;#1-字符串最后一个单词的长度&quot; class=&quot;headerlink&quot; title=&quot;1. 字符串最后一个单词的长度&quot;&gt;&lt;/a&gt;1. 字符串最后一个单词的长度&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;描述：&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="华为机试" scheme="https://xhjiang.tech/categories/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="华为机试" scheme="https://xhjiang.tech/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-53.Maximum Subarray</title>
    <link href="https://xhjiang.tech/2018/11/16/leetcode%E5%88%B7%E9%A2%98-Maximum-Subarray/"/>
    <id>https://xhjiang.tech/2018/11/16/leetcode刷题-Maximum-Subarray/</id>
    <published>2018-11-16T11:42:14.000Z</published>
    <updated>2018-11-20T07:19:43.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-Maximum-Subarray-最大子序和"><a href="#53-Maximum-Subarray-最大子序和" class="headerlink" title="53. Maximum Subarray-最大子序和"></a>53. Maximum Subarray-最大子序和</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></p><blockquote><p><em>进阶:</em><br>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p></blockquote><hr><ul><li>解法一：动态规划</li></ul><p><strong>思路：</strong><br>当我们从头到尾遍历这个数组时，对于数组里的一个整数，他有几种选择呢？它只有两种选择：</p><ol><li>加入之前的SubArray;</li><li>自己另起一个SubArray。那什么时候会出现这两种情况呢？</li></ol><p>如果之前SubArray的总体之和大于0的话，那么就认为它对后续结果是有贡献的,这种情况下我们选择加入之前的SubArray;</p><p>如果之前SubArray的总体之和小于等于0的话，那么就认为它对后续结果是没有贡献的,甚至是有害的（小于0时），这种情况下我们选择以这个数字开始另起一个SubArray;</p><p>设状态为f[j]，表示以S[j]结尾的最大l连续子序列和，则状态转移方程如下：<br>$$f[j] = max{f[j-1] + S[j],S[j]},其中 1 \leq j \le n$$ </p><p>$$target = max{f[j]} , 其中 1 \leq j \le n $$</p><p>解释如下：</p><ul><li>情况一：S[j]不独立，与前面的某些数组成一个连续子序列，则最大连续子序列和为f[j-1]+S[j]</li><li>情况二：S[j]独立划分成一段,即连续子序列仅包含一个数S[j]，则最大连续子序列和为S[j]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">          f = max(f + nums[i], nums[i]);</span><br><span class="line">           result = max(result, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;53-Maximum-Subarray-最大子序和&quot;&gt;&lt;a href=&quot;#53-Maximum-Subarray-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;53. Maximum Subarray-最大子序和&quot;&gt;&lt;/a&gt;53. Maximu
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-21.Merge Two Sorted Lists</title>
    <link href="https://xhjiang.tech/2018/11/15/leetcode%E5%88%B7%E9%A2%98-Merge-Two-Sorted-Lists/"/>
    <id>https://xhjiang.tech/2018/11/15/leetcode刷题-Merge-Two-Sorted-Lists/</id>
    <published>2018-11-15T07:25:32.000Z</published>
    <updated>2018-11-20T07:19:50.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="21-Merge-Two-Sorted-Lists-合并两个有序链表"><a href="#21-Merge-Two-Sorted-Lists-合并两个有序链表" class="headerlink" title="21. Merge Two Sorted Lists-合并两个有序链表"></a>21. Merge Two Sorted Lists-合并两个有序链表</h1><hr><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><hr><ul><li>解法一:非递归版</li></ul><blockquote><p>思路：<br>新建一个链表用来存储新的有序链表，可以先让两个链表互相比较，新链表的指针指向更小的那个，依次遍历直到一方遍历结束，最后把剩下的那个链表的剩余部分连接到新链表的表尾</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//时间复杂度O(max(m,n)),空间复杂度O(m+n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *t1 = l1;</span><br><span class="line">        ListNode *t2 = l2;</span><br><span class="line">        ListNode *newlist = <span class="keyword">new</span> ListNode(<span class="number">0</span>);    <span class="comment">//新建一个链表用来存储</span></span><br><span class="line">        ListNode *nl = newlist;    <span class="comment">//让指针nl指向新链表，最后返回nl</span></span><br><span class="line">        <span class="comment">//两个链表相互比较大小，新链表指针指向更小的值</span></span><br><span class="line">        <span class="keyword">while</span>(t1 != <span class="literal">nullptr</span> &amp;&amp; t2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val &gt; t2-&gt;val)&#123;</span><br><span class="line">                newlist-&gt;next = t2;</span><br><span class="line">                newlist = newlist-&gt;next;    <span class="comment">//得到一个更小的值后指针后移</span></span><br><span class="line">                t2 = t2-&gt;next;      <span class="comment">//指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                newlist-&gt;next = t1;</span><br><span class="line">                newlist = newlist-&gt;next;</span><br><span class="line">                t1 = t1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把当只剩下一个链表时，把链表剩余部分连接到新链表表尾</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">nullptr</span> &amp;&amp; t2 != <span class="literal">nullptr</span>)</span><br><span class="line">            newlist-&gt;next = t2;     </span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="literal">nullptr</span> &amp;&amp; t1 != <span class="literal">nullptr</span>)</span><br><span class="line">            newlist-&gt;next = t1;</span><br><span class="line">        <span class="keyword">return</span> nl-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;21-Merge-Two-Sorted-Lists-合并两个有序链表&quot;&gt;&lt;a href=&quot;#21-Merge-Two-Sorted-Lists-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21. Merge Two Sorted Lis
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-66.Plus One</title>
    <link href="https://xhjiang.tech/2018/11/14/leetcode%E5%88%B7%E9%A2%98-Plus-One/"/>
    <id>https://xhjiang.tech/2018/11/14/leetcode刷题-Plus-One/</id>
    <published>2018-11-14T08:52:38.000Z</published>
    <updated>2018-11-20T08:49:23.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="66-Plus-One-加一"><a href="#66-Plus-One-加一" class="headerlink" title="66. Plus One-加一"></a>66. Plus One-加一</h1><hr><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><blockquote><p>高精度加法</p></blockquote><ul><li>解法一：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;</span><br><span class="line">        add(digits, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 0 &lt;= digit &lt;= 9</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = digit; <span class="comment">// carry, 进位</span></span><br><span class="line">        <span class="comment">// for_each(digits.rbegin(), digits.rend(), [&amp;c](int &amp;d)&#123;</span></span><br><span class="line">        <span class="comment">//     d += c;</span></span><br><span class="line">        <span class="comment">//     c = d / 10;</span></span><br><span class="line">        <span class="comment">//     d %= 10;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = digits.rbegin(); it != digits.rend(); ++it)&#123;</span><br><span class="line">            *it += c;</span><br><span class="line">            c = *it / <span class="number">10</span>;</span><br><span class="line">            *it %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) </span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素<br>c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置<br>对于反向迭代器，++ 运算将访问前一个元素，而 – 运算则访问下一个元素</p></blockquote><ul><li>解法二：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;</span><br><span class="line">        add(digits, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 0 &lt;= digit &lt;= 9</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = digit; <span class="comment">// carry, 进位</span></span><br><span class="line">        for_each(digits.rbegin(), digits.rend(), [&amp;c](<span class="keyword">int</span> &amp;d)&#123;</span><br><span class="line">            d += c;</span><br><span class="line">            c = d / <span class="number">10</span>;</span><br><span class="line">            d %= <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) </span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>这个解法没看明白……</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;66-Plus-One-加一&quot;&gt;&lt;a href=&quot;#66-Plus-One-加一&quot; class=&quot;headerlink&quot; title=&quot;66. Plus One-加一&quot;&gt;&lt;/a&gt;66. Plus One-加一&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;描述&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-100.Same Tree</title>
    <link href="https://xhjiang.tech/2018/11/14/leetcode%E5%88%B7%E9%A2%98-Same-Tree/"/>
    <id>https://xhjiang.tech/2018/11/14/leetcode刷题-Same-Tree/</id>
    <published>2018-11-14T06:58:20.000Z</published>
    <updated>2018-11-20T07:20:55.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="100-Same-Tree-相同的树"><a href="#100-Same-Tree-相同的树" class="headerlink" title="100. Same Tree-相同的树"></a>100. Same Tree-相同的树</h1><hr><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h1 id="递归版："><a href="#递归版：" class="headerlink" title="递归版："></a>递归版：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//递归版，时间复杂度O(n),空间复杂度O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val     <span class="comment">//三方合并</span></span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) </span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代版："><a href="#迭代版：" class="headerlink" title="迭代版："></a>迭代版：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(p);</span><br><span class="line">        s.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            p = s.top(); s.pop();</span><br><span class="line">            q = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(p-&gt;left);</span><br><span class="line">            s.push(q-&gt;left);</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">            s.push(q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;100-Same-Tree-相同的树&quot;&gt;&lt;a href=&quot;#100-Same-Tree-相同的树&quot; class=&quot;headerlink&quot; title=&quot;100. Same Tree-相同的树&quot;&gt;&lt;/a&gt;100. Same Tree-相同的树&lt;/h1&gt;&lt;hr&gt;
&lt;p
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
