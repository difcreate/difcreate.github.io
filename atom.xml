<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>difcreate&#39;s blog</title>
  
  <subtitle>偷得浮生半日闲</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xhjiang.tech/"/>
  <updated>2018-11-14T09:14:58.893Z</updated>
  <id>https://xhjiang.tech/</id>
  
  <author>
    <name>difcreate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode刷题-Plus One</title>
    <link href="https://xhjiang.tech/2018/11/14/leetcode%E5%88%B7%E9%A2%98-Plus-One/"/>
    <id>https://xhjiang.tech/2018/11/14/leetcode刷题-Plus-One/</id>
    <published>2018-11-14T08:52:38.000Z</published>
    <updated>2018-11-14T09:14:58.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="66-Plus-One-加一"><a href="#66-Plus-One-加一" class="headerlink" title="66. Plus One-加一"></a>66. Plus One-加一</h1><hr><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><blockquote><p>高精度加法</p></blockquote><ul><li>解法一：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;</span><br><span class="line">        add(digits, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 0 &lt;= digit &lt;= 9</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = digit; <span class="comment">// carry, 进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = digits.rbegin(); it != digits.rend(); ++it)&#123;</span><br><span class="line">            *it += c;</span><br><span class="line">            c = *it / <span class="number">10</span>;</span><br><span class="line">            *it %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="comment">//如果最前一位是9+1需要进位的话，那就在最前面的位置插入1</span></span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素<br>c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置<br>对于反向迭代器，++ 运算将访问前一个元素，而 – 运算则访问下一个元素</p></blockquote><ul><li>解法二：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;</span><br><span class="line">        add(digits, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 0 &lt;= digit &lt;= 9</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = digit; <span class="comment">// carry, 进位</span></span><br><span class="line">        for_each(digits.rbegin(), digits.rend(), [&amp;c](<span class="keyword">int</span> &amp;d)&#123;</span><br><span class="line">            d += c;</span><br><span class="line">            c = d / <span class="number">10</span>;</span><br><span class="line">            d %= <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) </span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>这个解法没看明白……</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;66-Plus-One-加一&quot;&gt;&lt;a href=&quot;#66-Plus-One-加一&quot; class=&quot;headerlink&quot; title=&quot;66. Plus One-加一&quot;&gt;&lt;/a&gt;66. Plus One-加一&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;描述&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/C/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-Same Tree</title>
    <link href="https://xhjiang.tech/2018/11/14/leetcode%E5%88%B7%E9%A2%98-Same-Tree/"/>
    <id>https://xhjiang.tech/2018/11/14/leetcode刷题-Same-Tree/</id>
    <published>2018-11-14T06:58:20.000Z</published>
    <updated>2018-11-14T08:08:14.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="100-Same-Tree-相同的树"><a href="#100-Same-Tree-相同的树" class="headerlink" title="100. Same Tree-相同的树"></a>100. Same Tree-相同的树</h1><hr><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h1 id="递归版："><a href="#递归版：" class="headerlink" title="递归版："></a>递归版：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//递归版，时间复杂度O(n),空间复杂度O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val     <span class="comment">//三方合并</span></span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) </span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代版："><a href="#迭代版：" class="headerlink" title="迭代版："></a>迭代版：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(p);</span><br><span class="line">        s.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            p = s.top(); s.pop();</span><br><span class="line">            q = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(p-&gt;left);</span><br><span class="line">            s.push(q-&gt;left);</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">            s.push(q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;100-Same-Tree-相同的树&quot;&gt;&lt;a href=&quot;#100-Same-Tree-相同的树&quot; class=&quot;headerlink&quot; title=&quot;100. Same Tree-相同的树&quot;&gt;&lt;/a&gt;100. Same Tree-相同的树&lt;/h1&gt;&lt;hr&gt;
&lt;p
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/C/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习-mnist手写数字tensorflow实现</title>
    <link href="https://xhjiang.tech/2018/11/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97tensorflow%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xhjiang.tech/2018/11/14/深度学习-mnist手写数字tensorflow实现/</id>
    <published>2018-11-14T03:01:58.000Z</published>
    <updated>2018-11-14T05:36:41.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习实战（一）：手写数字识别"><a href="#深度学习实战（一）：手写数字识别" class="headerlink" title="深度学习实战（一）：手写数字识别"></a>深度学习实战（一）：手写数字识别</h1><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>为了更好的理解Neural Network，本文使用Tensorflow实现一个最简单的神经网络，然后使用MNIST数据集进行测试。同时使用Tensorboard对训练过程进行可视化。</p><hr><h1 id="2-MNIST数据集简介"><a href="#2-MNIST数据集简介" class="headerlink" title="2. MNIST数据集简介"></a>2. MNIST数据集简介</h1><p>当我们学习新的编程语言时，通常第一个程序就是打印输出著名的“Hello World!”。在深度学习中，MNIST数据集就相当于Hello World。</p><p><strong>数据集：</strong><br>train-images-idx3-ubyte 训练数据图像 (60,000)<br>train-labels-idx1-ubyte 训练数据label<br>t10k-images-idx3-ubyte 测试数据图像 (10,000)<br>t10k-labels-idx1-ubyte 测试数据label</p><blockquote><p>我们的任务是使用上面数据训练一个可以准确识别手写数字的神经网络模型，并使用Tensorflow对训练过程各个参数的变化进行可视化。</p></blockquote><hr><h1 id="3-Tensorboard简介"><a href="#3-Tensorboard简介" class="headerlink" title="3. Tensorboard简介"></a>3. Tensorboard简介</h1><p>本文要使用到Tensorboard，先让我们看看它究竟是用来干什么的。</p><p>当使用Tensorflow训练大量深层的神经网络时，我们希望去跟踪神经网络的整个训练过程中的信息，比如迭代的过程中每一层参数是如何变化与分布的，比如每次循环参数更新后模型在测试集与训练集上的准确率是如何的，比如损失值的变化情况，等等。如果能在训练的过程中将一些信息加以记录并可视化得表现出来，是不是对我们探索模型有更深的帮助与理解呢？</p><p>Tensorflow官方推出了可视化工具Tensorboard，可以帮助我们实现以上功能，它可以将模型训练过程中的各种数据汇总起来存在自定义的路径与日志文件中，然后在指定的web端可视化地展现这些信息。</p><h2 id="3-1-Tensorboard的数据形式："><a href="#3-1-Tensorboard的数据形式：" class="headerlink" title="3.1 Tensorboard的数据形式："></a>3.1 Tensorboard的数据形式：</h2><p>Tensorboard可以记录与展示以下数据形式：</p><p>（1）标量Scalars</p><p>（2）图片Images</p><p>（3）音频Audio</p><p>（4）计算图Graph</p><p>（5）数据分布Distribution</p><p>（6）直方图Histograms</p><p>（7）嵌入向量Embeddings</p><h2 id="3-2-Tensorboard的可视化过程："><a href="#3-2-Tensorboard的可视化过程：" class="headerlink" title="3.2 Tensorboard的可视化过程："></a>3.2 Tensorboard的可视化过程：</h2><p>（1）首先肯定是先建立一个graph,你想从这个graph中获取某些数据的信息</p><p>（2）确定要在graph中的哪些节点放置summary operations以记录信息</p><p>使用tf.summary.scalar记录标量</p><p>使用tf.summary.histogram记录数据的直方图</p><p>使用tf.summary.distribution记录数据的分布图</p><p>使用tf.summary.image记录图像数据</p><p>…..等等</p><p>（3）operations并不会去真的执行计算，除非你告诉他们需要去run,或者它被其他的需要run的operation所依赖。而我们上一步创建的这些summary operations其实并不被其他节点依赖，因此，我们需要特地去运行所有的summary节点。但是呢，一份程序下来可能有超多这样的summary 节点，要手动一个一个去启动自然是极其繁琐的，因此我们可以使用tf.summary.merge_all去将所有summary节点合并成一个节点，只要运行这个节点，就能产生所有我们之前设置的summary data。</p><p>（4）使用tf.summary.FileWriter将运行后输出的数据都保存到本地磁盘中</p><p>（5）运行整个程序，并在命令行输入运行tensorboard的指令，之后打开web端可查看可视化的结果</p><p>考虑多类情况。非onehot，标签是类似0 1 2 3…n这样。而onehot标签则是顾名思义，一个长度为n的数组，只有一个元素是1.0，其他元素是0.0。例如在n为4的情况下，标签2对应的onehot标签就是 0.0 0.0 1.0 0.0使用onehot的直接原因是现在多分类cnn网络的输出通常是softmax层，而它的输出是一个概率分布，从而要求输入的标签也以概率分布的形式出现，进而算交叉熵之类。</p><hr><h1 id="4-手写数字识别"><a href="#4-手写数字识别" class="headerlink" title="4. 手写数字识别"></a>4. 手写数字识别</h1><p>现在，我们使用最基础的手写数字识别。</p><h2 id="4-1-准备数据集、定义超参数等准备工作"><a href="#4-1-准备数据集、定义超参数等准备工作" class="headerlink" title="4.1 准备数据集、定义超参数等准备工作"></a>4.1 准备数据集、定义超参数等准备工作</h2><p>1）首先是导入需要使用的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入使用的包</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><p>2）定义超参数</p><p>如果你问，这个超参数为啥要这样设定，如何选择最优的超参数？这个问题此处先不讨论，超参数的选择在机器学习建模中最常用的方法就是“交叉验证法”。而现在假设我们已经获得了最优的超参数，设置学利率为0.001，dropout的保留节点比例为0.9，最大循环次数为1000。</p><p>另外，还要设置两个路径，第一个是数据下载下来存放的地方，一个是summary输出保存的地方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">max_steps = <span class="number">1000</span>  <span class="comment"># 最大迭代数</span></span><br><span class="line">learning_rate = <span class="number">0.001</span>  <span class="comment"># 学习率</span></span><br><span class="line">dropout = <span class="number">0.9</span>  <span class="comment"># dropout时随机保留神经元的比例</span></span><br><span class="line">data_dir = <span class="string">'./MNIST_DATA'</span>  <span class="comment"># 样本数据存储的路径</span></span><br><span class="line">log_dir = <span class="string">'./MNIST_LOG'</span>    <span class="comment"># 输出日志保存的路径</span></span><br></pre></td></tr></table></figure><p>3）GPU设置</p><p>这里使用GPU进行训练，如果使用cpu，可以略过此步。如果使用GPU建议进行设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU设置</span></span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"0"</span></span><br><span class="line">config = tf.ConfigProto(allow_soft_placement=<span class="keyword">True</span>)</span><br><span class="line">gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=<span class="number">0.99</span>)</span><br><span class="line">config.gpu_options.allow_growth = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><blockquote><p><em>Tips：</em><br>上述代码的意思是使用GPU设备0，最多给GPU分配总共内存的百分之33，并且允许GPU按需申请内存。也就是说，假设一个程序使用一块GPU内存百分之10就够了，如果我们没有指定allow_growth=True，那么程序会直接占用GPU内存的百分之33，因为这个是我们给它分配的。如果我们连0.33，也就是GPU内存的百分之33都没有指定，那么程序会直接占用整个GPU设备0。虽然占用这么多没有用，但是我就占着，属于“占着茅坑不拉屎”。所以，为了充分利用资源，特别是一帮人使用一个服务器的时候，指定下这些参数就很有必要了。</p></blockquote><p>4）下载数据下载数据是直接调用了tensorflow提供的函数<strong>read_data_sets</strong>，输入两个参数，第一个是下载到数据存储的路径，第二个one_hot表示是否要将类别标签进行独热编码。它首先回去找制定目录下有没有这个数据文件，没有的话才去下载，有的话就直接读取。所以第一次执行这个命令，速度会比较慢，因为没有数据集，需要进行下载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据集，并采用one_hot独热编码</span></span><br><span class="line">mnist = input_data.read_data_sets(data_dir, one_hot=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h2 id="4-2-数据处理"><a href="#4-2-数据处理" class="headerlink" title="4.2 数据处理"></a>4.2 数据处理</h2><p>1）创建tensorflow默认会话：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建tensorflow默认会话</span></span><br><span class="line">sess = tf.InteractiveSession(config=config)</span><br></pre></td></tr></table></figure></p><blockquote><p><em>Tips:</em><br>为了使设置的GPU参数生效，我们需要在创建会话的时候传入这个config参数。</p></blockquote><p>2）创建输入数据的占位符，分别创建特征数据x，标签数据y_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建输入数据的占位符，分别创建特征数据x，标签数据y_</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'input'</span>):</span><br><span class="line">    x = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">784</span>], name=<span class="string">'x-input'</span>)</span><br><span class="line">    y_ = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">10</span>], name=<span class="string">'y-input'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips：</em><br>在<strong>tf.placeholder()</strong>函数中传入了3个参数，第一个是定义数据类型为float32；第二个是数据的大小，特征数据是大小784的向量，标签数据是大小为10的向量，None表示不定死大小，到时候可以传入任何数量的样本；第3个参数是这个占位符的名称<br><strong>mnist下载好的数据集就是很多个1<em>784的向量，就是已经对28</em>28的图片进行了向量化处理。</strong></p></blockquote><p>3）使用tf.summary.image保存图像信息</p><p>前面也说了，特征数据其实就是图像的像素数据拉升成一个1<em>784的向量，现在如果想在tensorboard上还原出输入的特征数据对应的图片，就需要将拉升的向量转变成28 </em> 28 * 1的原始像素了，于是可以用<strong>tf.reshape()</strong>直接重新调整特征数据的维度：</p><p>将输入的数据转换成[28 <em> 28 </em> 1]的shape，存储成另一个tensor，命名为image_shaped_input。<br>为了能使图片在tensorbord上展示出来，使用<strong>tf.summary.image</strong>将图片数据汇总给tensorbord。<br><strong>tf.summary.image（）</strong>中传入的第一个参数是命名，第二个是图片数据，第三个是最多展示的张数，此处为10张。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用tf.summary.image保存图像信息</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'input_reshape'</span>):</span><br><span class="line">    image_shaped_input = tf.reshape(x, [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">    tf.summary.image(<span class="string">'input'</span>, image_shaped_input, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="4-3-初始化参数并保存参数信息到summary"><a href="#4-3-初始化参数并保存参数信息到summary" class="headerlink" title="4.3 初始化参数并保存参数信息到summary"></a>4.3 初始化参数并保存参数信息到summary</h2><p>1）初始化参数w和b</p><p>在构建神经网络模型中，每一层中都需要去初始化参数w,b,为了使代码简介美观，最好将初始化参数的过程封装成方法function。 创建初始化权重w的方法，生成大小等于传入的shape参数，标准差为0.1，遵循正态分布的随机数，并且将它转换成tensorflow中的variable返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化权重参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.truncated_normal(shape, stddev=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure><p>创建初始换偏执项b的方法，生成大小为传入参数shape的常数0.1，并将其转换成tensorflow的variable并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化偏执参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.constant(<span class="number">0.1</span>, shape=shape)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure><p>2）记录训练过程参数变化</p><p>我们知道，在训练的过程在参数是不断地在改变和优化的，我们往往想知道每次迭代后参数都做了哪些变化，可以将参数的信息展现在tenorbord上，因此我们专门写一个方法来收录每次的参数信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录训练过程参数变化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable_summaries</span><span class="params">(var)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'summaries'</span>):</span><br><span class="line">        <span class="comment"># 计算参数的均值，并使用tf.summary.scalar记录</span></span><br><span class="line">        mean = tf.reduce_mean(var)</span><br><span class="line">        tf.summary.scalar(<span class="string">'mean'</span>, mean)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算参数的标准差</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'stddev'</span>):</span><br><span class="line">            stddev = tf.sqrt(tf.reduce_mean(var - mean))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用tf.summat.scalar记录标准差，最大值，最小值</span></span><br><span class="line">        tf.summary.scalar(<span class="string">'stddev'</span>, stddev)</span><br><span class="line">        tf.summary.scalar(<span class="string">'max'</span>, tf.reduce_max(var))</span><br><span class="line">        tf.summary.scalar(<span class="string">'min'</span>, tf.reduce_min(var))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用直方图记录参数的分布</span></span><br><span class="line">        tf.summary.histogram(<span class="string">'histogram'</span>, var)</span><br></pre></td></tr></table></figure><h2 id="4-4-构建神经网络层"><a href="#4-4-构建神经网络层" class="headerlink" title="4.4 构建神经网络层"></a>4.4 构建神经网络层</h2><p>1）创建第一层隐藏层</p><p>创建一个构建隐藏层的方法,输入的参数有：</p><blockquote><p>input_tensor：特征数据<br>input_dim：输入数据的维度大小<br>output_dim：输出数据的维度大小(=隐层神经元个数）<br>layer_name：命名空间<br>act=tf.nn.relu：激活函数（默认是relu)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建神经网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_layer</span><span class="params">(input_tensor, input_dim, out_dim, layer_name, act=tf.nn.relu)</span>:</span></span><br><span class="line">    <span class="comment"># 设置命名空间</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(layer_name):</span><br><span class="line">        <span class="comment"># 调用之前的方法初始化权重w，并且调用参数信息的记录方法，记录w的信息</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'weights'</span>):</span><br><span class="line">            weights = weight_variable([input_dim, out_dim])</span><br><span class="line">            variable_summaries(weights)</span><br><span class="line">        <span class="comment"># 调用之前的方法初始化权重b，并且调用参数信息的记录方法，记录b的信息</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'biases'</span>):</span><br><span class="line">            biases = bias_variable([out_dim])</span><br><span class="line">            variable_summaries(biases)</span><br><span class="line">        <span class="comment"># 执行wx+b的线性计算，并且用直方图记录下来</span></span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'linear_compute'</span>):</span><br><span class="line">            preactivate = tf.matmul(input_tensor, weights) + biases</span><br><span class="line">            tf.summary.histogram(<span class="string">'linear'</span>, preactivate)</span><br><span class="line">        <span class="comment"># 将线性输出经过激励函数，并将输出也用直方图记录下来</span></span><br><span class="line">        activations = act(preactivate, name=<span class="string">'activations'</span>)</span><br><span class="line">        tf.summary.histogram(<span class="string">'activations'</span>, activations)</span><br><span class="line">    <span class="comment"># 返回激励层的最终输出</span></span><br><span class="line">    <span class="keyword">return</span> activations</span><br></pre></td></tr></table></figure><p>调用隐层创建函数创建一个隐藏层：输入的维度是特征的维度784，隐藏层的神经元个数是500，也就是输出的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个隐藏层</span></span><br><span class="line">hidden1 = nn_layer(x, <span class="number">784</span>, <span class="number">500</span>, <span class="string">'layer1'</span>)</span><br></pre></td></tr></table></figure><p>2）创建一个dropout层</p><p>随机关闭掉hidden1的一些神经元，并记录keep_prob，减少保存参数，防止过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个dropout层</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'dropout'</span>):</span><br><span class="line">    keep_prob = tf.placeholder(tf.float32)</span><br><span class="line">    tf.summary.scalar(<span class="string">'dropout_keep_probability'</span>, keep_prob)</span><br><span class="line">    dropped = tf.nn.dropout(hidden1, keep_prob)</span><br></pre></td></tr></table></figure><p>3）创建一个输出层</p><p>输入的维度是上一层的输出:500,输出的维度是分类的类别种类：10，激活函数设置为全等映射identity。（暂且先别使用softmax，会放在之后的损失函数中一起计算）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个输出层</span></span><br><span class="line">y = nn_layer(dropped, <span class="number">500</span>, <span class="number">10</span>, <span class="string">'layer2'</span>, act=tf.identity)</span><br></pre></td></tr></table></figure><h2 id="4-5-创造损失函数"><a href="#4-5-创造损失函数" class="headerlink" title="4.5 创造损失函数"></a>4.5 创造损失函数</h2><p>使用tf.nn.softmax_cross_entropy_with_logits来计算softmax并计算交叉熵损失,并且求均值作为最终的损失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建损失函数</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'loss'</span>):</span><br><span class="line">    <span class="comment"># 计算交叉熵损失（每个样本都会有一个损失）</span></span><br><span class="line">    diff = tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y)</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'total'</span>):</span><br><span class="line">        <span class="comment"># 计算所有样本交叉熵损失的均值</span></span><br><span class="line">        cross_entropy = tf.reduce_mean(diff)</span><br><span class="line">    tf.summary.scalar(<span class="string">'loss'</span>, cross_entropy)</span><br></pre></td></tr></table></figure><h2 id="4-6-训练"><a href="#4-6-训练" class="headerlink" title="4.6 训练"></a>4.6 训练</h2><p>首先，使用AdamOptimizer优化器训练模型，最小化交叉熵损失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用AdamOptimizer优化器训练模型，最小化交叉熵损失</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'train'</span>):</span><br><span class="line">    train_step = tf.train.AdamOptimizer(learning_rate).minimize(cross_entropy)</span><br></pre></td></tr></table></figure><p>然后，计算准确率,并用tf.summary.scalar记录准确率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'accuracy'</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'correct_prediction'</span>):</span><br><span class="line">        <span class="comment"># 分别将预测和真实的标签中取出最大值的索引，若相同则返回1(true),不同则返回0(false)</span></span><br><span class="line">        correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'accuracy'</span>):</span><br><span class="line">            <span class="comment"># 求均值即为准确率</span></span><br><span class="line">            accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line">tf.summary.scalar(<span class="string">'accuracy'</span>, accuracy)</span><br></pre></td></tr></table></figure><h2 id="4-7-所有变量初始化"><a href="#4-7-所有变量初始化" class="headerlink" title="4.7 所有变量初始化"></a>4.7 所有变量初始化</h2><p>将所有的summaries合并，并且将它们写到之前定义的log_dir路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># summaries合并</span></span><br><span class="line">merged = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写到指定的磁盘路径中</span></span><br><span class="line">train_writer = tf.summary.FileWriter(log_dir + <span class="string">'/train'</span>, sess.graph)</span><br><span class="line">test_writer = tf.summary.FileWriter(log_dir + <span class="string">'/test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行初始化所有变量</span></span><br><span class="line">tf.global_variables_initializer().run()</span><br></pre></td></tr></table></figure><h2 id="4-8-送入数据集"><a href="#4-8-送入数据集" class="headerlink" title="4.8 送入数据集"></a>4.8 送入数据集</h2><p>feed_dict用于获取数据，如果是<strong>train == true</strong>，也就是进行训练的时候，就从mnist.train中获取一个batch大小为100样本，并且设置dropout值为0.9。如果是<strong>train == false</strong>,则获取minist.test的测试数据，并且设置dropout为1，即保留所有神经元开启。</p><p>同时，每隔10步，进行一次测试，并打印一次测试数据集的准确率，然后将测试数据集的各种summary信息写进日志中。 其余的时候，都是在进行训练，将训练集的summary信息并写到日志中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feed_dict</span><span class="params">(train)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> train:</span><br><span class="line">        xs, ys = mnist.train.next_batch(<span class="number">100</span>)</span><br><span class="line">        k = dropout</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        xs, ys = mnist.test.images, mnist.test.labels</span><br><span class="line">        k = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;x: xs, y_: ys, keep_prob: k&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(max_steps):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:  <span class="comment"># 记录测试集的summary与accuracy</span></span><br><span class="line">        summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(<span class="keyword">False</span>))</span><br><span class="line">        test_writer.add_summary(summary, i)</span><br><span class="line">        print(<span class="string">'Accuracy at step %s: %s'</span> % (i, acc))</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 记录训练集的summary</span></span><br><span class="line">        summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(<span class="keyword">True</span>))</span><br><span class="line">        train_writer.add_summary(summary, i)</span><br><span class="line"></span><br><span class="line">train_writer.close()</span><br><span class="line">test_writer.close()</span><br></pre></td></tr></table></figure><h2 id="4-9-运行程序"><a href="#4-9-运行程序" class="headerlink" title="4.9 运行程序"></a>4.9 运行程序</h2><p>运行整个程序，在程序中定义的summary node就会将要记录的信息全部保存在指定的logdir路径中了，训练的记录会存一份文件，测试的记录会存一份文件。</p><p>运行程序，如果使用GPU进行训练，等待几分钟应该就OK了</p><h2 id="4-10-利用Tensorboard查看训练状态"><a href="#4-10-利用Tensorboard查看训练状态" class="headerlink" title="4.10 利用Tensorboard查看训练状态"></a>4.10 利用Tensorboard查看训练状态</h2><p>与此同时，在运行的时候，我们就可以打开Tensorboard查看训练状态。使用如下指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=./MNIST_LOG --port=<span class="number">8008</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度学习实战（一）：手写数字识别&quot;&gt;&lt;a href=&quot;#深度学习实战（一）：手写数字识别&quot; class=&quot;headerlink&quot; title=&quot;深度学习实战（一）：手写数字识别&quot;&gt;&lt;/a&gt;深度学习实战（一）：手写数字识别&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;1-前言
      
    
    </summary>
    
      <category term="深度学习" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Tensorflow" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Tensorflow/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Tensorflow/Python/"/>
    
    
      <category term="深度学习" scheme="https://xhjiang.tech/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/tags/Python/"/>
    
      <category term="Tensorflow" scheme="https://xhjiang.tech/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-替换空格</title>
    <link href="https://xhjiang.tech/2018/11/13/%E5%89%91%E6%8C%87offer-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://xhjiang.tech/2018/11/13/剑指offer-替换空格/</id>
    <published>2018-11-13T11:35:12.000Z</published>
    <updated>2018-11-13T11:48:43.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><hr><p><strong>题目描述</strong></p><p>请实现一个函数，将一个字符串中的每个空格替换成“<strong>%20</strong>”。例如，当字符串为<strong>We Are Happy</strong>.则经过替换之后的字符串为<strong>We%20Are%20Happy</strong>.</p><hr><p><strong>C++解题思路</strong></p><ol><li><p>可以新建一个string对象，从前向后遍历源字符串，遇到空格即替换成%20，不是空格直接拷贝，最后把string对象转换成C字符串拷贝给源字符串。</p></li><li><p>先遍历源字符串得到空格的个数，得到替换后字符串的长度，使用两个指针，一个指向源串的最后，一个指向新字符串的最后，从后向前拷贝，遇到空格开始替换，同时后面的指针继续向前，直到两个指针相等，说明替换完成。注意不要在函数内新建一个数组来做，直接在源串上进行改动。这里给出第二种解题思路的代码：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* pstr = str; </span><br><span class="line">    <span class="keyword">while</span>(*pstr != <span class="string">'\0'</span>)     <span class="comment">//得到空格的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pstr == <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;    </span><br><span class="line">        &#125;</span><br><span class="line">        pstr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newsize = length + <span class="number">2</span>*count;    <span class="comment">//替换后的字符串长度</span></span><br><span class="line">    str[newsize] = <span class="string">'\0'</span>;           <span class="comment">//给新字符串末尾设置结束标志，不能省略。</span></span><br><span class="line">    <span class="keyword">char</span>* end = str + length - <span class="number">1</span>;     <span class="comment">//源串的最后一个位置</span></span><br><span class="line">    <span class="keyword">char</span>* finish = str + newsize - <span class="number">1</span>;   <span class="comment">//新串的最后一个位置</span></span><br><span class="line">    <span class="keyword">while</span>(end != finish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*end != <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *finish-- = *end--;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                  <span class="comment">//遇见空格开始替换。</span></span><br><span class="line">            *finish-- = <span class="string">'0'</span>;</span><br><span class="line">            *finish-- = <span class="string">'2'</span>;</span><br><span class="line">            *finish-- = <span class="string">'%'</span>;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Python解题思路</strong></p><p><strong>Python</strong>中的<strong>replace()</strong> 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。所以只需要在循环中判断字符是否是空格字符，如果是的话就替换成‘<strong>%20</strong>’就行了。</p><blockquote><p><em>用法：</em> str.replace(old, new[, max])</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#s1 = dict(s)</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="string">' '</span>:</span><br><span class="line">                s = s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><blockquote><p>Tips:<br>此解法是本菜鸡自己想出来的，所以可以得出并不是本菜鸡变厉害了，而是python相对于c++来说确实很好用。python真香~</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;替换空格&quot;&gt;&lt;a href=&quot;#替换空格&quot; class=&quot;headerlink&quot; title=&quot;替换空格&quot;&gt;&lt;/a&gt;替换空格&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的每个空格替换成“&lt;str
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://xhjiang.tech/categories/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/%E5%89%91%E6%8C%87offer/C/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="剑指offer" scheme="https://xhjiang.tech/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-Reverse Integer</title>
    <link href="https://xhjiang.tech/2018/11/13/leetcode%E5%88%B7%E9%A2%98-Reverse-Integer/"/>
    <id>https://xhjiang.tech/2018/11/13/leetcode刷题-Reverse-Integer/</id>
    <published>2018-11-13T08:38:32.000Z</published>
    <updated>2018-11-13T08:55:52.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-Reverse-Integer-反转整数"><a href="#7-Reverse-Integer-反转整数" class="headerlink" title="7.Reverse Integer-反转整数"></a>7.Reverse Integer-反转整数</h1><hr><p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p><p>注意:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</span><br></pre></td></tr></table></figure></p><hr><h1 id="方法：弹出和推入数字-amp-溢出前进行检查"><a href="#方法：弹出和推入数字-amp-溢出前进行检查" class="headerlink" title="方法：弹出和推入数字 &amp; 溢出前进行检查"></a>方法：弹出和推入数字 &amp; 溢出前进行检查</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>反转整数的方法可以与反转字符串进行类比。</p><p>我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 <strong>rev</strong> 的后面。最后，<strong>rev</strong> 将与 xx 相反。</p><p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure></p><p>但是，这种方法很危险，因为当 <strong>temp=rev⋅10+pop</strong> 时会导致溢出。</p><p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p><p>为了便于解释，我们假设 <strong>rev</strong> 是正数。</p><ol><li>如果 <strong>temp = rev ⋅ 10 + pop</strong> 导致溢出，那么一定有 <strong>rev ≥ INTMAX / 10</strong>。</li><li>如果 <strong>rev &gt; INTMAX / 10</strong>，那么 <strong>temp = rev ⋅ 10 + pop</strong> 一定会溢出。</li><li>如果 <strong>rev== INTMAX / 10</strong>，那么只要 <strong>pop &gt; 7</strong>, <strong>temp = rev ⋅ 10 + pop</strong> 就会溢出。<br>当 <strong>rev</strong> 为负时可以应用类似的逻辑。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>复杂度分析:</strong></p><p>时间复杂度：O(log(x))，x 中大约有 log10(x) 位数字。<br>空间复杂度：O(1)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;7-Reverse-Integer-反转整数&quot;&gt;&lt;a href=&quot;#7-Reverse-Integer-反转整数&quot; class=&quot;headerlink&quot; title=&quot;7.Reverse Integer-反转整数&quot;&gt;&lt;/a&gt;7.Reverse Integer-反转
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数学" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E5%AD%A6/C/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E5%AD%A6/C/Python/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数学" scheme="https://xhjiang.tech/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-Transpose Matrix</title>
    <link href="https://xhjiang.tech/2018/11/13/leetcode%E5%88%B7%E9%A2%98-Transpose-Matrix/"/>
    <id>https://xhjiang.tech/2018/11/13/leetcode刷题-Transpose-Matrix/</id>
    <published>2018-11-13T08:00:30.000Z</published>
    <updated>2018-11-13T11:52:50.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="867-Transpose-Matrix-转置矩阵"><a href="#867-Transpose-Matrix-转置矩阵" class="headerlink" title="867.Transpose Matrix-转置矩阵"></a>867.Transpose Matrix-转置矩阵</h1><hr><p>给定一个矩阵 A， 返回 A 的转置矩阵。</p><p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt;提示：</span><br><span class="line">&gt;1 &lt;= A.length &lt;= 1000</span><br><span class="line">&gt;1 &lt;= A[0].length &lt;= 1000</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**解题思路：**</span><br><span class="line"></span><br><span class="line">矩阵的行列互换，简单的二重循环就可以了,不过很可惜，可能是太久没实战编码了，虽然知道该怎么做，但还是没写出来正确可以运行的代码......</span><br><span class="line"></span><br><span class="line">- C++版代码：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">        int m=A.size();</span><br><span class="line">        int n=A[0].size();</span><br><span class="line">        vector&lt;int&gt; B(m,0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; C(n,B);</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">                C[j][i]=A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        return C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Python版代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        R, C = len(A), len(A[<span class="number">0</span>])</span><br><span class="line">        ans = [[<span class="keyword">None</span>] * R <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(C)]</span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> c, val <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                ans[c][r] = val</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="comment">#Alternative Solution:</span></span><br><span class="line">        <span class="comment">#return zip(*A)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>复杂度分析:</strong></p><p>时间复杂度：O(R * C)，其中 R 和 C 是给定矩阵 A 的行数和列数。</p><p>空间复杂度：O(R * C)，也就是答案所使用的空间。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;867-Transpose-Matrix-转置矩阵&quot;&gt;&lt;a href=&quot;#867-Transpose-Matrix-转置矩阵&quot; class=&quot;headerlink&quot; title=&quot;867.Transpose Matrix-转置矩阵&quot;&gt;&lt;/a&gt;867.Transpo
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/C/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/C/Python/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Python" scheme="https://xhjiang.tech/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-Remove Element</title>
    <link href="https://xhjiang.tech/2018/11/12/leetcode%E5%88%B7%E9%A2%98-Remove-Element/"/>
    <id>https://xhjiang.tech/2018/11/12/leetcode刷题-Remove-Element/</id>
    <published>2018-11-12T11:34:34.000Z</published>
    <updated>2018-11-13T08:15:52.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="27-Remove-Element-移除元素"><a href="#27-Remove-Element-移除元素" class="headerlink" title="27. Remove Element-移除元素"></a>27. Remove Element-移除元素</h1><hr><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>解法一:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Element</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><em>Tips:</em><br>本解法是受到了 <strong>LeetCode</strong> 上第26题 <strong>Remove Duplicates from Sorted Array</strong> 的解法一的启发。<em>PS</em>终于自己解出来了一道题，虽然是一道简单级别的题，并且两题解法很相似，但还是觉得受到了鼓舞^_^</p></blockquote><ul><li>解法二:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Element</span></span><br><span class="line"><span class="comment">// 使用 remove()，时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(), remove(nums.begin(), nums.end(), val));</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意:</strong></p><ul><li><strong>distance(iterator first,iterator last)</strong> 函数表示返回两个迭代器 <strong>first</strong> 和 <strong>last</strong> 之间的距离;</li><li><strong>remove()</strong> 函数表示返回新的end()迭代器但是不改变原来数组的end()迭代器的值，将范围内值等于val的元素用后一个元素替代。原先数组中 新的end()至原end()范围内的值仍为原来数组的值，但是这部分状态不可靠。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;27-Remove-Element-移除元素&quot;&gt;&lt;a href=&quot;#27-Remove-Element-移除元素&quot; class=&quot;headerlink&quot; title=&quot;27. Remove Element-移除元素&quot;&gt;&lt;/a&gt;27. Remove Element-
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/C/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-Remove Duplicates from Sorted Array</title>
    <link href="https://xhjiang.tech/2018/11/12/leetcode%E5%88%B7%E9%A2%98-Remove-Duplicates-from-Sorted-Array/"/>
    <id>https://xhjiang.tech/2018/11/12/leetcode刷题-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2018-11-12T08:18:08.000Z</published>
    <updated>2018-11-13T08:03:18.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项"><a href="#26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项" class="headerlink" title="26. Remove Duplicates from Sorted Array-删除排序数组中的重复项"></a>26. Remove Duplicates from Sorted Array-删除排序数组中的重复项</h1><p><strong>内容：</strong> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>Tips：</em><br>这道题开始还是没有做出来，暴力破解法的思路错误了，不能一直试图用for循环来解决，应该着重于数组本身的变化以及要在STL上面寻求更好的解题思路</p></blockquote><ul><li><p>解法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Duplicates from Sorted Array</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] != nums[i])</span><br><span class="line">            nums[++index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>解法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Duplicates from Sorted Array</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(), unique(nums.begin(), nums.end()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意:</strong></p><ul><li><strong>distance(iterator first,iterator last)</strong> 函数表示返回两个迭代器 <strong>first</strong> 和 <strong>last</strong> 之间的距离;</li><li><strong>unique(iterator it_1,iterator it_2)</strong> 函数表示其中这两个参数表示对容器中[it_1，it_2)范围的元素进行去重(注：区间是前闭后开，即不包含it_2所指的元素),返回值是一个迭代器，它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。</li></ul></blockquote><ul><li>解法三：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeetCode, Remove Duplicates from Sorted Array</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n)，空间复杂度 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(), removeDuplicates(nums.begin(), nums.end(), nums.begin()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InIt, <span class="keyword">typename</span> OutIt&gt;</span><br><span class="line">    <span class="function">OutIt <span class="title">removeDuplicates</span><span class="params">(InIt first, InIt last, OutIt output)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *output++ = *first;</span><br><span class="line">        first = upper_bound(first, last, *first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;#26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/C/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++中的STL中map用法详解</title>
    <link href="https://xhjiang.tech/2018/11/12/C-%E4%B8%AD%E7%9A%84STL%E4%B8%ADmap%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://xhjiang.tech/2018/11/12/C-中的STL中map用法详解/</id>
    <published>2018-11-12T06:35:43.000Z</published>
    <updated>2018-11-12T07:27:07.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-map简介"><a href="#1-map简介" class="headerlink" title="1. map简介"></a>1. map简介</h1><p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。跟<strong>python</strong>语言中的<strong>元组</strong>类似。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p><hr><h1 id="2-map的基本操作函数"><a href="#2-map的基本操作函数" class="headerlink" title="2. map的基本操作函数"></a>2. map的基本操作函数</h1><p>map的基本操作函数：</p><pre><code>begin()         返回指向map头部的迭代器clear(）        删除所有元素count()         返回指定元素出现的次数empty()         如果map为空则返回trueend()           返回指向map末尾的迭代器equal_range()   返回特殊条目的迭代器对erase()         删除一个元素find()          查找一个元素get_allocator() 返回map的配置器insert()        插入元素key_comp()      返回比较元素key的函数lower_bound()   返回键值&gt;=给定元素的第一个位置max_size()      返回可以容纳的最大元素个数rbegin()        返回一个指向map尾部的逆向迭代器rend()          返回一个指向map头部的逆向迭代器size()          返回map中元素的个数swap()           交换两个mapupper_bound()    返回键值&gt;给定元素的第一个位置value_comp()     返回比较元素value的函数</code></pre><hr><h1 id="3-使用map"><a href="#3-使用map" class="headerlink" title="3. 使用map"></a>3. 使用map</h1><p>使用map得包含map类所在的头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //注意，STL头文件没有扩展名.h</span></span></span><br></pre></td></tr></table></figure></p><p>map对象是模板类，需要关键字和存储对象两个模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; personnel;</span><br></pre></td></tr></table></figure></p><p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p><p>为了使用方便，可以对模板类进行一下类型定义，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>,CString&gt; UDT_MAP_INT_CSTRING;</span><br><span class="line"></span><br><span class="line">UDT_MAP_INT_CSTRING enumMap;</span><br></pre></td></tr></table></figure></p><h1 id="4-map的构造函数"><a href="#4-map的构造函数" class="headerlink" title="4. map的构造函数"></a>4. map的构造函数</h1><p>map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br></pre></td></tr></table></figure></p><h1 id="5-map的一些基本操作"><a href="#5-map的一些基本操作" class="headerlink" title="5. map的一些基本操作"></a>5. map的一些基本操作</h1><h2 id="5-1-insert插入操作"><a href="#5-1-insert插入操作" class="headerlink" title="5.1 insert插入操作"></a>5.1 insert插入操作</h2><p>在构造map容器后，我们就可以往里面插入数据了。这里讲三种插入数据的方法：</p><h3 id="5-1-1-用insert函数插入pair数据，下面举例说明"><a href="#5-1-1-用insert函数插入pair数据，下面举例说明" class="headerlink" title="5.1.1 用insert函数插入pair数据，下面举例说明"></a>5.1.1 用insert函数插入pair数据，下面举例说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据的插入--第一种：用insert函数插入pair数据  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-用insert函数插入value-type数据，下面举例说明"><a href="#5-1-2-用insert函数插入value-type数据，下面举例说明" class="headerlink" title="5.1.2 用insert函数插入value_type数据，下面举例说明"></a>5.1.2 用insert函数插入value_type数据，下面举例说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种：用insert函数插入value_type数据，下面举例说明  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-用数组方式插入数据，下面举例说明"><a href="#5-1-3-用数组方式插入数据，下面举例说明" class="headerlink" title="5.1.3 用数组方式插入数据，下面举例说明"></a>5.1.3 用数组方式插入数据，下面举例说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种：用数组方式插入数据，下面举例说明  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">"student_one"</span>;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">2</span>] = <span class="string">"student_two"</span>;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">3</span>] = <span class="string">"student_three"</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips：</em><br>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值。</p></blockquote><h2 id="5-2-map的大小–size函数"><a href="#5-2-map的大小–size函数" class="headerlink" title="5.2 map的大小–size函数"></a>5.2 map的大小–size函数</h2><p>这里也提供三种方法，对map进行遍历</p><h3 id="5-2-1-应用前向迭代器，上面举例程序中到处都是了，略过不表"><a href="#5-2-1-应用前向迭代器，上面举例程序中到处都是了，略过不表" class="headerlink" title="5.2.1 应用前向迭代器，上面举例程序中到处都是了，略过不表"></a>5.2.1 应用前向迭代器，上面举例程序中到处都是了，略过不表</h3><h3 id="5-2-2-应用反相迭代器，下面举例说明："><a href="#5-2-2-应用反相迭代器，下面举例说明：" class="headerlink" title="5.2.2 应用反相迭代器，下面举例说明："></a>5.2.2 应用反相迭代器，下面举例说明：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种，利用反向迭代器  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::reverse_iterator iter;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">"  "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-用数组的形式，程序说明如下："><a href="#5-2-3-用数组的形式，程序说明如下：" class="headerlink" title="5.2.3 用数组的形式，程序说明如下："></a>5.2.3 用数组的形式，程序说明如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种：用数组方式，程序说明如下  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> nSize = mapStudent.size();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//此处应注意，应该是 for(int nindex = 1; nindex &lt;= nSize; nindex++)  </span></span><br><span class="line"><span class="comment">//而不是 for(int nindex = 0; nindex &lt; nSize; nindex++)  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> nindex = <span class="number">1</span>; nindex &lt;= nSize; nindex++)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mapStudent[nindex]&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-查找并获取map中的元素（包括判定这个关键字是否在map中出现）"><a href="#5-3-查找并获取map中的元素（包括判定这个关键字是否在map中出现）" class="headerlink" title="5.3 查找并获取map中的元素（包括判定这个关键字是否在map中出现）"></a>5.3 查找并获取map中的元素（包括判定这个关键字是否在map中出现）</h2><p>在这里我们将体会，map在数据插入时保证有序的好处。要判定一个数据（关键字）是否在map中出现的方法比较多，这里标题虽然是数据的查找，在这里将穿插着大量的map基本用法。<br>这里给出三种数据查找方法:</p><h3 id="5-3-1-用count函数来判定关键字是否出现"><a href="#5-3-1-用count函数来判定关键字是否出现" class="headerlink" title="5.3.1 用count函数来判定关键字是否出现"></a>5.3.1 用count函数来判定关键字是否出现</h3><p>其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了</p><h3 id="5-3-2-用find函数来定位数据出现位置"><a href="#5-3-2-用find函数来定位数据出现位置" class="headerlink" title="5.3.2 用find函数来定位数据出现位置"></a>5.3.2 用find函数来定位数据出现位置</h3><p>它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。查找map中是否包含某个关键字条目用find()方法，传入的参数是要查找的key，在这里需要提到的是<strong>begin()</strong>和<strong>end()</strong>两个成员，分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是<strong>iterator</strong>。<br>程序说明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">    mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.find(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(iter != mapStudent.end())  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find, the value is "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>通过map对象的方法获取的iterator数据类型是一个std::pair对象，包括两个数据 iterator-&gt;first和 iterator-&gt;second分别代表关键字和存储的数据。</p></blockquote><h3 id="5-3-3-第三种：这个方法用来判定数据是否出现"><a href="#5-3-3-第三种：这个方法用来判定数据是否出现" class="headerlink" title="5.3.3 第三种：这个方法用来判定数据是否出现"></a>5.3.3 第三种：这个方法用来判定数据是否出现</h3><p>lower_bound函数用法，这个函数用来返回要查找关键字的下界(是一个迭代器)<br>upper_bound函数用法，这个函数用来返回要查找关键字的上界(是一个迭代器)</p><p>例如：map中已经插入了1，2，3，4的话，如果lower_bound(2)的话，返回的2，而upper-bound（2）的话，返回的就是3</p><p>Equal_range函数返回一个pair，pair里面第一个变量是Lower_bound返回的迭代器，pair里面第二个迭代器是Upper_bound返回的迭代器，如果这两个迭代器相等的话，则说明map中不出现这个关键字，</p><p>程序说明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">"student_one"</span>;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">3</span>] = <span class="string">"student_three"</span>;  </span><br><span class="line">  </span><br><span class="line">    mapStudent[<span class="number">5</span>] = <span class="string">"student_five"</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.lower_bound(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是下界1的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.lower_bound(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是下界3的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.lower_bound(<span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是下界3的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.upper_bound(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是上界3的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    iter = mapStudent.upper_bound(<span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回的是上界5的迭代器  </span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator&gt; mappair;  </span><br><span class="line">  </span><br><span class="line">    mappair = mapStudent.equal_range(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(mappair.first == mappair.second)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    mappair = mapStudent.equal_range(<span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(mappair.first == mappair.second)  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-从map中删除元素"><a href="#5-4-从map中删除元素" class="headerlink" title="5.4 从map中删除元素"></a>5.4 从map中删除元素</h2><p>移除某个map中某个条目用<strong>erase（）</strong></p><p>该成员方法的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iterator erase（iterator it);<span class="comment">//通过一个条目对象删除</span></span><br><span class="line"></span><br><span class="line">iterator erase（iterator first，iterator last）<span class="comment">//删除一个范围</span></span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> Key&amp;key)</span></span>;<span class="comment">//通过关键字删除</span></span><br><span class="line"></span><br><span class="line">clear()就相当于enumMap.erase(enumMap.begin(),enumMap.end());</span><br></pre></td></tr></table></figure></p><p>这里要用到erase函数，它有三个重载了的函数，下面在例子中详细说明它们的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;  </span><br><span class="line">  </span><br><span class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));  </span><br><span class="line">  </span><br><span class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));  </span><br><span class="line">  </span><br><span class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好  </span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">//如果要删除1,用迭代器删除  </span></span><br><span class="line">  </span><br><span class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;  </span><br><span class="line">  </span><br><span class="line">       iter = mapStudent.find(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">       mapStudent.erase(iter);  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//如果要删除1，用关键字删除  </span></span><br><span class="line">  </span><br><span class="line">       <span class="keyword">int</span> n = mapStudent.erase(<span class="number">1</span>);<span class="comment">//如果删除了会返回1，否则返回0  </span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">//用迭代器，成片的删除  </span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">//一下代码把整个map清空  </span></span><br><span class="line">  </span><br><span class="line">       mapStudent.erase( mapStudent.begin(), mapStudent.end() );  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合  </span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">//自个加上遍历代码，打印输出吧  </span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-map中的swap用法"><a href="#5-5-map中的swap用法" class="headerlink" title="5.5 map中的swap用法"></a>5.5 map中的swap用法</h2><p>map中的swap不是一个容器中的元素交换，而是两个容器所有元素的交换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-map简介&quot;&gt;&lt;a href=&quot;#1-map简介&quot; class=&quot;headerlink&quot; title=&quot;1. map简介&quot;&gt;&lt;/a&gt;1. map简介&lt;/h1&gt;&lt;p&gt;Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出
      
    
    </summary>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/C/"/>
    
      <category term="STL" scheme="https://xhjiang.tech/categories/C/STL/"/>
    
      <category term="map" scheme="https://xhjiang.tech/categories/C/STL/map/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="STL" scheme="https://xhjiang.tech/tags/STL/"/>
    
      <category term="map" scheme="https://xhjiang.tech/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-Two Sum</title>
    <link href="https://xhjiang.tech/2018/11/12/leetcode%E5%88%B7%E9%A2%98-Two-Sum/"/>
    <id>https://xhjiang.tech/2018/11/12/leetcode刷题-Two-Sum/</id>
    <published>2018-11-12T05:21:52.000Z</published>
    <updated>2018-11-12T08:35:42.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法真的好难之刚开始就要被虐哭"><a href="#算法真的好难之刚开始就要被虐哭" class="headerlink" title="算法真的好难之刚开始就要被虐哭~~~"></a>算法真的好难之刚开始就要被虐哭~~~</h3><hr><h2 id="先吐槽一波"><a href="#先吐槽一波" class="headerlink" title="先吐槽一波~~~"></a>先吐槽一波~~~</h2><p>之前看了一段时间的基础知识，感觉一边学一边忘是不行的，于是静极思动，决定从今天开始直接刷LeetCode的题，实践出真知！（手动滑稽=_=），开始刷题了觉得自己当初是有多高估自己才选择算法，真是简单级别的题目都要难倒我了，真是可怕！不过事已至此只能拼命学了。好了，话不多说，正式记录自己的苦逼刷题之旅……</p><hr><h2 id="1-Two-Sum–两数之和"><a href="#1-Two-Sum–两数之和" class="headerlink" title="1.Two Sum–两数之和"></a>1.Two Sum–两数之和</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>之前准备用C++直接写暴力法，但是可惜算法思路正确了，就是C++基础还是不够扎实，提交代码还是有问题，所以这里引用了系统的<strong>Java</strong>版参考代码。暴力法很简单。遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。</p><p><em>java:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p><em>时间复杂度：</em> O(n^2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n)的时间。因此时间复杂度为O(n^2)。</p><p><em>空间复杂度：</em> O(1)。</p><h3 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h3><p>借助Hash求解，这是较为标准的解法，首先将数组中每个数存入Hash表，然后枚举数组内数字（假设当前枚举数字为A，则在Hash表中查询target- A是否存在，找到则返回解），枚举一趟中一定因为有解的存在而返回，时间复杂度O(n)；（实际时间使用情况，10ms[Java]以内）</p><p><em>C++:</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// map存储数组信息 vector存储结果</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="comment">// 遍历数组查询结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line"><span class="comment">// 查找到配对元素</span></span><br><span class="line"><span class="keyword">if</span> (m.find(target - nums[i]) != m.end()) &#123;</span><br><span class="line">ans.push_back(m[target - nums[i]]);</span><br><span class="line">ans.push_back(i);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则将现在元素插入map</span></span><br><span class="line">m.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(nums[i], i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>复杂度分析：</em></p><p><em>时间复杂度：</em> O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。</p><p><em>空间复杂度：</em> O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法真的好难之刚开始就要被虐哭&quot;&gt;&lt;a href=&quot;#算法真的好难之刚开始就要被虐哭&quot; class=&quot;headerlink&quot; title=&quot;算法真的好难之刚开始就要被虐哭~~~&quot;&gt;&lt;/a&gt;算法真的好难之刚开始就要被虐哭~~~&lt;/h3&gt;&lt;hr&gt;
&lt;h2 id=&quot;先吐
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="C++" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/C/"/>
    
      <category term="Java" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/C/Java/"/>
    
    
      <category term="C++" scheme="https://xhjiang.tech/tags/C/"/>
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="Java" scheme="https://xhjiang.tech/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AmbientGAN一文总结与摘录</title>
    <link href="https://xhjiang.tech/2018/11/07/AmbientGAN%E4%B8%80%E6%96%87%E6%80%BB%E7%BB%93%E4%B8%8E%E6%91%98%E5%BD%95/"/>
    <id>https://xhjiang.tech/2018/11/07/AmbientGAN一文总结与摘录/</id>
    <published>2018-11-07T14:40:17.000Z</published>
    <updated>2018-11-12T07:24:11.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AmbientGAN-Generative-models-from-lossy-measurements"><a href="#AmbientGAN-Generative-models-from-lossy-measurements" class="headerlink" title="AmbientGAN:Generative models from lossy measurements"></a>AmbientGAN:Generative models from lossy measurements</h1><hr><h2 id="环境GAN：从有损测度中生成模型"><a href="#环境GAN：从有损测度中生成模型" class="headerlink" title="环境GAN：从有损测度中生成模型"></a>环境GAN：从有损测度中生成模型</h2><p><strong>摘要：</strong><br>生成模型提供了一种对于复杂分布中结构进行建模的方式，并且已经被证明可用于很多实际感兴趣的任务中。但是，现在训练生成模型的技术需要访问完全可观测（fully-observed）的样本。在很多场景中，获取完全可观测的样本是昂贵的甚至不可能的，但是获取部分的有噪声的观测样本是比较实惠的。我们考虑在只给予感兴趣的分布的样本的有损失观测情况下，学习一个隐式的生成模型的任务。我们证明了即使在测度模型的某个类的每个样本信息丢失的情况下，真正隐藏的分布也可以被恢复。基于此，我们提出了一种我们称之为环境GAN（<strong>AmbientGAN</strong>）的新的训练生成对抗网络的方法。在三个基准数据集和对于很多测度模型而言，我们证实了方法实质性的定性和定量的改进。用我们方法训练的生成模型可以获得比基准高2-4倍的初始分数（inception score）。</p><hr><p>#原理</p><p>本文提出的模型很简单，就是生成器需要去拟合的数据分布并不可直接得到，但是知道经过一些处理后得到的原数据的有损数据，并且知道这个处理的过程，于是采用有损数据，并将处理过程整合到GAN的架构中，获得的就是这篇文章提出的AmbientGAN的架构，其具体架构如图所示：<div align="center"><img src="img/ambient_p1.png" alt=""></div><br>其中Y是原始数据有损处理以后的结果数据，而黄色的fθ函数就是有损处理的映射函数，因而这个AmbientGAN与GAN之间的区别就在于分辨器D需要分辨输入的有损数据来自于真实的有损数据Yr，还是生成的数据Xg经过f函数映射后得到的Yg。因此，对应的AmbientGAN的loss修改为如下形式：<div align="center"><img src="img/ambient_p2.png" alt=""></div></p><p>其中，q(x)表示的是质量函数（按照理解，就是loss函数，在原始的GAN中，这个函数就是q(x)=log(x)）。而fθ函数，就是模拟的测度函数，就是图中黄色部分。在论文中，这个函数要求对所有的输入，该函数可导。</p><hr><p>#实验</p><p>然后实验部分用了下面几种测量模型：<br>Block-Pixels：模糊图片，对于0像素，使用其周围的像素来填充，文中采用的是total variation inpainting的方法。<br>Convolve+Noise：Wiener deconvolution的方法处理图片作为近似。<br>Block-Patch：Navier Stokes based inpainting的方法来填充0像素。还有诸如Keep-patch，Pad-Rotate-Project和Pad-Rotate-Project-θ等等模型。没有其他的方法进行近似估计逆值，因而在试验中，作者只提供了AmbientGAN的结果。最后训练效果除了一个降维测度模型中，AmbientGAN没有产生较好的实验结果，其他的实验结果都是比baseline在观感上要好的。</p><hr><p>#总结</p><p>这篇文章的网络架构很简单，有损的样本，得到有损样本的处理过程，在这种情况下，将得到有损样本的处理过程整合到GAN中，以此得到AmbientGAN，来在只能得到有损样本和有损样本的处理过程的情况下，学习从不完整数据中，生成完整数据的一个生成模型。虽然整体的约束条件比较苛刻，但是有论文的审核者提出，这或许是为去噪模型提供了一种思路，这样的模型可能可以用来去噪或者还原图片。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AmbientGAN-Generative-models-from-lossy-measurements&quot;&gt;&lt;a href=&quot;#AmbientGAN-Generative-models-from-lossy-measurements&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="深度学习" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GAN" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/GAN/"/>
    
      <category term="科研" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/GAN/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="深度学习" scheme="https://xhjiang.tech/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GAN" scheme="https://xhjiang.tech/tags/GAN/"/>
    
      <category term="科研" scheme="https://xhjiang.tech/tags/%E7%A7%91%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>生成对抗网络(GAN)原理理解</title>
    <link href="https://xhjiang.tech/2018/11/06/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C-GAN-%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/"/>
    <id>https://xhjiang.tech/2018/11/06/生成对抗网络-GAN-原理理解/</id>
    <published>2018-11-06T13:06:16.000Z</published>
    <updated>2018-11-12T07:23:32.996Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Generative Adversarial Network</strong>，就是大家耳熟能详的 <strong>GAN</strong>，由 Ian Goodfellow 首先提出，在这两年更是深度学习中最热门的东西，仿佛什么东西都能由 GAN 做出来。我最近刚入门 <strong>GAN</strong>，主要是在哔哩哔哩网站上学习李宏毅教授的<strong>GAN</strong>课程。现在总结一下思路，做一篇笔记。<br><br></p><hr><h1 id="1-GAN基础概念"><a href="#1-GAN基础概念" class="headerlink" title="1. GAN基础概念"></a>1. GAN基础概念</h1><p><strong>GAN</strong>全称是Generative Adversarial Nets，中文叫做“<strong>生成对抗网络</strong>”。<br>在GAN中有2个网络，一个网络用于生成数据，叫做<strong>generator</strong>也就是“<strong>生成器</strong>”。另一个网络用于判别生成数据是否接近于真实，叫做<strong>discriminator</strong>也就是“<strong>判别器</strong>”。<br><br>流程图如下所示：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDWhVyPj0ivBduQzAthEtlQYRuV7ZESOvw&amp;q-sign-time=1541591468;1541593268&amp;q-key-time=1541591468;1541593268&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=cc2de2fba4d67289dfe7ca7b5780334db75a6583&amp;x-cos-security-token=ddfc8a545dc91147c517c5234380dbd571f78fd510001&amp;response-content-disposition=attachment" alt=""></div><br><br><br>首先，有一个一代的 generator，它能生成一些很差的图片，然后有一个一代的discriminator，它能准确的把生成的图片，和真实的图片分类，简而言之，这个 discriminator 就是一个二分类器，对生成的图片输出 0，对真实的图片输出 1。</p><p>接着，开始训练出二代的 generator，它能生成稍好一点的图片，能够让一代的 discriminator 认为这些生成的图片是真实的图片。然后会训练出一个二代的 discriminator，它能准确的识别出真实的图片，和二代 generator 生成的图片。以此类推，会有三代，四代。。。n 代的 generator 和 discriminator，最后 discriminator 无法分辨生成的图片和真实图片，这个网络就拟合了。</p><p>这就是 GAN，运行过程就是这么的简单。这就结束了嘛？显然没有，下面还要介绍一下 GAN 的原理。</p><hr><h1 id="2-GAN原理"><a href="#2-GAN原理" class="headerlink" title="2. GAN原理"></a>2. GAN原理</h1><p>首先我们知道真实图片集的分布 Pdata(x)，x 是一个真实图片，可以想象成一个向量，这个向量集合的分布就是 Pdata。我们需要生成一些也在这个分布内的图片，如果直接就是这个分布的话，怕是做不到的。</p><p>我们现在有的 generator 生成的分布可以假设为 PG(x;θ)，这是一个由 θ 控制的分布，θ 是这个分布的参数（如果是高斯混合模型，那么 θ 就是每个高斯分布的平均值和方差）</p><p>假设我们在真实分布中取出一些数据，{x1, x2, … , xm}，我们想要计算一个似然 PG(xi; θ)。</p><p>对于这些数据，在生成模型中的似然就是<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/1.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDNi0Bsg5QydkxlMUNY29ahl9kMFD4Hvw4&amp;q-sign-time=1541591395;1541593195&amp;q-key-time=1541591395;1541593195&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=7c3f7d9afe8199d9f3ea49b73ee66a39efec7502&amp;x-cos-security-token=81c78b985feb56ee872a2c00727e8db44e50b5b310001&amp;response-content-disposition=attachment" alt=""></div><br>我们想要最大化这个似然，等价于让 generator 生成那些真实图片的概率最大。这就变成了一个<strong>最大似然估计的问题</strong>了，我们需要找到一个 θ* 来最大化这个似然。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/2.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDWeZstr7lvkbmecS2GkW4CnttRZNNYCR8&amp;q-sign-time=1541591495;1541593295&amp;q-key-time=1541591495;1541593295&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=d328b8438250f4d310b24d0b18fa662260bcb59a&amp;x-cos-security-token=3a7970557101263e1089a6d69f0b90b2b342f4bb10001&amp;response-content-disposition=attachment" alt=""></div></p><p>寻找一个 θ* 来最大化这个似然，等价于最大化 log 似然。因为此时这 m 个数据，是从真实分布中取的，所以也就约等于，真实分布中的所有 x 在 PG 分布中的 log 似然的期望。</p><p>真实分布中的所有 x 的期望，等价于求概率积分，所以可以转化成积分运算，因为减号后面的项和 θ 无关，所以添上之后还是等价的。然后提出共有的项，括号内的反转，max 变 min，就可以转化为 <strong>KL divergence</strong> 的形式了，<strong>KL divergence</strong> 描述的是两个概率分布之间的差异。</p><p>所以最大化似然，让 generator 最大概率的生成真实图片，也就是要找一个 θ 让 PG 更接近于 Pdata。</p><p>那如何来找这个最合理的 θ 呢？我们可以假设 PG(x; θ) 是一个神经网络。</p><p>首先随机一个向量 z，通过 G(z)=x 这个网络，生成图片 x，那么我们如何比较两个分布是否相似呢？只要我们取一组 sample z，这组 z 符合一个分布，那么通过网络就可以生成另一个分布 PG，然后来比较与真实分布 Pdata。</p><p>大家都知道，神经网络只要有非线性激活函数，就可以去拟合任意的函数，那么分布也是一样，所以可以用一直正态分布，或者高斯分布，取样去训练一个神经网络，学习到一个很复杂的分布。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/3.jpg?q-sign-algorithm=sha1&amp;q-ak=AKID8APajjKNuWJS9aCQkHmcFWEorQ8jD7D9&amp;q-sign-time=1541591517;1541593317&amp;q-key-time=1541591517;1541593317&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=3ec4d14a65862cb65d2163e16460aacd0960a97f&amp;x-cos-security-token=20aa5a08ea0f50eeadae91edc671c12679d7e15510001&amp;response-content-disposition=attachment" alt=""></div></p><p>如何来找到更接近的分布，这就是 GAN 的贡献了。先给出 GAN 的公式：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/4.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDoWe3VUDyqycm7RyqrjwZCnGSzHELr0vj&amp;q-sign-time=1541591545;1541593345&amp;q-key-time=1541591545;1541593345&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=8113178a4281f8a55730f210a51291f721d73046&amp;x-cos-security-token=b40666353c57b5adc316fa0fc9a9f9e919ed848710001&amp;response-content-disposition=attachment" alt=""></div></p><p>这个式子的好处在于，固定 G，max  V(G,D) 就表示 PG 和 Pdata 之间的差异，然后要找一个最好的 G，让这个最大值最小，也就是两个分布之间的差异最小。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/5.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDYUaGmc2uEkkzGUzxE063Yoat7IH9JZX9&amp;q-sign-time=1541591570;1541593370&amp;q-key-time=1541591570;1541593370&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=127c16952bf66ab22a96622195bdc89003fa130f&amp;x-cos-security-token=5f25638471592a9a75beec512e21faf7269a708d10001&amp;response-content-disposition=attachment" alt=""></div></p><p>表面上看这个的意思是，D 要让这个式子尽可能的大，也就是对于 x 是真实分布中，D(x) 要接近与 1，对于 x 来自于生成的分布，D(x) 要接近于 0，然后 G 要让式子尽可能的小，让来自于生成分布中的 x，D(x) 尽可能的接近 1。</p><p>现在我们先固定 G，来求解最优的 D：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/6.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDWLzH7cLFlZ8Kyzjns5jZxbyJ1DMv4kId&amp;q-sign-time=1541591600;1541593400&amp;q-key-time=1541591600;1541593400&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=919a1842c9519e4e9ec662362053bd4cde761aea&amp;x-cos-security-token=728962d323caf679a36e836883a2163938de362a10001&amp;response-content-disposition=attachment" alt=""></div></p><p>对于一个给定的 x，得到最优的 D 如上图，范围在 (0,1) 内，把最优的 D 带入<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/7.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDkJLBnezxSbp65d2BSn3JZmN9MIZoJJQI&amp;q-sign-time=1541591621;1541593421&amp;q-key-time=1541591621;1541593421&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=f8cff0fa270195317e8c186fea0157efa03b1dd3&amp;x-cos-security-token=75acab77f5437891fb7ecb5cf6cc921da463b1ae10001&amp;response-content-disposition=attachment" alt=""></div></p><p>可以得到：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/8.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDE80S6rrnbdP60A9i6p9jj3ONIC5YyeZu&amp;q-sign-time=1541591651;1541593451&amp;q-key-time=1541591651;1541593451&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=41439a45d80e2b6e9dfb1bf598e32c9104393495&amp;x-cos-security-token=4ee1800772b8da834ddcaad119a016603563d41110001&amp;response-content-disposition=attachment" alt=""></div><div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/8-1.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDbEdE7Zh7Esxyy1b8csaA55VfFZmd4gPR&amp;q-sign-time=1541592169;1541593969&amp;q-key-time=1541592169;1541593969&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=2a50d3908cf3eb79f525f0f081223ca16cc3e7eb&amp;x-cos-security-token=874c459cbef33b6610b15a96ae927ffae886c8d910001&amp;response-content-disposition=attachment" alt=""></div></p><p>JS divergence 是 KL divergence 的对称平滑版本，表示了两个分布之间的差异，这个推导就表明了上面所说的，固定 G。<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/7.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDkJLBnezxSbp65d2BSn3JZmN9MIZoJJQI&amp;q-sign-time=1541591621;1541593421&amp;q-key-time=1541591621;1541593421&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=f8cff0fa270195317e8c186fea0157efa03b1dd3&amp;x-cos-security-token=75acab77f5437891fb7ecb5cf6cc921da463b1ae10001&amp;response-content-disposition=attachment" alt=""></div></p><p>表示两个分布之间的差异，最小值是 -2log2，最大值为 0。</p><p>现在我们需要找个 G，来最小化<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/7.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDkJLBnezxSbp65d2BSn3JZmN9MIZoJJQI&amp;q-sign-time=1541591621;1541593421&amp;q-key-time=1541591621;1541593421&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=f8cff0fa270195317e8c186fea0157efa03b1dd3&amp;x-cos-security-token=75acab77f5437891fb7ecb5cf6cc921da463b1ae10001&amp;response-content-disposition=attachment" alt=""></div></p><p>观察上式，当 PG(x)=Pdata(x) 时，G 是最优的。</p><hr><h1 id="3-训练"><a href="#3-训练" class="headerlink" title="3. 训练"></a>3. 训练</h1><p>有了上面推导的基础之后，我们就可以开始训练 GAN 了。结合我们开头说的，两个网络交替训练，我们可以在起初有一个 G0 和 D0，先训练 D0 找到 ：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/9.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDGIqYYaFOSTaxLBoT0wVPSFZEbK6rrZJs&amp;q-sign-time=1541591672;1541593472&amp;q-key-time=1541591672;1541593472&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=7cf05362dfd80d5fd19e6b991a8462f141ebd7db&amp;x-cos-security-token=13a5612f500464783827e7d395ddde686fea6fb910001&amp;response-content-disposition=attachment" alt=""></div></p><p>然后固定 D0 开始训练 G0， 训练的过程都可以使用 <strong>gradient descent</strong>，以此类推，训练 D1,G1,D2,G2,…</p><p>但是这里有个问题就是，你可能在 D0* 的位置取到了<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/10.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDJCVLVCPzwlaPGM8StdZ8nadi3yz3sy4x&amp;q-sign-time=1541591692;1541593492&amp;q-key-time=1541591692;1541593492&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=a9225d7bfd09820c49e2f8c858a50cfe41bfda6f&amp;x-cos-security-token=b97dd0bfe8cfe72b509e534b773eb5ab1957e5f310001&amp;response-content-disposition=attachment" alt=""></div></p><p>然后更新 G0 为 G1，可能<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/11.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDfEdAa5EucPp2kamKc6Ys2FNQIHeC9fRm&amp;q-sign-time=1541591709;1541593509&amp;q-key-time=1541591709;1541593509&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=55309c3e8da3bf8a4499a5c829f00a81472a7f1c&amp;x-cos-security-token=cb7d9b3d3dcc64fa9c2babd91aa7345edeb4309910001&amp;response-content-disposition=attachment" alt=""></div></p><p>但是并不保证会出现一个新的点 D1* 使得<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/12.jpg?q-sign-algorithm=sha1&amp;q-ak=AKID3okL8rmuLowWC8QS7VIsqx14RiSsVAs5&amp;q-sign-time=1541591727;1541593527&amp;q-key-time=1541591727;1541593527&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=29134c48a4a4c35a454097e82f0fe52957d4b161&amp;x-cos-security-token=d3ad284e07a94dc51b257952efbd7de77d238b0210001&amp;response-content-disposition=attachment" alt=""></div></p><p>这样更新 G 就没达到它原来应该要的效果，如下图所示：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/13.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDDy2YAW1SccPKc8wPFbpp7ZA5cSxqV1cp&amp;q-sign-time=1541591742;1541593542&amp;q-key-time=1541591742;1541593542&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=481aa6cfa37224d266eaab80bdca51fe262f4502&amp;x-cos-security-token=54acc507a82604a6816d554bf06561536965dda210001&amp;response-content-disposition=attachment" alt=""></div></p><p>避免上述情况的方法就是更新 G 的时候，不要更新 G 太多。</p><p>知道了网络的训练顺序，我们还需要设定两个 loss function，一个是 D 的 loss，一个是 G 的 loss。下面是整个 GAN 的训练具体步骤：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/14.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDEqlpcYjXTj8izB3OsFg4TgAs6la3Lcr7&amp;q-sign-time=1541591759;1541593559&amp;q-key-time=1541591759;1541593559&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=4618819c9895b5d38859183ba9d14472b4250944&amp;x-cos-security-token=bbf74c76ad5119e1c93762bb11e5595c22f0e43c10001&amp;response-content-disposition=attachment" alt=""></div></p><p>上述步骤在机器学习和深度学习中也是非常常见，易于理解。</p><hr><h1 id="4-存在的问题"><a href="#4-存在的问题" class="headerlink" title="4. 存在的问题"></a>4. 存在的问题</h1><p>但是上面 G 的 <strong>loss function</strong> 还是有一点小问题，下图是两个函数的图像：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/15.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDml8g67H6N2vV8WVtK9NgYcUpQh1YiFxW&amp;q-sign-time=1541591940;1541593740&amp;q-key-time=1541591940;1541593740&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=7abf97829c9ec11526dd4fb4c2e34b5cac355a9a&amp;x-cos-security-token=51e13b9e423947fe7ea45e313979f9c49369673e10001&amp;response-content-disposition=attachment" alt=""></div></p><p>log(1-D(x)) 是我们计算时 G 的 loss function，但是我们发现，在 D(x) 接近于 0 的时候，这个函数十分平滑，梯度非常的小。这就会导致，在训练的初期，G 想要骗过 D，变化十分的缓慢，而上面的函数，趋势和下面的是一样的，都是递减的。但是它的优势是在 D(x) 接近 0 的时候，梯度很大，有利于训练，在 D(x) 越来越大之后，梯度减小，这也很符合实际，在初期应该训练速度更快，到后期速度减慢。</p><p>所以我们把 G 的 loss function 修改为<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/16.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDL1vRXMGF214YXXnWgbGCxwtATePB1OGs&amp;q-sign-time=1541591918;1541593718&amp;q-key-time=1541591918;1541593718&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=767c97e63d0a6a72ccb0fcdea432fd60d47d3db6&amp;x-cos-security-token=dcc01eb725a87df948d2cade4658bf92d80f473e10001&amp;response-content-disposition=attachment" alt=""></div></p><p>这样可以提高训练的速度。</p><p>还有一个问题，在其他 paper 中提出，就是经过实验发现，经过许多次训练，loss 一直都是平的，也就是<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/17.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDLkOy5N24dxJQZPCY5FVRXCIStdOachPP&amp;q-sign-time=1541591968;1541593768&amp;q-key-time=1541591968;1541593768&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=5df5e128bf9953d96c105e03f559a8745a709220&amp;x-cos-security-token=191089cbdcd62a0d62a5f1ef92a03a50e40d4a1710001&amp;response-content-disposition=attachment" alt=""></div></p><p>JS divergence 一直都是 log2，PG 和 Pdata 完全没有交集，但是实际上两个分布是有交集的，造成这个的原因是因为，我们无法真正计算期望和积分，只能使用 sample 的方法，如果训练的过拟合了，D 还是能够完全把两部分的点分开，如下图：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/18.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDhHDqGGeTbNLhM4qq3t2Ipn4KKVVwmXLU&amp;q-sign-time=1541591993;1541593793&amp;q-key-time=1541591993;1541593793&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=cf022121831240dddf3385e533f6640c77805618&amp;x-cos-security-token=7ae0a2c729b0eb71f2c9a8e7015e58170aadd2a210001&amp;response-content-disposition=attachment" alt=""></div></p><p>对于这个问题，我们是否应该让 D 变得弱一点，减弱它的分类能力，但是从理论上讲，为了让它能够有效的区分真假图片，我们又希望它能够 powerful，所以这里就产生了矛盾。</p><p>还有可能的原因是，虽然两个分布都是高维的，但是两个分布都十分的窄，可能交集相当小，这样也会导致 <strong>JS divergence</strong> 算出来 =log2，约等于没有交集。</p><p>解决的一些方法，有添加噪声，让两个分布变得更宽，可能可以增大它们的交集，这样 JS divergence 就可以计算，但是随着时间变化，噪声需要逐渐变小。</p><p>还有一个问题叫 <strong>Mode Collapse</strong>，如下图：<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/19.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDGwuroT10H75imvVIq9VmZ2c1yVinWQy3&amp;q-sign-time=1541592013;1541593813&amp;q-key-time=1541592013;1541593813&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=80221ba3513178daf7fec817a0f292f0e3b4125f&amp;x-cos-security-token=5e03cae7040c2a8bb24fede9f72ed0d9c08bc0d710001&amp;response-content-disposition=attachment" alt=""></div></p><p>这个图的意思是，data 的分布是一个双峰的，但是学习到的生成分布却只有单峰，我们可以看到模型学到的数据，但是却不知道它没有学到的分布。</p><p>造成这个情况的原因是，KL divergence 里的两个分布写反了<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/hexo-GAN/image/20.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDznzX4HpBlsNpwXDzZt088AiUaagX7MwT&amp;q-sign-time=1541592029;1541593829&amp;q-key-time=1541592029;1541593829&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=2a8d20d8af2fc6153d329a541ea90c49791a387b&amp;x-cos-security-token=692829b819dba91d595a5da3a88ab271030b35d910001&amp;response-content-disposition=attachment" alt=""></div></p><p>这个图很清楚的显示了，如果是第一个 KL divergence 的写法，为了防止出现无穷大，所以有 Pdata 出现的地方都必须要有 PG 覆盖，就不会出现 Mode Collapse。</p><hr><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><p>这是对 GAN 入门学习做的一些笔记和理解，后来太懒了，不想打公式了，主要是参考了李宏毅老师的视频：<a href="https://www.bilibili.com/video/av24011528/?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av24011528/?p=1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Generative Adversarial Network&lt;/strong&gt;，就是大家耳熟能详的 &lt;strong&gt;GAN&lt;/strong&gt;，由 Ian Goodfellow 首先提出，在这两年更是深度学习中最热门的东西，仿佛什么东西都能由 GAN 做出来。
      
    
    </summary>
    
      <category term="深度学习" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GAN" scheme="https://xhjiang.tech/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/GAN/"/>
    
    
      <category term="深度学习" scheme="https://xhjiang.tech/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GAN" scheme="https://xhjiang.tech/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>linux基础第六天</title>
    <link href="https://xhjiang.tech/2018/10/29/linux%E5%9F%BA%E7%A1%80%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>https://xhjiang.tech/2018/10/29/linux基础第六天/</id>
    <published>2018-10-29T10:13:48.000Z</published>
    <updated>2018-10-29T12:13:44.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><hr><p>本篇博文就是这次linux系统学习的最后一篇了，之前我们学习了<strong>常用 Linux 命令的基本使用，文件和目录常用命令,远程管理常用命令,用户权限常用命令</strong>还有<strong>系统信息相关命令</strong>。<br>由于这篇博文要学习的东西不太好分类，所以我们把这部分学习的内容统一划分为<strong>其他命令</strong><br><br></p><hr><p><strong>目标</strong></p><ul><li><p>查找文件</p><ul><li><code>find</code></li></ul></li><li><p>软链接</p><ul><li><code>ln</code></li></ul></li><li><p>打包和压缩</p><ul><li><code>tar</code></li></ul></li><li><p>软件安装</p><ul><li><code>apt-get</code></li></ul></li></ul><hr><h2 id="01-查找文件"><a href="#01-查找文件" class="headerlink" title="01. 查找文件"></a>01. 查找文件</h2><ul><li><code>find</code> 命令功能非常强大，通常用来在 <strong>特定的目录下 搜索</strong> 符合条件的文件</li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>find [路径] -name “*.py”</td><td>查找指定路径下扩展名是 .py 的文件，包括子目录</td></tr></tbody></table><ul><li><p>如果省略路径，表示在当前文件夹下查找</p></li><li><p>之前学习的通配符，在使用 <code>find</code> 命令时同时可用</p></li><li><p>有关 <code>find</code> 的高级使用，在就业班会讲</p></li></ul><p><strong>演练目标</strong></p><ol><li>搜索桌面目录下，文件名包含 <code>1</code> 的文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;*1*&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>搜索桌面目录下，所有以 <code>.txt</code> 为扩展名的文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>搜索桌面目录下，以数字 <code>1</code> 开头的文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;1*&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="02-软链接"><a href="#02-软链接" class="headerlink" title="02. 软链接"></a>02. 软链接</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ln -s 被链接的源文件 链接文件</td><td>建立文件的软链接，用通俗的方式讲<strong>类似于</strong> Windows 下的<strong>快捷方式</strong></td></tr></tbody></table><p><em>注意：</em></p><ul><li><p>没有 <code>-s</code> 选项建立的是一个 <strong>硬链接文件</strong></p></li><li><p>两个文件占用相同大小的硬盘空间，<strong>工作中几乎不会建立文件的硬链接</strong></p></li><li><p><strong>源文件要使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</p></li></ul><p><strong>演练目标</strong></p><ol><li><p>将桌面目录下的 <code>01.py</code> 移动到 <code>demo/b/c</code> 目录下</p></li><li><p>在桌面目录下新建 <code>01.py</code> 的 软链接 <code>FirstPython</code>,分别使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 建立 <code>FirstPython</code> 的软链接</p></li><li><p>将 <code>FirstPython</code> 移动到 <code>demo</code> 目录下，对比使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 的区别</p></li></ol><p><strong>硬链接简介（知道）</strong></p><ul><li>在使用 <code>ln</code> 创建链接时，如果没有 <code>-s</code> 选项，会创建一个 <strong>硬链接</strong>，而不是软链接</li></ul><p><strong>硬链接演练</strong></p><ol><li><p>在 <code>~/Desktop/demo</code> 目录下建立 <code>~/Desktop/demo/b/c/01.py</code> 的硬链接 <code>01_hard</code></p></li><li><p>使用 <code>ls -l</code> 查看文件的<strong>硬链接数</strong>（硬链接——有多少种方式可以访问文件或者目录）</p></li><li><p>删除<code>~/Desktop/demo/b/c/01.py</code>，并且使用 <code>tree</code> 来确认 <code>demo</code> 目录下的三个链接文件</p></li></ol><blockquote><p><em>在 Linux 中，<strong>文件名</strong> 和 <strong>文件的数据</strong> 是分开存储的</em></p></blockquote><ul><li><p><em>提示：</em></p></li><li><p>在 Linux 中，只有文件的 <code>硬链接数 == 0</code> 才会被删除</p></li><li><p>使用 <code>ls -l</code> 可以查看一个文件的硬链接的数量</p></li><li><p>在日常工作中，几乎不会建立文件的硬链接，知道即可</p></li></ul><hr><h2 id="03-打包压缩"><a href="#03-打包压缩" class="headerlink" title="03. 打包压缩"></a>03. 打包压缩</h2><ul><li><p><strong>打包压缩</strong> 是日常工作中备份文件的一种方式</p></li><li><p>在不同操作系统中，常用的打包压缩方式是不同的</p><ul><li><p><code>Windows</code> 常用 <code>rar</code></p></li><li><p><code>Mac</code> 常用 <code>zip</code></p></li><li><p><code>Linux</code> 常用 <code>tar.gz</code></p></li></ul></li></ul><h3 id="3-1-打包-／-解包"><a href="#3-1-打包-／-解包" class="headerlink" title="3.1 打包 ／ 解包"></a>3.1 打包 ／ 解包</h3><ul><li><p><code>tar</code> 是 Linux 中最常用的 <strong>备份工具</strong>，此命令可以 <strong>把一系列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一系列文件</strong></p></li><li><p><code>tar</code> 的命令格式如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 打包文件</span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件／路径...</span><br><span class="line"></span><br><span class="line"># 解包文件</span><br><span class="line">tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure><ul><li><code>tar</code> 选项说明</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>x</td><td>解开档案文件</td></tr><tr><td>v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>f</td><td>指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</td></tr></tbody></table><blockquote><p><em>注意：<code>f</code> 选项必须放在最后，其他选项顺序可以随意</em></p></blockquote><p><strong>打包解包演练*</strong></p><ol><li><p>删除桌面下的所有内容</p></li><li><p>在桌面下新建三个空白文件 <code>01.py</code>、<code>02.py</code>、<code>03.py</code></p></li><li><p>将这三个文件打一个 <code>py.tar</code> 的包</p></li><li><p>新建 <code>tar</code> 目录，并且将 <code>py.tar</code> 移动到 <code>tar</code> 目录下</p></li><li><p>解包 <code>py.tar</code></p></li></ol><h3 id="3-2-压缩／解压缩"><a href="#3-2-压缩／解压缩" class="headerlink" title="3.2 压缩／解压缩"></a>3.2 压缩／解压缩</h3><p><strong>1) gzip</strong></p><ul><li><p><code>tar</code> 与 <code>gzip</code> 命令结合可以使用实现文件 打包和压缩</p><ul><li><p><code>tar</code> 只负责打包文件，但不压缩</p></li><li><p>用 <code>gzip</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.gz</code></p></li></ul></li></ul><blockquote><p>在 <code>Linux</code> 中，最常见的压缩文件格式就是 <code>xxx.tar.gz</code></p></blockquote><ul><li><p>在 <code>tar</code> 命令中有一个选项 <code>-z</code> 可以调用 <code>gzip</code>，从而可以方便的实现压缩和解压缩的功能</p></li><li><p>命令格式如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 压缩文件</span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"># 解压缩文件</span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压缩到指定路径</span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-C</td><td>解压缩到指定目录，注意：要解压缩的目录必须存在</td></tr></tbody></table><p><strong>2) bzip2(two)</strong></p><ul><li><p><code>tar</code> 与 <code>bzip2</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong>（用法和 <code>gzip</code> 一样）</p><ul><li><p><code>tar</code> 只负责打包文件，但不压缩，</p></li><li><p>用 <code>bzip2</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.bz2</code></p></li></ul></li><li><p>在 <code>tar</code> 命令中有一个选项 <code>-j</code> 可以调用 <code>bzip2</code>，从而可以方便的实现压缩和解压缩的功能</p></li><li><p>命令格式如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 压缩文件</span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"># 解压缩文件</span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br></pre></td></tr></table></figure><hr><h2 id="04-软件安装"><a href="#04-软件安装" class="headerlink" title="04. 软件安装"></a>04. 软件安装</h2><h3 id="4-1-通过-apt-安装／卸载软件"><a href="#4-1-通过-apt-安装／卸载软件" class="headerlink" title="4.1 通过 apt 安装／卸载软件"></a>4.1 通过 apt 安装／卸载软件</h3><ul><li><code>apt</code> 是 <code>Advanced Packaging Tool</code>，是 Linux 下的一款安装包管理工具<br>可以在终端中方便的 <strong>安装／卸载／更新软件包</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 安装软件</span><br><span class="line">$ sudo apt install 软件包</span><br><span class="line"></span><br><span class="line"># 2. 卸载软件</span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"># 3. 更新已安装的包</span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure><p><strong>安装演练</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 一个小火车提示</span><br><span class="line">$ sudo apt install sl</span><br><span class="line"></span><br><span class="line"># 一个比较漂亮的查看当前进程排名的软件</span><br><span class="line">$ sudo apt install htop</span><br></pre></td></tr></table></figure><h3 id="4-2-配置软件源"><a href="#4-2-配置软件源" class="headerlink" title="4.2 配置软件源"></a>4.2 配置软件源</h3><ul><li><p>如果希望在 <code>ubuntu</code> 中安装软件，<strong>更加快速</strong>，可以通过设置<strong>镜像源</strong>，选择一个访问网速更快的服务器，来提供软件下载／安装服务</p></li><li><p>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</p></li></ul><blockquote><p><em>所谓镜像源，就是<strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，国内服务器通常速度会更快一些！</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;其他命令&quot;&gt;&lt;a href=&quot;#其他命令&quot; class=&quot;headerlink&quot; title=&quot;其他命令&quot;&gt;&lt;/a&gt;其他命令&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;本篇博文就是这次linux系统学习的最后一篇了，之前我们学习了&lt;strong&gt;常用 Linux 命令的基本使用，文
      
    
    </summary>
    
      <category term="Linux操作系统" scheme="https://xhjiang.tech/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://xhjiang.tech/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux基础第五天</title>
    <link href="https://xhjiang.tech/2018/10/29/linux%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <id>https://xhjiang.tech/2018/10/29/linux基础第五天/</id>
    <published>2018-10-29T10:13:37.000Z</published>
    <updated>2018-10-29T12:16:14.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h1><hr><ul><li><p>本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 <strong>系统日期和时间 ／ 磁盘空间占用情况 ／ 程序执行情况</strong></p></li><li><p>本小结学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解<br><br></p></li></ul><hr><p><strong>目标</strong></p><ul><li><p>时间和日期</p><ul><li><code>date</code></li><li><code>cal</code></li></ul></li><li><p>磁盘和目录空间</p><ul><li><code>df</code></li><li><code>du</code></li></ul></li><li><p>进程信息</p><ul><li><code>ps</code></li><li><code>top</code></li><li><code>kill</code></li></ul></li></ul><hr><h2 id="01-时间和日期"><a href="#01-时间和日期" class="headerlink" title="01. 时间和日期"></a>01. 时间和日期</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>date</td><td>查看系统时间</td></tr><tr><td>02</td><td>cal</td><td>calendar 查看日历，-y 选项可以查看一年的日历</td></tr></tbody></table><hr><h2 id="02-磁盘信息"><a href="#02-磁盘信息" class="headerlink" title="02. 磁盘信息"></a>02. 磁盘信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>df -h</td><td>disk free 显示磁盘剩余空间</td></tr><tr><td>02</td><td>du -h [目录名]</td><td>disk usage 显示目录下的文件大小</td></tr></tbody></table><p><strong>选项说明</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-h</td><td>以人性化的方式显示文件大小</td></tr></tbody></table><hr><h2 id="03-进程信息"><a href="#03-进程信息" class="headerlink" title="03. 进程信息"></a>03. 进程信息</h2><ul><li>所谓 <strong>进程</strong>，通俗地说就是 <strong>当前正在执行的一个程序</strong></li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ps aux</td><td>process status 查看进程的详细状况</td></tr><tr><td>02</td><td>top</td><td>动态显示运行中的进程并且排序</td></tr><tr><td>03</td><td>kill [-9] 进程代号</td><td>终止指定代号的进程，-9 表示强行终止</td></tr></tbody></table><blockquote><p><code>ps</code> 默认只会显示当前用户通过终端启动的应用程序</p></blockquote><ul><li><code>ps</code> 选项说明功能</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr></tbody></table><blockquote><p><em>提示：使用 <code>kill</code> 命令时，最好只终止由当前用户开启的进程，而不要终止 <code>root</code> 身份开启的进程，否则可能导致系统崩溃</em></p><ul><li>要退出 <code>top</code> 可以直接输入 <code>q</code></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统信息相关命令&quot;&gt;&lt;a href=&quot;#系统信息相关命令&quot; class=&quot;headerlink&quot; title=&quot;系统信息相关命令&quot;&gt;&lt;/a&gt;系统信息相关命令&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前
      
    
    </summary>
    
      <category term="Linux操作系统" scheme="https://xhjiang.tech/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://xhjiang.tech/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux基础第四天</title>
    <link href="https://xhjiang.tech/2018/10/29/linux%E5%9F%BA%E7%A1%80%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <id>https://xhjiang.tech/2018/10/29/linux基础第四天/</id>
    <published>2018-10-29T10:13:26.000Z</published>
    <updated>2018-10-29T12:17:15.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户权限相关命令"><a href="#用户权限相关命令" class="headerlink" title="用户权限相关命令"></a>用户权限相关命令</h1><hr><p>本篇博文主要介绍了linux系统中用户权限的相关命令，其中包括了<strong>用户管理</strong>以及<strong>组管理</strong>，此外还介绍了<strong>修改权限</strong>的操作，跟Windows操作系统中的用户管理还是大为不同的。<br><br></p><hr><p><strong>目标</strong></p><ul><li><strong>用户</strong> 和 <strong>权限</strong> 的基本概念</li><li><strong>用户管理</strong> 终端命令</li><li><strong>组管理</strong> 终端命令</li><li><strong>修改权限</strong> 终端命令</li></ul><hr><h2 id="01-用户-和-权限-的基本概念"><a href="#01-用户-和-权限-的基本概念" class="headerlink" title="01. 用户 和 权限 的基本概念"></a>01. 用户 和 权限 的基本概念</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul><li><p><strong>用户</strong> 是 Linux 系统工作中重要的一环，用户管理包括 <strong>用户</strong> 与 <strong>组</strong> 管理</p></li><li><p>在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须<strong>拥有一个账号，并且对于不同的系统资源拥有不同的使用权限</strong></p></li><li><p>在 Linux 中，可以指定 <strong>每一个用户</strong> 针对 <strong>不同的文件或者目录 的</strong> 不同权限</p></li><li><p>对 文件／目录 的权限包括：</p></li></ul><table><thead><tr><th>序号</th><th>权限</th><th>英文</th><th>缩写</th><th>数字代号</th></tr></thead><tbody><tr><td>01</td><td>读</td><td>read</td><td>r</td><td>4</td></tr><tr><td>02</td><td>写</td><td>write</td><td>w</td><td>2</td></tr><tr><td>03</td><td>执行</td><td>excute</td><td>x</td><td>1</td></tr></tbody></table><h3 id="1-2-组"><a href="#1-2-组" class="headerlink" title="1.2 组"></a>1.2 组</h3><ul><li>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限</strong></li></ul><h3 id="1-3-ls-l-扩展"><a href="#1-3-ls-l-扩展" class="headerlink" title="1.3 ls -l 扩展"></a>1.3 ls -l 扩展</h3><ul><li><p><code>ls -l</code> 可以查看文件夹下文件的详细信息，从左到右依次是：</p></li><li><p>权限，第 1 个字符如果是 <code>d</code> 表示目录</p></li><li>硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件</li><li>拥有者，家目录下 文件／目录 的拥有者通常都是当前用户</li><li>组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲</li><li>大小</li><li>时间</li><li>名称</li></ul><h3 id="1-4-chmod-简单使用（重要）"><a href="#1-4-chmod-简单使用（重要）" class="headerlink" title="1.4 chmod 简单使用（重要）"></a>1.4 chmod 简单使用（重要）</h3><ul><li><p><code>chmod</code> 可以修改 <strong>用户／组</strong> 对 <strong>文件／目录</strong> 的权限</p></li><li><p>命令格式如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><blockquote><p><em>提示：</em>以上方式会一次性修改 <code>拥有者</code> / <code>组</code> 权限，有关 <code>chmod</code> 的高级用法，后续会讲</p></blockquote><h3 id="1-5-超级用户"><a href="#1-5-超级用户" class="headerlink" title="1.5 超级用户"></a>1.5 超级用户</h3><ul><li><p>Linux 系统中的 <code>root</code> 账号通常 <strong>用于系统的维护和管理</strong>，对操作系统的所有资源 <strong>具有所有访问权限</strong></p></li><li><p>在大多数版本的 Linux 中，都不推荐 <strong>直接使用 root 账号登录系统</strong></p></li><li><p>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</p></li></ul><p><strong>sudo</strong></p><ul><li><p><code>su</code> 是 <code>substitute user</code> 的缩写，表示 <strong>使用另一个用户的身份</strong></p></li><li><p><code>sudo</code> 命令用来以其他身份来执行命令，预设的身份为 <code>root</code></p></li><li><p>用户使用 <code>sudo</code> 时，必须先输入密码，之后有 <strong>5 分钟的有效期限</strong>，超过期限则必须重新输入密码</p></li></ul><blockquote><p><em>若其未经授权的用户企图使用 <code>sudo</code>，则会发出警告邮件给管理员</em></p></blockquote><hr><h2 id="02-组管理-终端命令"><a href="#02-组管理-终端命令" class="headerlink" title="02. 组管理 终端命令"></a>02. 组管理 终端命令</h2><blockquote><p><em>提示：<strong>创建组 / 删除组</strong> 的终端命令都需要通过 <code>sudo</code> 执行</em></p></blockquote><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>groupadd 组名</td><td>添加组</td></tr><tr><td>02</td><td>groupdel 组名</td><td>删除组</td></tr><tr><td>03</td><td>cat /etc/group</td><td>确认组信息</td></tr><tr><td>04</td><td>chgrp -R 组名 文件/目录名</td><td>递归修改文件/目录的所属组</td></tr></tbody></table><blockquote><p><em>提示：</em></p><ul><li><p>组信息保存在 <code>/etc/group</code> 文件中</p></li><li><p><code>/etc</code> 目录是专门用来保存 <strong>系统配置信息</strong> 的目录</p></li></ul></blockquote><ul><li>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></li></ul><p><strong>演练目标</strong></p><ol><li>在 <code>python</code> 用户的桌面文件夹下创建 <code>Python学习</code> 目录</li><li>新建 <code>dev</code> 组</li><li>将 <code>Python学习</code> 目录的组修改为 dev</li></ol><hr><h2 id="03-用户管理-终端命令"><a href="#03-用户管理-终端命令" class="headerlink" title="03. 用户管理 终端命令"></a>03. 用户管理 终端命令</h2><blockquote><p><em>提示：<strong>创建用户 / 删除用户 / 修改其他用户密码</strong> 的终端命令都需要通过 <code>sudo</code> 执行</em></p></blockquote><h3 id="3-1-创建用户／设置密码／删除用户"><a href="#3-1-创建用户／设置密码／删除用户" class="headerlink" title="3.1 创建用户／设置密码／删除用户"></a>3.1 创建用户／设置密码／删除用户</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>useradd -m -g 组 新建用户名</td><td>添加新用户</td><td>-m 自动建立用户家目录;<br>  -g 指定用户所在的组，否则会建立一个和同名的组</td></tr><tr><td>02</td><td>passwd 用户名</td><td>设置用户密码</td><td>如果是普通用户，直接用 passwd 可以修改自己的账户密码</td></tr><tr><td>03</td><td>userdel -r 用户名</td><td>删除用户    -r 选项会自动删除用户家目录</td></tr><tr><td>04</td><td>cat /etc/passwd \</td><td>grep</td><td>用户名    确认用户信息</td><td>新建用户后，用户信息会保存在 /etc/passwd 文件中</td></tr></tbody></table><blockquote><p><em>提示：</em></p><ul><li><p>创建用户时，如果忘记添加 <code>-m</code> 选项指定新用户的家目录 —— 最简单的方法就是<strong>删除用户，重新创建</strong></p></li><li><p>创建用户时，默认会创建一个和用户名同名的组名</p></li><li><p>用户信息保存在 <code>/etc/passwd</code> 文件中</p></li></ul></blockquote><h3 id="3-2-查看用户信息"><a href="#3-2-查看用户信息" class="headerlink" title="3.2 查看用户信息"></a>3.2 查看用户信息</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>id [用户名]</td><td>查看用户 UID 和 GID 信息</td></tr><tr><td>02</td><td>who</td><td>查看当前所有登录的用户列表</td></tr><tr><td>03</td><td>whoami</td><td>查看当前登录用户的账户名</td></tr></tbody></table><p><strong>passwd 文件</strong></p><p><code>/etc/passwd</code> 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是</p><ol><li><p>用户名</p></li><li><p>密码（x，表示加密的密码）</p></li><li><p>UID（用户标识）</p></li><li><p>GID（组标识）</p></li><li><p>用户全名或本地帐号</p></li><li><p>家目录</p></li><li><p>登录使用的 Shell，就是登录之后，使用的终端命令，<code>ubuntu</code> 默认是 <code>dash</code></p></li></ol><p><strong>usermod</strong></p><ul><li><p><code>usermod</code> 可以用来设置 <strong>用户</strong> 的 <strong>主组 ／ 附加组</strong> 和 <strong>登录 Shell</strong>，命令格式如下：</p></li><li><p><strong>主组：</strong>通常在新建用户时指定，在 <code>etc/passwd</code> 的第 4 列 <strong>GID 对应的组</strong></p></li><li><p><strong>附加组：</strong>在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定 <strong>用户的附加权限</strong></p></li></ul><blockquote><p><em>提示：设置了用户的附加组之后，需要重新登录才能生效！</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改用户的主组（passwd 中的 GID）</span><br><span class="line">usermod -g 组 用户名</span><br><span class="line"></span><br><span class="line"># 修改用户的附加组</span><br><span class="line">usermod -G 组 用户名</span><br><span class="line"></span><br><span class="line"># 修改用户登录 Shell</span><br><span class="line">usermod -s /bin/bash 用户名</span><br></pre></td></tr></table></figure><blockquote><p><em>注意：默认使用 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，可以使用以下命令，将用户添加到 <code>sudo</code> 附加组中</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure><p><strong>which（重要）</strong></p><blockquote><p><em>提示:</em></p><ul><li><p><code>/etc/passwd</code> 是用于保存用户信息的文件</p></li><li><p><code>/usr/bin/passwd</code> 是用于修改用户密码的程序</p></li></ul></blockquote><ul><li><code>which</code> 命令可以查看执行命令所在位置，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">which ls</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"># /bin/ls</span><br><span class="line"></span><br><span class="line">which useradd</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"># /usr/sbin/useradd</span><br></pre></td></tr></table></figure><p><strong>bin 和 sbin</strong></p><ul><li><p>在 <code>Linux</code> 中，绝大多数可执行文件都是保存在 <code>/bin</code>、<code>/sbin</code>、<code>/usr/bin</code>、<code>/usr/sbin</code></p></li><li><p><code>/bin（binary）</code>是二进制执行文件目录，主要用于具体应用</p></li><li><p><code>/sbin（system binary）</code>是系统管理员专用的二进制代码存放目录，主要用于系统管理</p></li><li><p><code>/usr/bin（user commands for applications）</code>后期安装的一些软件</p></li><li><p><code>/usr/sbin（super user commands for applications）</code>超级用户的一些管理程序</p></li></ul><blockquote><p><em>提示：</em></p><ul><li><code>cd</code> 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 <code>which</code> 无法找到 <code>cd</code> 命令的位置*</li></ul></blockquote><h3 id="3-3-切换用户"><a href="#3-3-切换用户" class="headerlink" title="3.3 切换用户"></a>3.3 切换用户</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>su - 用户名</td><td>切换用户，并且切换目录</td><td>- 可以切换到用户家目录，否则保持位置不变</td></tr><tr><td>02</td><td>exit</td><td>退出当前登录账户    </td></tr></tbody></table><ul><li><code>su</code> 不接用户名，可以切换到 <code>root</code>，但是不推荐使用，因为不安全</li></ul><h2 id="04-修改文件权限"><a href="#04-修改文件权限" class="headerlink" title="04. 修改文件权限"></a>04. 修改文件权限</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>chown</td><td>修改拥有者</td></tr><tr><td>02</td><td>chgrp</td><td>修改组</td></tr><tr><td>03</td><td>chmod</td><td>修改权限</td></tr></tbody></table><ul><li>命令格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改文件|目录的拥有者</span><br><span class="line">chown 用户名 文件名|目录名</span><br><span class="line"></span><br><span class="line"># 递归修改文件|目录的组</span><br><span class="line">chgrp -R 组名 文件名|目录名</span><br><span class="line"></span><br><span class="line"># 递归修改文件权限</span><br><span class="line">chmod -R 755 文件名|目录名</span><br></pre></td></tr></table></figure><ul><li><code>chmod</code> 在设置权限时，可以简单地使用三个数字分别对应 <strong>拥有者 ／ 组</strong> 和 <strong>其他</strong> 用户的权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他</span><br><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><ul><li><p>常见数字组合有（<code>u</code>表示用户／<code>g</code>表示组／<code>o</code>表示其他）：</p><ul><li><p>777 ===&gt; u=rwx,g=rwx,o=rwx</p></li><li><p>755 ===&gt; u=rwx,g=rx,o=rx</p></li><li><p>644 ===&gt; u=rw,g=r,o=r</p></li></ul></li></ul><p><strong>chmod 演练目标</strong></p><ol><li><p>将 <code>01.py</code> 的权限修改为 <code>u=rwx,g=rx,o=r</code></p></li><li><p>将 <code>123.txt</code> 的权限修改为 <code>u=rw,g=r,o=-</code></p></li><li><p>将 <code>test</code> 目录以及目录下的 <strong>所有</strong> 文件权限修改为 <code>u=rwx,g=rwx,o=rx</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用户权限相关命令&quot;&gt;&lt;a href=&quot;#用户权限相关命令&quot; class=&quot;headerlink&quot; title=&quot;用户权限相关命令&quot;&gt;&lt;/a&gt;用户权限相关命令&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;本篇博文主要介绍了linux系统中用户权限的相关命令，其中包括了&lt;strong&gt;用
      
    
    </summary>
    
      <category term="Linux操作系统" scheme="https://xhjiang.tech/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://xhjiang.tech/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux基础第三天</title>
    <link href="https://xhjiang.tech/2018/10/29/linux%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <id>https://xhjiang.tech/2018/10/29/linux基础第三天/</id>
    <published>2018-10-29T08:13:39.000Z</published>
    <updated>2018-10-29T12:17:08.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程管理常用命令"><a href="#远程管理常用命令" class="headerlink" title="远程管理常用命令"></a>远程管理常用命令</h1><hr><p>今天继续学习linux基础,本篇博文主要详细描述了关于linux系统的<strong>远程管理常用命令</strong>，下面介绍一下今天的主要学习目标：<br><br><br><br></p><hr><p><strong>目标</strong></p><ul><li><p>关机/重启</p><ul><li><code>shutdown</code></li></ul></li><li><p>查看或配置网卡信息</p><ul><li><code>ifconfig</code></li><li><code>ping</code></li></ul></li><li><p>远程登录和复制文件</p><ul><li><code>ssh</code></li><li><code>scp</code></li></ul></li></ul><hr><h2 id="01-关机-重启"><a href="#01-关机-重启" class="headerlink" title="01. 关机/重启"></a>01. 关机/重启</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>shutdown 选项 时间</td><td>shutdown</td><td>关机／重新启动</td></tr></tbody></table><h3 id="1-1-shutdown"><a href="#1-1-shutdown" class="headerlink" title="1.1 shutdown"></a>1.1 shutdown</h3><ul><li><code>shutdown</code>命令可以<strong>安全 关闭</strong> 或者 <strong>重新启动系统</strong></li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>重新启动</td></tr></tbody></table><blockquote><p><em>提示:</em></p><ul><li>不指定选项和参数，默认表示 1 分钟之后 关闭电脑</li><li>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</li></ul></blockquote><ul><li>常用命令示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 重新启动操作系统，其中 now 表示现在</span><br><span class="line">$ shutdown -r now</span><br><span class="line"></span><br><span class="line"># 立刻关机，其中 now 表示现在</span><br><span class="line">$ shutdown now</span><br><span class="line"></span><br><span class="line"># 系统在今天的 20:25 会关机</span><br><span class="line">$ shutdown 20:25</span><br><span class="line"></span><br><span class="line"># 系统再过十分钟后自动关机</span><br><span class="line">$ shutdown +10</span><br><span class="line"></span><br><span class="line"># 取消之前指定的关机计划</span><br><span class="line">$ shutdown -c</span><br></pre></td></tr></table></figure><hr><h2 id="02-查看或配置网卡信息"><a href="#02-查看或配置网卡信息" class="headerlink" title="02. 查看或配置网卡信息"></a>02. 查看或配置网卡信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ifconfig</td><td>configure a network interface</td><td>查看/配置计算机当前的网卡配置信息</td></tr><tr><td>02</td><td>ping ip地址</td><td>ping</td><td>检测到目标 ip地址 的连接是否正常</td></tr></tbody></table><h3 id="2-1-网卡-和-IP-地址"><a href="#2-1-网卡-和-IP-地址" class="headerlink" title="2.1 网卡 和 IP 地址"></a>2.1 网卡 和 IP 地址</h3><p><strong>网卡</strong></p><ul><li>网卡是一个专门负责网络通讯的硬件设备</li><li><strong>IP 地址</strong>是设置在网卡上的地址信息<blockquote><p><em>我们可以把 <strong>电脑</strong> 比作 <strong>电话</strong>，<strong>网卡</strong> 相当于 <strong>SIM 卡</strong>，<strong>IP 地址</strong> 相当于 <strong>电话号码</strong></em></p></blockquote></li></ul><p><strong>IP 地址</strong></p><ul><li><strong>每台联网的电脑上</strong>都有 <strong>IP 地址</strong>，<strong>是保证电脑之间正常通讯的重要设置</strong><blockquote><p><em>注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯</em></p></blockquote></li></ul><h3 id="2-2-ifconfig"><a href="#2-2-ifconfig" class="headerlink" title="2.2 ifconfig"></a>2.2 ifconfig</h3><ul><li><code>ifconfig</code> 可以查看／配置计算机当前的网卡配置信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看网卡配置信息</span><br><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line"># 查看网卡对应的 IP 地址</span><br><span class="line">$ ifconfig | grep inet</span><br></pre></td></tr></table></figure><blockquote><p><em>提示：一台计算机中有可能会有一个 <strong>物理网卡</strong> 和 <strong>多个虚拟网卡</strong>，在 Linux 中物理网卡的名字通常以 <code>ensXX</code> 表示</em></p></blockquote><ul><li><code>127.0.0.1</code> 被称为 <strong>本地回环/环回地址</strong>，一般用来测试本机网卡是否正常</li></ul><h3 id="2-3-ping"><a href="#2-3-ping" class="headerlink" title="2.3 ping"></a>2.3 ping</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 检测到目标主机是否连接正常</span><br><span class="line">$ ping IP地址</span><br><span class="line"></span><br><span class="line"># 检测本地网卡工作正常</span><br><span class="line">$ ping 127.0.0.1</span><br></pre></td></tr></table></figure><ul><li><code>ping</code> 一般用于检测当前计算机到目标计算机之间的网络 <strong>是否通畅，数值越大，速度越慢</strong><blockquote><ul><li><code>ping</code> 的工作原理与潜水艇的声纳相似，<code>ping</code> 这个命令就是取自 <strong>声纳的声音</strong></li><li>网络管理员之间也常将 <code>ping</code> 用作动词 —— <strong>ping 一下计算机X，看他是否开着</strong></li></ul></blockquote></li></ul><p>原理：网络上的机器都有 <strong>唯一确定的 IP 地址</strong>，我们给<strong>目标 IP 地址</strong>发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</p><blockquote><p><em>提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 <code>CTRL + C</code></em></p></blockquote><hr><h2 id="03-远程登录和复制文件"><a href="#03-远程登录和复制文件" class="headerlink" title="03. 远程登录和复制文件"></a>03. 远程登录和复制文件</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ssh 用户名@ip</td><td>secure shell</td><td>关机／重新启动</td></tr><tr><td>02</td><td>scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径</td><td>secure copy</td><td>远程复制文件</td></tr></tbody></table><h3 id="3-1-ssh-基础（重点）"><a href="#3-1-ssh-基础（重点）" class="headerlink" title="3.1 ssh 基础（重点）"></a>3.1 ssh 基础（重点）</h3><p>在 Linux 中 SSH 是 <strong>非常常用</strong> 的工具，通过 <strong>SSH 客户端</strong> 我们可以连接到运行了 <strong>SSH 服务器</strong> 的远程机器上</p><ul><li><strong>SSH 客户端</strong>是一种使用 <code>Secure Shell（SSH）</code> 协议连接到远程计算机的软件程序</li><li><code>SSH</code> 是目前较可靠，<strong>专为远程登录会话和其他网络服务</strong> 提供安全性的协议<ul><li>利用 <code>SSH 协议</code> 可以有效<strong>防止远程管理过程中的信息泄露</strong></li><li>通过 <code>SSH 协议</code> 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗</li></ul></li><li><code>SSH</code> 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度</li></ul><p><strong>1) 域名 和 端口号</strong></p><p><strong>域名</strong></p><ul><li>由一串 <strong>用点分隔</strong> 的名字组成，例如：<code>www.itcast.cn</code></li><li>是 <strong>IP 地址</strong> 的别名，方便用户记忆</li></ul><p><strong>端口号</strong></p><ul><li><strong>IP 地址：</strong>通过 <strong>IP 地址</strong> 找到网络上的 计算机</li><li><p><strong>端口号：</strong>通过 <strong>端口号</strong> 可以找到 <strong>计算机上运行的应用程序</strong></p><ul><li><strong>SSH 服务器</strong> 的默认端口号是 <code>22</code>，如果是默认端口号，在连接的时候，可以省略</li></ul></li><li><p>常见服务端口号列表：</p></li></ul><table><thead><tr><th>序号</th><th>服务</th><th>端口号</th></tr></thead><tbody><tr><td>01</td><td>SSH 服务器</td><td>22</td></tr><tr><td>02</td><td>Web 服务器</td><td>80</td></tr><tr><td>03</td><td>HTTPS</td><td>443</td></tr><tr><td>04</td><td>FTP 服务器</td><td>21</td></tr></tbody></table><p><strong>2) SSH 客户端的简单使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-p port] user@remote</span><br></pre></td></tr></table></figure><ul><li><code>user</code> 是在远程机器上的用户名，如果不指定的话默认为当前用户</li><li><code>remote</code> 是远程机器的地址，可以是 <strong>IP／域名</strong>，或者是 <strong>后面会提到的别名</strong></li><li><code>port</code> 是 <strong>SSH Server 监听的端口</strong>，如果不指定，就为默认值 <code>22</code><blockquote><p><em>提示：</em></p><ul><li>使用 <code>exit</code> 退出当前用户的登录</li></ul><p><em>注意：</em></p><ul><li><code>ssh</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li><li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code> 或者 <code>XShell</code> 客户端软件即可</li></ul><p><em>提示：</em></p><ul><li>在工作中，SSH 服务器的端口号很有可能<strong>不是 22</strong>，如果遇到这种情况就需要使用 <code>-p</code> 选项，指定正确的端口号，否则无法正常连接到服务器</li></ul></blockquote></li></ul><h3 id="3-2-scp（掌握）"><a href="#3-2-scp（掌握）" class="headerlink" title="3.2 scp（掌握）"></a>3.2 scp（掌握）</h3><ul><li><p>scp 就是 <code>secure copy</code>，是一个在 Linux 下用来进行 <strong>远程拷贝文件</strong> 的命令</p></li><li><p>它的<strong>地址格式与 ssh 基本相同，需要注意的是</strong>，在指定端口时用的是大写的 <code>-P</code> 而不是小写的￼</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py</span><br><span class="line"># 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</span><br><span class="line">scp -P port 01.py user@remote:Desktop/01.py</span><br><span class="line"></span><br><span class="line"># 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</span><br><span class="line">scp -P port user@remote:Desktop/01.py 01.py</span><br><span class="line"></span><br><span class="line"># 加上 -r 选项可以传送文件夹</span><br><span class="line"># 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop</span><br><span class="line">scp -r demo user@remote:Desktop</span><br><span class="line"></span><br><span class="line"># 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹</span><br><span class="line">scp -r user@remote:Desktop demo</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr><tr><td>-P</td><td>若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口</td></tr></tbody></table><blockquote><p><em>注意：</em></p><ul><li>scp 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li><li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code>，使用 <code>pscp</code> 命令行工具或者安装 <code>FileZilla</code> 使用 <code>FTP</code> 进行文件传输</li></ul></blockquote><h3 id="3-3-SSH-高级（知道）"><a href="#3-3-SSH-高级（知道）" class="headerlink" title="3.3 SSH 高级（知道）"></a>3.3 SSH 高级（知道）</h3><ul><li>免密码登录</li><li>配置别名</li></ul><blockquote><p><em>提示：有关 SSH 配置信息都保存在用户家目录下的 <code>.ssh</code> 目录下</em></p></blockquote><p><strong>1）免密码登录</strong></p><p><strong>步骤</strong></p><ul><li><p>配置公钥</p><ul><li>执行 <code>ssh-keygen</code> 即可生成 SSH 钥匙，一路回车即可</li></ul></li><li><p>上传公钥到服务器</p><ul><li>执行 <code>ssh-copy-id -p port user@remote</code>，可以让远程服务器记住我们的公钥</li></ul></li></ul><blockquote><p><em>非对称加密算法</em></p><ul><li>使用 <strong>公钥</strong> 加密的数据，需要使用 <strong>私钥</strong> 解密</li><li>使用 <strong>私钥</strong> 加密的数据，需要使用 <strong>公钥</strong> 解密</li></ul></blockquote><p><strong>2) 配置别名</strong></p><p>每次都输入 <code>ssh -p port user@remote</code>，时间久了会觉得很麻烦，特别是当 <code>user</code>, <code>remote</code> 和 <code>port</code> 都得输入，而且还不好记忆</p><p>而 <strong>配置别名</strong> 可以让我们进一步偷懒，譬如用：<code>ssh mac</code> 来替代上面这么一长串，那么就在 <code>~/.ssh/config</code> 里面追加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host mac</span><br><span class="line">    HostName ip地址</span><br><span class="line">    User itheima</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure><p><strong>保存之后，即可用</strong> <code>ssh mac</code> <strong>实现远程登录了，</strong><code>scp</code> <strong>同样可以使用</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;远程管理常用命令&quot;&gt;&lt;a href=&quot;#远程管理常用命令&quot; class=&quot;headerlink&quot; title=&quot;远程管理常用命令&quot;&gt;&lt;/a&gt;远程管理常用命令&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;今天继续学习linux基础,本篇博文主要详细描述了关于linux系统的&lt;stron
      
    
    </summary>
    
      <category term="Linux操作系统" scheme="https://xhjiang.tech/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://xhjiang.tech/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux基础第二天</title>
    <link href="https://xhjiang.tech/2018/10/28/linux%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>https://xhjiang.tech/2018/10/28/linux基础第二天/</id>
    <published>2018-10-28T10:52:30.000Z</published>
    <updated>2018-10-29T12:17:01.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h1><hr><p>由于一些原因，最近几天都没有继续复习linux基础，现在继续恢复学习。本篇博文主要学习<strong>文件和目录常用命令</strong>。这些命令都是我们在使用linux系统中最常使用到的关于文件和目录的命令<br><br></p><hr><p><strong>目标</strong></p><ul><li><p>查看目录内容</p><ul><li><code>ls</code></li></ul></li><li><p>切换目录</p><ul><li><code>cd</code></li></ul></li><li><p>创建和删除操作</p><ul><li><code>touch</code></li><li><code>rm</code></li><li><code>mkdir</code></li></ul></li><li><p>拷贝和移动文件</p><ul><li><code>cp</code></li><li><code>mv</code></li></ul></li><li><p>查看文件内容</p><ul><li><code>cat</code></li><li><code>more</code></li><li><code>grep</code></li></ul></li><li><p>其他</p><ul><li><code>echo</code></li><li><code>重定向 &gt; 和 &gt;&gt;</code></li><li><code>管道 |</code></li></ul></li></ul><p><strong>文件和目录常用命令</strong></p><hr><h2 id="01-查看目录内容"><a href="#01-查看目录内容" class="headerlink" title="01.查看目录内容"></a>01.查看目录内容</h2><h3 id="1-1-ls-命令说明"><a href="#1-1-ls-命令说明" class="headerlink" title="1.1 ls 命令说明"></a>1.1 <strong>ls</strong> 命令说明</h3><ul><li><code>ls</code> 是英文单词 <strong>list</strong> 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 <strong>DOS</strong> 下的 <code>dir</code> 命令<br><strong>Linux 下文件和目录的特点</strong></li><li>Linux<strong>文件</strong>或者<strong>目录</strong>名称最长可以有<code>256</code>个字符</li><li>以<code>.</code>开头的文件为隐藏文件，需要用<code>-a</code>参数才能显示</li><li><code>.</code>代表当前目录</li><li><code>..</code>代表上一级目录</li></ul><h3 id="1-3-ls-常用选项"><a href="#1-3-ls-常用选项" class="headerlink" title="1.3 ls 常用选项"></a>1.3 <strong>ls</strong> 常用选项</h3><table><thead><tr><th>参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td><code>-a</code></td><td style="text-align:left">显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td><code>-l</code></td><td style="text-align:left">以列表方式显示文件的详细信息</td></tr><tr><td><code>-h</code></td><td style="text-align:left">配合<code>-l</code>以人性化的方式显示文件大小</td></tr></tbody></table><p><strong>计算机中文件大小的表示方式（科普）</strong></p><table><thead><tr><th>单位</th><th>英文</th><th>含义</th></tr></thead><tbody><tr><td>字节</td><td>B（Byte）</td><td>在计算机中作为一个数字单元，一般为 8 位二进制数</td></tr><tr><td>千</td><td>K（Kibibyte）</td><td>1 KB = 1024 B，千字节 （1024 = 2 ** 10）</td></tr><tr><td>兆</td><td>M（Mebibyte）</td><td>1 MB = 1024 KB，百万字节</td></tr><tr><td>千兆</td><td>G（Gigabyte）</td><td>1 GB = 1024 MB，十亿字节，千兆字节</td></tr><tr><td>太</td><td>T（Terabyte）</td><td>1 TB = 1024 GB，万亿字节，太字节</td></tr><tr><td>拍</td><td>P（Petabyte）</td><td>1 PB = 1024 TB，千万亿字节，拍字节</td></tr><tr><td>艾</td><td>E（Exabyte）</td><td>1 EB = 1024 PB，百亿亿字节，艾字节</td></tr><tr><td>泽</td><td>Z（Zettabyte）</td><td>1 ZB = 1024 EB，十万亿亿字节，泽字节</td></tr><tr><td>尧</td><td>Y（Yottabyte）</td><td>1 YB = 1024 ZB，一亿亿亿字节，尧字节</td></tr></tbody></table><h3 id="1-4-ls-通配符的使用"><a href="#1-4-ls-通配符的使用" class="headerlink" title="1.4 ls 通配符的使用"></a>1.4 <strong>ls</strong> 通配符的使用</h3><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意个数个字符</td></tr><tr><td>?</td><td>代表任意一个字符，至少 1 个</td></tr><tr><td>[]</td><td>表示可以匹配字符组中的任一一个</td></tr><tr><td>[abc]</td><td>匹配 a、b、c 中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从 a 到 f 范围内的的任意一个字符</td></tr></tbody></table><hr><h2 id="02-切换目录"><a href="#02-切换目录" class="headerlink" title="02.切换目录"></a>02.切换目录</h2><h3 id="2-1-cd"><a href="#2-1-cd" class="headerlink" title="2.1 cd"></a>2.1 cd</h3><ul><li><code>cd</code> 是英文单词<strong>change directory</strong>的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一</li></ul><blockquote><p>注意：Linux 所有的 目录 和 文件名 都是大小写敏感的</p></blockquote><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的主目录(/home/用户目录)</td></tr><tr><td>cd ~</td><td>切换到当前用户的主目录(/home/用户目录)</td></tr><tr><td>cd .</td><td>保持在当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h3 id="2-2-相对路径和绝对路径"><a href="#2-2-相对路径和绝对路径" class="headerlink" title="2.2 相对路径和绝对路径"></a>2.2 相对路径和绝对路径</h3><ul><li><p>相对路径 在输入路径时，最前面不是<code>/</code>或者<code>~</code>，表示相对<strong>当前目录</strong>所在的目录位置</p></li><li><p>绝对路径 在输入路径时，最前面是<code>/</code>或者<code>~</code>，表示从<strong>根目录/家目录 </strong>开始的具体目录位置</p></li></ul><hr><h2 id="03-创建和删除操作"><a href="#03-创建和删除操作" class="headerlink" title="03. 创建和删除操作"></a>03. 创建和删除操作</h2><h3 id="3-1-touch"><a href="#3-1-touch" class="headerlink" title="3.1 touch"></a>3.1 touch</h3><ul><li>创建文件或修改文件时间<ul><li>如果文件<strong>不存在</strong>，可以创建一个空白文件</li><li>如果文件<strong>已经存在</strong>，可以修改文件的末次修改日期</li></ul></li></ul><h3 id="3-2-mkdir"><a href="#3-2-mkdir" class="headerlink" title="3.2 mkdir"></a>3.2 mkdir</h3><ul><li>创建一个新的目录</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>可以递归创建目录</td></tr></tbody></table><p><strong>新建目录的名称</strong>不能与当前目录中<strong>已有的目录或文件</strong>同名</p><h3 id="3-3-rm"><a href="#3-3-rm" class="headerlink" title="3.3 rm"></a>3.3 rm</h3><ul><li>删除文件或目录</li></ul><blockquote><p>使用<code>rm</code>命令要小心，因为文件删除后不能恢复</p></blockquote><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容<strong>删除文件夹</strong>时必须加此参数</td></tr></tbody></table><hr><h2 id="04-拷贝和移动文件"><a href="#04-拷贝和移动文件" class="headerlink" title="04. 拷贝和移动文件"></a>04. 拷贝和移动文件</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>tree [目录名]</td><td>tree</td><td>以树状图列出文件目录结构</td></tr><tr><td>02</td><td>cp 源文件 目标文件</td><td>copy</td><td>复制文件或者目录</td></tr><tr><td>03</td><td>mv 源文件 目标文件</td><td>move</td><td>移动文件或者目录／文件或者目录重命名</td></tr></tbody></table><h3 id="4-1-tree"><a href="#4-1-tree" class="headerlink" title="4.1 tree"></a>4.1 tree</h3><ul><li><code>tree</code>命令可以以树状图列出文件目录结构</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>只显示目录</td></tr></tbody></table><h3 id="4-2-cp"><a href="#4-2-cp" class="headerlink" title="4.2 cp"></a>4.2 cp</h3><ul><li><code>cp</code>命令的功能是将给出的<strong>文件*</strong>或<strong>目录</strong>复制到另一个<strong>文件</strong>或<strong>目录</strong>中，相当于 DOS 下的<code>copy</code>命令</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr><tr><td>-r</td><td>若给出的源文件是目录文件，则<code>cp</code>将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr></tbody></table><h3 id="4-3-mv"><a href="#4-3-mv" class="headerlink" title="4.3 mv"></a>4.3 mv</h3><ul><li><code>mv</code>命令可以用来<strong>移动</strong> <strong>文件</strong>或<strong>目录</strong>，也可以给<strong>文件或目录</strong>重命名</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr></tbody></table><hr><h2 id="05-查看文件内容"><a href="#05-查看文件内容" class="headerlink" title="05. 查看文件内容"></a>05. 查看文件内容</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>cat 文件名</td><td>concatenate</td><td>查看文件内容、创建文件、文件合并、追加文件内容等功能</td></tr><tr><td>02</td><td>more 文件名</td><td>more</td><td>分屏显示文件内容</td></tr><tr><td>03</td><td>grep 搜索文本 文件名</td><td>grep</td><td>搜索文本文件内容</td></tr></tbody></table><h2 id="5-1-cat"><a href="#5-1-cat" class="headerlink" title="5.1 cat"></a>5.1 cat</h2><ul><li><code>cat</code>命令可以用来<strong>查看文件内容、创建文件、文件合并、追加文件内容</strong>等功能</li><li><code>cat</code>会一次显示所有的内容，适合<strong>查看内容较少</strong>的文本文件</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>对非空输出行编号</td></tr><tr><td>-n</td><td>对输出的所有行编号</td></tr></tbody></table><blockquote><p>Linux 中还有一个<code>nl</code>的命令和<code>cat</code> <code>-b</code>的效果等价</p></blockquote><h2 id="5-2-more"><a href="#5-2-more" class="headerlink" title="5.2 more"></a>5.2 more</h2><ul><li><code>more</code>命令可以用于分屏显示文件内容，每次只显示一页内容</li><li>适合于<strong>查看内容较多</strong>的文本文件</li></ul><p>使用<code>more</code>的操作键：</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter 键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>/word</td><td>搜索 word 字符串</td></tr></tbody></table><h2 id="5-3-grep"><a href="#5-3-grep" class="headerlink" title="5.3 grep"></a>5.3 grep</h2><ul><li>Linux 系统中 grep 命令是一种强大的文本搜索工具</li><li><code>grep</code>允许对文本文件进行<strong>模式</strong>查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><ul><li>常用的两种模式查找</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首，搜寻以<code>a</code>开头的行</td></tr><tr><td>ke$</td><td>行尾，搜寻以<code>ke</code>结束的行</td></tr></tbody></table><hr><h2 id="06-其他"><a href="#06-其他" class="headerlink" title="06. 其他"></a>06. 其他</h2><h3 id="6-1-echo-文字内容"><a href="#6-1-echo-文字内容" class="headerlink" title="6.1 echo 文字内容"></a>6.1 echo 文字内容</h3><ul><li><code>echo</code>会在终端中显示参数指定的文字，通常会和<strong>重定向</strong>联合使用</li></ul><h3 id="6-2-重定向-gt-和-gt-gt"><a href="#6-2-重定向-gt-和-gt-gt" class="headerlink" title="6.2 重定向 &gt; 和 &gt;&gt;"></a>6.2 重定向 &gt; 和 &gt;&gt;</h3><ul><li>Linux 允许将命令执行结果<strong>重定向</strong>到一个<strong>文件</strong></li><li>将本应显示在<strong>终端上的内容</strong> <strong>输出／追加</strong>到<strong>指定文件</strong>中</li></ul><p>其中</p><ul><li><code>&gt;</code>表示输出，会覆盖文件原有的内容</li><li><code>&gt;&gt;</code>表示追加，会将内容追加到已有文件的末尾</li></ul><h3 id="6-3-管道"><a href="#6-3-管道" class="headerlink" title="6.3 管道 |"></a>6.3 管道 |</h3><ul><li>Linux 允许将<strong>一个命令的输出</strong>可以<strong>通过管道</strong>做为<strong>另一个命令的输入</strong></li><li>可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读）</li></ul><blockquote><p>常用的管道命令有：</p></blockquote><ul><li><code>more</code>：分屏显示内容</li><li><code>grep</code>：在命令执行结果的基础上查询指定的文本</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件和目录常用命令&quot;&gt;&lt;a href=&quot;#文件和目录常用命令&quot; class=&quot;headerlink&quot; title=&quot;文件和目录常用命令&quot;&gt;&lt;/a&gt;文件和目录常用命令&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;由于一些原因，最近几天都没有继续复习linux基础，现在继续恢复学习。本篇
      
    
    </summary>
    
      <category term="Linux操作系统" scheme="https://xhjiang.tech/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://xhjiang.tech/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux基础第一天</title>
    <link href="https://xhjiang.tech/2018/10/25/linux%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://xhjiang.tech/2018/10/25/linux基础第一天/</id>
    <published>2018-10-25T14:57:52.000Z</published>
    <updated>2018-10-29T12:17:29.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用-Linux-命令的基本使用"><a href="#常用-Linux-命令的基本使用" class="headerlink" title="常用 Linux 命令的基本使用"></a>常用 Linux 命令的基本使用</h1><p>楼主最近想要复习一下以前学过的linux基础知识，现在准备把一些常用的linux基础命令操作放在自己的博客上，以便下次再用时查阅。<br><br><br>本篇博文主要学习了一些最常用的linux命令。<br><br></p><hr><h2 id="01-学习-Linux-终端命令的原因"><a href="#01-学习-Linux-终端命令的原因" class="headerlink" title="01. 学习 Linux 终端命令的原因"></a>01. 学习 Linux 终端命令的原因</h2><ul><li>Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如<strong>磁盘操作</strong>、<strong>文件存取</strong>、<strong>目录操作</strong>、<strong>进程管理</strong>、<strong>文件权限</strong>设定等</li><li>在职场中，大量的<strong>服务器维护工作</strong>都是在<strong>远程</strong>通过<strong>SSH</strong>客户端 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成</li><li>在职场中，作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令</li><li>Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已</li></ul><hr><h2 id="02-常用-Linux-命令的基本使用"><a href="#02-常用-Linux-命令的基本使用" class="headerlink" title="02.常用 Linux 命令的基本使用"></a>02.常用 Linux 命令的基本使用</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ls</td><td>查看当前文件夹下的内容</td></tr><tr><td>02</td><td>pwd</td><td>查看当前所在文件夹</td></tr><tr><td>03</td><td>cd[目录名]</td><td>切换文件夹</td></tr><tr><td>04</td><td>touch[文件名]</td><td>若文件夹不存在，新建文件</td></tr><tr><td>05</td><td>mkdir[目录名]</td><td>创建目录</td></tr><tr><td>06</td><td>rm[文件名]</td><td>删除指定的文件名</td></tr><tr><td>07</td><td>clear</td><td>清屏</td></tr></tbody></table><blockquote><p><em>小技巧</em></p><ul><li><code>ctrl + shift + =</code><strong>放大</strong>终端窗口的字体显示</li><li><code>ctrl + -</code> <strong>缩小</strong>终端窗口的字体显示</li></ul></blockquote><hr><h2 id="03-自动补全"><a href="#03-自动补全" class="headerlink" title="03.自动补全"></a>03.自动补全</h2><ul><li>在敲出<code>文件</code>/<code>目录</code>/<code>命令</code>的前几个字母之后，按下<code>tab</code>键<ul><li>如果输入的没有歧义，系统会自动补全</li><li>如果还存在其他<code>文件</code>/<code>目录</code>/<code>命令</code>。再按一下<code>tab</code>键，系统会提示可能存在的命令</li></ul></li></ul><blockquote><p><em>小技巧</em></p><ul><li>按 <code>上</code>／<code>下</code> 光标键可以在曾经使用过的命令之间来回切换</li><li>如果想要退出选择，并且不想执行当前选中的命令，可以按 <code>ctrl + c</code></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用-Linux-命令的基本使用&quot;&gt;&lt;a href=&quot;#常用-Linux-命令的基本使用&quot; class=&quot;headerlink&quot; title=&quot;常用 Linux 命令的基本使用&quot;&gt;&lt;/a&gt;常用 Linux 命令的基本使用&lt;/h1&gt;&lt;p&gt;楼主最近想要复习一下以前学过
      
    
    </summary>
    
      <category term="Linux操作系统" scheme="https://xhjiang.tech/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://xhjiang.tech/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://xhjiang.tech/2018/10/23/hello-world/"/>
    <id>https://xhjiang.tech/2018/10/23/hello-world/</id>
    <published>2018-10-23T13:54:02.022Z</published>
    <updated>2018-10-23T13:54:02.022Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
