<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>difcreate&#39;s blog</title>
  
  <subtitle>偷得浮生半日闲</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xhjiang.tech/"/>
  <updated>2018-12-06T09:46:51.261Z</updated>
  <id>https://xhjiang.tech/</id>
  
  <author>
    <name>difcreate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode刷题-102. Binary Tree Level Order Traversal</title>
    <link href="https://xhjiang.tech/2018/12/06/leetcode%E5%88%B7%E9%A2%98-102-Binary-Tree-Level-Order-Traversal/"/>
    <id>https://xhjiang.tech/2018/12/06/leetcode刷题-102-Binary-Tree-Level-Order-Traversal/</id>
    <published>2018-12-06T09:22:11.000Z</published>
    <updated>2018-12-06T09:46:51.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="102-Binary-Tree-Level-Order-Traversal-二叉树的层次遍历"><a href="#102-Binary-Tree-Level-Order-Traversal-二叉树的层次遍历" class="headerlink" title="102. Binary Tree Level Order Traversal-二叉树的层次遍历"></a>102. Binary Tree Level Order Traversal-二叉树的层次遍历</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回其层次遍历结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><hr><p><strong>递归版：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        traverse(root, <span class="number">1</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode *root, <span class="keyword">size_t</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果已经递归到另一层，则给二维数组result添加一个空的一位数组</span></span><br><span class="line">        &lt;!--</span><br></pre></td></tr></table></figure><pre><code>结果数组输出格式：    [    [3],    [9,20],    [15,7]    ]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        if (level &gt; result.size())</span><br><span class="line">            result.push_back(vector&lt;int&gt;());</span><br><span class="line"></span><br><span class="line">        result[level-1].push_back(root-&gt;val);</span><br><span class="line">        traverse(root-&gt;left, level+1, result);</span><br><span class="line">        traverse(root-&gt;right, level+1, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><p><strong>迭代版：用队列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=que.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_temp;</span><br><span class="line">            <span class="comment">//每一次都将某一层的节点值添加到这一层的一位数组中</span></span><br><span class="line">            <span class="keyword">while</span>(size--)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* t = que.front();</span><br><span class="line">                vec_temp.push_back(que.front()-&gt;val);</span><br><span class="line">                que.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)&#123;</span><br><span class="line">                    que.push(t-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)&#123;</span><br><span class="line">                    que.push(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//二维结果数组添加每一层的一位数组</span></span><br><span class="line">            vec.push_back(vec_temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;102-Binary-Tree-Level-Order-Traversal-二叉树的层次遍历&quot;&gt;&lt;a href=&quot;#102-Binary-Tree-Level-Order-Traversal-二叉树的层次遍历&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-3. Longest Substring Without Repeating Characters</title>
    <link href="https://xhjiang.tech/2018/12/06/leetcode%E5%88%B7%E9%A2%98-3-Longest-Substring-Without-Repeating-Characters/"/>
    <id>https://xhjiang.tech/2018/12/06/leetcode刷题-3-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2018-12-06T08:41:55.000Z</published>
    <updated>2018-12-06T09:58:57.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串"><a href="#3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串" class="headerlink" title="3. Longest Substring Without Repeating Characters-无重复字符的最长子串"></a>3. Longest Substring Without Repeating Characters-无重复字符的最长子串</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></p><hr><p><strong>分析：</strong><br>这是一道可以跟Two Sum媲美的题。给了我们一个字符串，让我们求最长的无重复字符的子串，注意这里是子串，不是子序列，所以必须是连续的。我们先不考虑代码怎么实现，如果给一个例子”abcabcbb”，让你手动找无重复字符的子串，该怎么找？一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用<strong>HashMap</strong>来建立字符和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个<strong>滑动窗口</strong>，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果了。</p><p>建立一个256位大小的整型数组来代替哈希表，这样做的原因是ASCII表共能表示256个字符，所以可以记录所有字符，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置，然后我们遍历整个字符串，对于每一个遍历到的字符，如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串，i - left +１，其中ｉ是最长无重复子串最右边的位置，left是最左边的位置，还有一种情况也需要计算最长无重复子串，就是当哈希表中的值小于left，这是由于此时出现过重复的字符，left的位置更新了，如果又遇到了新的字符，就要重新计算最长无重复子串。最后每次都要在哈希表中将当前字符对应的值赋值为i+1。</p><p>代码一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, res = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">             <span class="keyword">if</span> (m[s[i]] == <span class="number">0</span> || m[s[i]] &lt; left) &#123;</span><br><span class="line">                 res = max(res, i - left + <span class="number">1</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 left = m[s[i]];</span><br><span class="line">             &#125;</span><br><span class="line">             m[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>Tips:</em><br>这里解释下程序中那个if条件语句中为啥要有个<strong>m[s[i]] &lt; left</strong>，我们用一个例子来说明，当输入字符串为”abbca”的时候，当i=4时，也就是即将要开始遍历最后一个字母a时，此时哈希表中a对应1，b对应3，c对应4，left为2，即当前最长的子字符串的左边界为第二个b的位置，而第一个a已经不在当前最长的字符串的范围内了，那么对于i=4这个新进来的a，应该要加入结果中，而此时未被更新的哈希表中a为1，不是0，如果不判断它和left的关系的话，就无法更新结果，那么答案就会少一位，所以需要加m[s[i]] &lt; left。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串&quot; 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="https://xhjiang.tech/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-2. Add Two Numbers</title>
    <link href="https://xhjiang.tech/2018/12/01/leetcode%E5%88%B7%E9%A2%98-2-Add-Two-Numbers/"/>
    <id>https://xhjiang.tech/2018/12/01/leetcode刷题-2-Add-Two-Numbers/</id>
    <published>2018-12-01T15:32:12.000Z</published>
    <updated>2018-12-01T15:50:53.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers-两数相加"><a href="#2-Add-Two-Numbers-两数相加" class="headerlink" title="2. Add Two Numbers-两数相加"></a>2. Add Two Numbers-两数相加</h1><hr><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>创建一个临时的头结点，并将指针cur指向该节点，之后遍历L1 和 L2两个链表，将他们对应位置节点的值相加，同和，如果该位置前的两个节点之和大于等于10，需要进位，则该节点值加1，然后对10取余，并新建节点保存，将cur的next指针指向该节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> carry = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(carry)</span><br><span class="line">                sum++;</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">            carry = sum &gt;= <span class="number">10</span> ? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-Add-Two-Numbers-两数相加&quot;&gt;&lt;a href=&quot;#2-Add-Two-Numbers-两数相加&quot; class=&quot;headerlink&quot; title=&quot;2. Add Two Numbers-两数相加&quot;&gt;&lt;/a&gt;2. Add Two Numbers-
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-69. Sqrt(x)</title>
    <link href="https://xhjiang.tech/2018/12/01/leetcode%E5%88%B7%E9%A2%98-69-Sqrt-x/"/>
    <id>https://xhjiang.tech/2018/12/01/leetcode刷题-69-Sqrt-x/</id>
    <published>2018-12-01T14:27:20.000Z</published>
    <updated>2018-12-01T14:41:50.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-Sqrt-x-x的平方根"><a href="#69-Sqrt-x-x的平方根" class="headerlink" title="69. Sqrt(x)-x的平方根"></a>69. Sqrt(x)-x的平方根</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>算一个候选值的平方，然后和x比较大小，为了缩短查找时间，我们采用二分搜索法来找平方根</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">         <span class="keyword">int</span> left = <span class="number">0</span>, right = x;</span><br><span class="line">         <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">             <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span> (x / mid &gt;= mid) left = mid + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;69-Sqrt-x-x的平方根&quot;&gt;&lt;a href=&quot;#69-Sqrt-x-x的平方根&quot; class=&quot;headerlink&quot; title=&quot;69. Sqrt(x)-x的平方根&quot;&gt;&lt;/a&gt;69. Sqrt(x)-x的平方根&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;描述：&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数学" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数学" scheme="https://xhjiang.tech/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-55. Jump Game</title>
    <link href="https://xhjiang.tech/2018/11/30/leetcode%E5%88%B7%E9%A2%98-55-Jump-Game/"/>
    <id>https://xhjiang.tech/2018/11/30/leetcode刷题-55-Jump-Game/</id>
    <published>2018-11-30T08:25:41.000Z</published>
    <updated>2018-11-30T08:26:37.577Z</updated>
    
    <content type="html"><![CDATA[<p>#　55. Jump Game-跳跃游戏</p><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题可以用<strong>贪婪算法Greedy Algorithm</strong>来解决，因为我们并不是很关心每一个位置上的剩余步数，我们只希望知道能否到达末尾，也就是说我们只对最远能到达的位置感兴趣，所以我们维护一个变量reach，表示最远能到达的位置，初始化为0。遍历数组中每一个数字，如果当前坐标大于reach或者reach已经抵达最后一个位置则跳出循环，否则就更新reach的值为其和i + nums[i]中的较大值，其中i + nums[i]表示当前位置能到达的最大位置，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), reach = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//当前坐标大于reach或者reach已经抵达最后则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; reach || reach &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            reach = max(reach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reach &gt;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#　55. Jump Game-跳跃游戏&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;headerlink&quot; title=&quot;描述：&quot;&gt;&lt;/a&gt;描述：&lt;/h2&gt;&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/categories/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-144. Binary Tree Preorder Traversal</title>
    <link href="https://xhjiang.tech/2018/11/29/leetcode%E5%88%B7%E9%A2%98-144-Binary-Tree-Preorder-Traversal/"/>
    <id>https://xhjiang.tech/2018/11/29/leetcode刷题-144-Binary-Tree-Preorder-Traversal/</id>
    <published>2018-11-29T12:10:26.000Z</published>
    <updated>2018-11-29T12:25:11.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历"><a href="#144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历" class="headerlink" title="144. Binary Tree Preorder Traversal-二叉树的前序遍历"></a>144. Binary Tree Preorder Traversal-二叉树的前序遍历</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个二叉树，返回它的 前序 遍历。</p><p> 示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure></p><blockquote><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><hr><p>非递归版-使用栈解题<br>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">const</span> TreeNode *&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">const</span> TreeNode *p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            result.push_back(p-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right != <span class="literal">nullptr</span>) s.push(p-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left != <span class="literal">nullptr</span>) s.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">            preorder(root-&gt;left,result);</span><br><span class="line">            preorder(root-&gt;right,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        preorder(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;144. B
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-20. Valid Parentheses</title>
    <link href="https://xhjiang.tech/2018/11/29/leetcode%E5%88%B7%E9%A2%98-20-Valid-Parentheses/"/>
    <id>https://xhjiang.tech/2018/11/29/leetcode刷题-20-Valid-Parentheses/</id>
    <published>2018-11-29T11:38:19.000Z</published>
    <updated>2018-11-29T11:49:58.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20-Valid-Parentheses-有效的括号"><a href="#20-Valid-Parentheses-有效的括号" class="headerlink" title="20. Valid Parentheses-有效的括号"></a>20. Valid Parentheses-有效的括号</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>利用<strong>栈stack数据结构</strong>来解决问题；首先判断字符串是否为空，若为空则返回true；然后判断只要栈中的元素为空，就入栈，而且栈顶和目前的元素无法配对的时候，同样打入栈中，这样避免了一开始就是右括号，不入栈；若栈顶是对应的左括号接下来要访问栈顶的元素，最后只需要判断栈中是不是为空就好了。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; result;  </span><br><span class="line">        <span class="keyword">int</span> n=s.size();  </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)  &#123;  </span><br><span class="line">            <span class="keyword">if</span>(result.empty())  </span><br><span class="line">                result.push(s[i]);  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(result.top()==<span class="string">'('</span>&amp;&amp;s[i]==<span class="string">')'</span>||  </span><br><span class="line">                  result.top()==<span class="string">'['</span>&amp;&amp;s[i]==<span class="string">']'</span>||  </span><br><span class="line">                  result.top()==<span class="string">'&#123;'</span>&amp;&amp;s[i]==<span class="string">'&#125;'</span>)   </span><br><span class="line">                    result.pop();  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                result.push(s[i]);  </span><br><span class="line"></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> result.empty(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;20-Valid-Parentheses-有效的括号&quot;&gt;&lt;a href=&quot;#20-Valid-Parentheses-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;20. Valid Parentheses-有效的括号&quot;&gt;&lt;/a&gt;20. Val
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="栈" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%88/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="栈" scheme="https://xhjiang.tech/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-11. Container With Most Water</title>
    <link href="https://xhjiang.tech/2018/11/28/leetcode%E5%88%B7%E9%A2%98-11-Container-With-Most-Water/"/>
    <id>https://xhjiang.tech/2018/11/28/leetcode刷题-11-Container-With-Most-Water/</id>
    <published>2018-11-28T14:53:05.000Z</published>
    <updated>2018-11-28T15:05:00.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water-盛最多水的容器"><a href="#11-Container-With-Most-Water-盛最多水的容器" class="headerlink" title="11. Container With Most Water-盛最多水的容器"></a>11. Container With Most Water-盛最多水的容器</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong> 你不能倾斜容器，且 n 的值至少为 2。<div align="center"><br><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/leetcode/question_11.jpg?q-sign-algorithm=sha1&amp;q-ak=AKIDAo1tspwphcTrXVj2W29WzZffzFfpa5c3&amp;q-sign-time=1543417200;1543419000&amp;q-key-time=1543417200;1543419000&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=88a6e762f29499510c18505700752a1f18c91853&amp;x-cos-security-token=2bc82588c9883bce6d8e820373aa29a8543eb06010001" alt="图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。"></div></p><blockquote><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p></blockquote><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure></p><p><strong>思路：</strong></p><p>考虑用<strong>双指针</strong>法解题。维护两个指针f、l分别指向数组左右两端，则f和l构成的容器盛水体积计算公式为<strong>min(height[f],height[l])*(l-f)</strong>。可以看出盛水体积取决于容器边中较小的数字和容器底长度。若移动较大的数字，则容器底长度会变小，而盛水的最大高度不变，所以盛水体积不会变更大。因此需要移动两数中较小的数字，这样若中间出现特别大的数字，则有可能提高盛水体积。然后每次移动完更新此时的最大盛水体积，直到两指针相遇。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>,l = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(f &lt; l)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = min(height[f],height[l])*(l-f);</span><br><span class="line">            <span class="keyword">if</span>(area &gt; max)</span><br><span class="line">                max = area;</span><br><span class="line">            <span class="keyword">if</span>(height[f]&lt;height[l])</span><br><span class="line">                f++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;11-Container-With-Most-Water-盛最多水的容器&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;11. Container With M
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-62. Unique Paths</title>
    <link href="https://xhjiang.tech/2018/11/27/leetcode%E5%88%B7%E9%A2%98-62-Unique-Paths/"/>
    <id>https://xhjiang.tech/2018/11/27/leetcode刷题-62-Unique-Paths/</id>
    <published>2018-11-27T14:07:31.000Z</published>
    <updated>2018-11-28T15:04:55.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="62-Unique-Paths-不同路径"><a href="#62-Unique-Paths-不同路径" class="headerlink" title="62. Unique Paths-不同路径"></a>62. Unique Paths-不同路径</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？<div align="center"><img src="https://xhjiang-1256231208.cos.ap-chengdu.myqcloud.com/leetcode/question_62.png?q-sign-algorithm=sha1&amp;q-ak=AKID2vZhp1cvd42VAikuWAywg73c8X0YvzTj&amp;q-sign-time=1543417433;1543419233&amp;q-key-time=1543417433;1543419233&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=aebbb05c9130983eb09642a9bfe67eb7f8298dd2&amp;x-cos-security-token=73c5e962610da5b65c10947356559eb21fe46a6e10001" alt=""></div></p><blockquote><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p></blockquote><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题跟之前那道 Climbing Stairs 很类似，那道题是说可以每次能爬一格或两格，问到达顶部的所有不同爬法的个数。而这道题是每次可以向下走或者向右走，求到达最右下角的所有不同走法的个数。那么跟爬梯子问题一样，我们需要用<strong>动态规划</strong>来解，我们可以维护一个二维数组nums，其中nums[i][j]表示到当前位置不同的走法的个数，然后可以得到<strong>状态转移方程: nums[i][j] = nums[i - 1][j] + nums[i][j - 1]</strong>。</p><p>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(m*n),空间复杂度O(m*n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nums(m,num);</span><br><span class="line">        <span class="comment">//nums[i][j] = nums[i - 1][j] + nums[i][j - 1];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    nums[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nums[i][j] = nums[i - <span class="number">1</span>][j] + nums[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了节省空间，我们使用一维数组nums，一行一行的刷新也可以。</p><p>代码二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(m*n),空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;62-Unique-Paths-不同路径&quot;&gt;&lt;a href=&quot;#62-Unique-Paths-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62. Unique Paths-不同路径&quot;&gt;&lt;/a&gt;62. Unique Paths-不同路径&lt;/h1
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-110. Balanced Binary Tree</title>
    <link href="https://xhjiang.tech/2018/11/27/leetcode%E5%88%B7%E9%A2%98-110-Balanced-Binary-Tree/"/>
    <id>https://xhjiang.tech/2018/11/27/leetcode刷题-110-Balanced-Binary-Tree/</id>
    <published>2018-11-27T10:21:10.000Z</published>
    <updated>2018-11-27T14:00:00.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="110-Balanced-Binary-Tree-平衡二叉树"><a href="#110-Balanced-Binary-Tree-平衡二叉树" class="headerlink" title="110. Balanced Binary Tree-平衡二叉树"></a>110. Balanced Binary Tree-平衡二叉树</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure></p><hr><p><strong>代码一：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//时间复杂度O(n),空间复杂度O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> balancedHeight (root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the height of `root` if `root` is a balanced tree,</span></span><br><span class="line"><span class="comment">    * otherwise, returns `-1`.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedHeight</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">int</span> left = balancedHeight (root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = balancedHeight (root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span> || <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>; <span class="comment">// ̸三方合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;110-Balanced-Binary-Tree-平衡二叉树&quot;&gt;&lt;a href=&quot;#110-Balanced-Binary-Tree-平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;110. Balanced Binary Tree-平衡二叉树&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-35. Search Insert Position</title>
    <link href="https://xhjiang.tech/2018/11/25/leetcode%E5%88%B7%E9%A2%98-35-Search-Insert-Position/"/>
    <id>https://xhjiang.tech/2018/11/25/leetcode刷题-35-Search-Insert-Position/</id>
    <published>2018-11-25T15:00:59.000Z</published>
    <updated>2018-11-27T10:20:05.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="35-Search-Insert-Position-搜索插入位置"><a href="#35-Search-Insert-Position-搜索插入位置" class="headerlink" title="35. Search Insert Position-搜索插入位置"></a>35. Search Insert Position-搜索插入位置</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><hr><p>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;target||nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;target&amp;&amp;nums[i+<span class="number">1</span>]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt; target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; target &amp;&amp; A[i+<span class="number">1</span>] &gt; target)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;35-Search-Insert-Position-搜索插入位置&quot;&gt;&lt;a href=&quot;#35-Search-Insert-Position-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;35. Search Insert Position-搜
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="查找" scheme="https://xhjiang.tech/categories/leetcode/%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="查找" scheme="https://xhjiang.tech/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-96. Unique Binary Search Trees</title>
    <link href="https://xhjiang.tech/2018/11/25/leetcode%E5%88%B7%E9%A2%98-96-Unique-Binary-Search-Trees/"/>
    <id>https://xhjiang.tech/2018/11/25/leetcode刷题-96-Unique-Binary-Search-Trees/</id>
    <published>2018-11-25T14:48:08.000Z</published>
    <updated>2018-11-27T10:22:12.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="96-Unique-Binary-Search-Trees-不同的二叉搜索树"><a href="#96-Unique-Binary-Search-Trees-不同的二叉搜索树" class="headerlink" title="96. Unique Binary Search Trees-不同的二叉搜索树"></a>96. Unique Binary Search Trees-不同的二叉搜索树</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题我们可以看出一个规律就是当数组为1,2,3…,n时，基于以下原则的构建的BST树具有唯一性：<strong>以i为根节点的树，其左子树由[1,i-1],组成，其右子树由[i+1,n]组成。</strong></p><p>此问题可以看作是一维动态规划问题，可以看出，以i为根节点的树的个数等于：<strong>左子树的个数乘以右子树的个数(其中空子树和单节点树的个数都为1)</strong><br>公式表达为：$$f(i) = \sum_{k=1}^{i}f(k-1)*f(i-k)$$</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n^2),空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)&#123;</span><br><span class="line">                f[i] += f[k<span class="number">-1</span>] * f[i-k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;96-Unique-Binary-Search-Trees-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#96-Unique-Binary-Search-Trees-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;96. Unique Binar
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/categories/leetcode/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="树" scheme="https://xhjiang.tech/tags/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-70. Climbing Stairs</title>
    <link href="https://xhjiang.tech/2018/11/23/leetcode%E5%88%B7%E9%A2%98-70-Climbing-Stairs/"/>
    <id>https://xhjiang.tech/2018/11/23/leetcode刷题-70-Climbing-Stairs/</id>
    <published>2018-11-23T13:41:29.000Z</published>
    <updated>2018-11-23T13:52:11.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-Climbing-Stairs-爬楼梯"><a href="#70-Climbing-Stairs-爬楼梯" class="headerlink" title="70. Climbing Stairs-爬楼梯"></a>70. Climbing Stairs-爬楼梯</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路：</strong></p><p>这道题目实际上跟<strong>斐波那契数列</strong>非常相似，假设梯子有n层，那么如何爬到第n层呢，因为每次只能爬1或2步，那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的，所以递推公式非常容易的就得出了：<strong>dp[n] = dp[n-1] + dp[n-2]</strong>。 由于斐波那契额数列的求解可以用递归，所以最先尝试了递归，拿到OJ上运行，显示Time Limit Exceeded，就是说运行时间超了，因为递归计算了很多分支，效率很低，这里需要用动态规划 (Dynamic Programming) 来提高效率，代码如下：</p><p>代码一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//类似于斐波那契数列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>另外：</strong></p><blockquote><p>我们可以对空间进行进一步优化，我们只用两个整型变量a和b来存储过程值，首先将a+b的值赋给b，然后a赋值为原来的b，所以应该赋值为b-a即可。这样就模拟了上面累加的过程，而不用存储所有的值。</p></blockquote><p>代码二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            b += a;</span><br><span class="line">            a = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;70-Climbing-Stairs-爬楼梯&quot;&gt;&lt;a href=&quot;#70-Climbing-Stairs-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. Climbing Stairs-爬楼梯&quot;&gt;&lt;/a&gt;70. Climbing Stairs
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://xhjiang.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-9. Palindrome Number</title>
    <link href="https://xhjiang.tech/2018/11/23/leetcode%E5%88%B7%E9%A2%98-9-Palindrome-Number/"/>
    <id>https://xhjiang.tech/2018/11/23/leetcode刷题-9-Palindrome-Number/</id>
    <published>2018-11-23T13:32:22.000Z</published>
    <updated>2018-11-23T13:36:58.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Palindrome-Number-回文数"><a href="#9-Palindrome-Number-回文数" class="headerlink" title="9. Palindrome Number-回文数"></a>9. Palindrome Number-回文数</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>进阶:</p><p>你能不将整数转为字符串来解决这个问题吗？</p><hr><p><strong>思路：</strong></p><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以10的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(log_10 n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9-Palindrome-Number-回文数&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number-回文数&quot; class=&quot;headerlink&quot; title=&quot;9. Palindrome Number-回文数&quot;&gt;&lt;/a&gt;9. Palindrome Nu
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-121. Best Time to Buy and Sell Stock</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-121-Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-121-Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2018-11-22T13:37:09.000Z</published>
    <updated>2018-11-22T13:41:00.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机" class="headerlink" title="121. Best Time to Buy and Sell Stock-买卖股票的最佳时机"></a>121. Best Time to Buy and Sell Stock-买卖股票的最佳时机</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>找到最小的值，然后依次比较最小值后面每个值与最小值的差值的大小，保留最大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到最小的值，然后依次比较最小值后面每个值与最小值的差值的大小，保留最大的差值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;12
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-48. Rotate Image</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-48-Rotate-Image/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-48-Rotate-Image/</id>
    <published>2018-11-22T13:27:41.000Z</published>
    <updated>2018-11-22T13:35:52.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="48-Rotate-Image-旋转图像"><a href="#48-Rotate-Image-旋转图像" class="headerlink" title="48. Rotate Image-旋转图像"></a>48. Rotate Image-旋转图像</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><hr><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="comment">// 沿着副对角线反转</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - <span class="number">1</span> - j][n - <span class="number">1</span> - i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) <span class="comment">// 沿着水平中线反转</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[n - <span class="number">1</span> - i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;48-Rotate-Image-旋转图像&quot;&gt;&lt;a href=&quot;#48-Rotate-Image-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. Rotate Image-旋转图像&quot;&gt;&lt;/a&gt;48. Rotate Image-旋转图像&lt;/h1
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-12. Integer to Roman</title>
    <link href="https://xhjiang.tech/2018/11/22/leetcode%E5%88%B7%E9%A2%98-12-Integer-to-Roman/"/>
    <id>https://xhjiang.tech/2018/11/22/leetcode刷题-12-Integer-to-Roman/</id>
    <published>2018-11-21T16:19:10.000Z</published>
    <updated>2018-11-21T16:23:27.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-Integer-to-Roman-整数转罗马数字"><a href="#12-Integer-to-Roman-整数转罗马数字" class="headerlink" title="12. Integer to Roman-整数转罗马数字"></a>12. Integer to Roman-整数转罗马数字</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br></pre></td></tr></table></figure></p><p>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><hr><p><strong>思路：</strong><br>从最高位开始依次求得每个位置上的数字，然后按照罗马字符串数组上对照的罗马字母依次添加到字符串Roman后面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> radix[] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>,</span><br><span class="line">                             <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span> symbol[] = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>,</span><br><span class="line">                                 <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> roman;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; num &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = num / radix[i];</span><br><span class="line">            num %= radix[i];</span><br><span class="line">            <span class="keyword">for</span> (; count &gt; <span class="number">0</span>; --count) roman += symbol[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;12-Integer-to-Roman-整数转罗马数字&quot;&gt;&lt;a href=&quot;#12-Integer-to-Roman-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;12. Integer to Roman-整数转罗马数字&quot;&gt;&lt;/a&gt;12. 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-141. Linked List Cycle</title>
    <link href="https://xhjiang.tech/2018/11/21/leetcode%E5%88%B7%E9%A2%98-141-Linked-List-Cycle/"/>
    <id>https://xhjiang.tech/2018/11/21/leetcode刷题-141-Linked-List-Cycle/</id>
    <published>2018-11-21T15:47:59.000Z</published>
    <updated>2018-11-21T15:53:18.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-Linked-List-Cycle-环形链表"><a href="#141-Linked-List-Cycle-环形链表" class="headerlink" title="141. Linked List Cycle-环形链表"></a>141. Linked List Cycle-环形链表</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个链表，判断链表中是否有环。</p><p><strong>思路：</strong><br>最好的方法是时间复杂度O(n),空间复杂度O(1)。设置两个指针，一个快，一个慢，快的指针每次走两步，慢的指针每次走一步，如果两个指针相遇，则说明有环。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> * Definition <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"> <span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head,*fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;141-Linked-List-Cycle-环形链表&quot;&gt;&lt;a href=&quot;#141-Linked-List-Cycle-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141. Linked List Cycle-环形链表&quot;&gt;&lt;/a&gt;141. Li
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="链表" scheme="https://xhjiang.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-13.Roman to Integer</title>
    <link href="https://xhjiang.tech/2018/11/20/leetcode%E5%88%B7%E9%A2%98-Roman-to-Integer/"/>
    <id>https://xhjiang.tech/2018/11/20/leetcode刷题-Roman-to-Integer/</id>
    <published>2018-11-20T07:08:44.000Z</published>
    <updated>2018-11-20T08:03:25.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer-罗马数字转整数"><a href="#13-Roman-to-Integer-罗马数字转整数" class="headerlink" title="13. Roman to Integer-罗马数字转整数"></a>13. Roman to Integer-罗马数字转整数</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>从前往后遍历，用一个临时变量记录分段数字。如果当前数字比上一个数字大，说明这一段的值应该用当前这个值减去上一个值，比如<strong>IV = 5 - 1</strong>；否则，将当前值加入到结果中，开始下一段记录。比如：<strong>VI = 5 + 1,II = 1 + 1</strong>;</p><blockquote><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">map</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'I'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">map</span>(s[i]) &gt; <span class="built_in">map</span>(s[i<span class="number">-1</span>])))&#123;</span><br><span class="line">                <span class="comment">//这里减去两倍的上一个值是前一个值在迭代时已经加过了，所以要减两次</span></span><br><span class="line">                result += (<span class="built_in">map</span>(s[i]) - <span class="number">2</span> * <span class="built_in">map</span>(s[i<span class="number">-1</span>]));</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">               result += <span class="built_in">map</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;13-Roman-to-Integer-罗马数字转整数&quot;&gt;&lt;a href=&quot;#13-Roman-to-Integer-罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;13. Roman to Integer-罗马数字转整数&quot;&gt;&lt;/a&gt;13. 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://xhjiang.tech/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题-122.Best Time to Buy and Sell Stock II</title>
    <link href="https://xhjiang.tech/2018/11/20/leetcode%E5%88%B7%E9%A2%98-Best-Time-to-Buy-and-Sell-Stock-II/"/>
    <id>https://xhjiang.tech/2018/11/20/leetcode刷题-Best-Time-to-Buy-and-Sell-Stock-II/</id>
    <published>2018-11-20T06:22:32.000Z</published>
    <updated>2018-11-20T07:19:16.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II" class="headerlink" title="122.Best Time to Buy and Sell Stock II-买卖股票的最佳时机 II"></a>122.Best Time to Buy and Sell Stock II-买卖股票的最佳时机 II</h1><hr><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>贪心算法，总是做出在当前看来是最好的选择，不从整体最优上加以考虑，也就是说，只关心当前最优解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>,tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            tmp = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)</span><br><span class="line">                max += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>Tips:</em><br>我们要算的是利润，要有利润，自然要有一次交易。<br>所以我们就说说prices[1]，即是第一天股票价格。按照贪心策略，不关心以后，我们只关心当前利益。第0天买入，花费prices[0]，第一天卖出，得到prices[1]，那么我们的收获就是max = prices[1] - prices[0],那么有两种情况</p><p>1）当max &gt; 0 时，赶紧买入卖出，能赚一笔是一笔，苍蝇再小也是肉嘛 </p><p>2）当max &lt;= 0 时，再买入卖出的话，那就是傻了，白费力气不说，还亏钱。</p><p>以此方式类推下去，即得最大利润。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-II-买卖股票的最佳时机-II&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="leetcode" scheme="https://xhjiang.tech/categories/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/categories/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://xhjiang.tech/tags/leetcode/"/>
    
      <category term="数组" scheme="https://xhjiang.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://xhjiang.tech/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
